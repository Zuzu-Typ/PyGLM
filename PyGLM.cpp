#define PyGLM_VERSION "1.1.6"

#define PyGLM_LICENSE "PyGLM license information:\n"\
"\n"\
"================================================================================\n"\
"OpenGL Mathematics (GLM)\n"\
"--------------------------------------------------------------------------------\n"\
"This is a redistribution of OpenGL Mathematics (GLM), which is licensed under\n"\
"\n"\
"================================================================================\n"\
"The MIT License\n"\
"--------------------------------------------------------------------------------\n"\
"Copyright (c) 2005 G-Truc Creation\n"\
"\n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy\n"\
"of this software and associated documentation files (the \"Software\"), to deal\n"\
"in the Software without restriction, including without limitation the rights\n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"\
"copies of the Software, and to permit persons to whom the Software is\n"\
"furnished to do so, subject to the following conditions:\n"\
"\n"\
"The above copyright notice and this permission notice shall be included in\n"\
"all copies or substantial portions of the Software.\n"\
"\n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"\
"THE SOFTWARE.\n"\
"\n"\
"================================================================================\n"\
"PyGLM\n"\
"--------------------------------------------------------------------------------\n"\
"PyGLM is licensed under the zlib/libpng License\n"\
"\n"\
"================================================================================\n"\
"zlib/libpng license\n"\
"--------------------------------------------------------------------------------\n"\
"Copyright (c) 2017 Zuzu_Typ\n"\
"\n"\
"This software is provided 'as-is', without any express or implied\n"\
"warranty. In no event will the authors be held liable for any damages\n"\
"arising from the use of this software.\n"\
"\n"\
"Permission is granted to anyone to use this software for any purpose,\n"\
"including commercial applications, and to alter it and redistribute it\n"\
"freely, subject to the following restrictions:\n"\
"\n"\
"1. The origin of this software must not be misrepresented; you must not\n"\
"   claim that you wrote the original software. If you use this software\n"\
"   in a product, an acknowledgment in the product documentation would be\n"\
"   appreciated but is not required.\n"\
"2. Altered source versions must be plainly marked as such, and must not be\n"\
"   misrepresented as being the original software.\n"\
"3. This notice may not be removed or altered from any source distribution."


#define PyGLM_NO_FUNCTIONS 1
#define PyGLM_NO_ITER_TYPECHECKING 2

#define PyGLM_DEFAULT 0
#define PyGLM_FAST PyGLM_NO_ITER_TYPECHECKING
#define PyGLM_MINIMAL PyGLM_NO_FUNCTIONS | PyGLM_NO_ITER_TYPECHECKING

#define PyGLM_BUILD PyGLM_DEFAULT

#if (PyGLM_BUILD == PyGLM_DEFAULT)
#define PyGLM_BUILD_STRING "DEFAULT"
#elif (PyGLM_BUILD == PyGLM_FAST)
#define PyGLM_BUILD_STRING "FAST"
#elif (PyGLM_BUILD == PyGLM_NO_FUNCTIONS)
#define PyGLM_BUILD_STRING "NO_FUNCTIONS"
#elif (PyGLM_BUILD == PyGLM_MINIMAL)
#define PyGLM_BUILD_STRING "MINIMAL"
#else
#define PyGLM_BUILD_STRING "CUSTOM"
#endif

#include <Python.h>
#include "structmember.h"

#include <cstdlib>
#include <type_traits>
#include <stdint.h>

#define GLM_FORCE_CTOR_INIT
#define GLM_ENABLE_EXPERIMENTAL

#include <glm/glm.hpp>

#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/matrix_integer.hpp>

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)

// Stable extensions
#include <glm/ext/matrix_clip_space.hpp>
#include <glm/ext/matrix_common.hpp>
#include <glm/ext/matrix_projection.hpp>
#include <glm/ext/matrix_relational.hpp>
#include <glm/ext/matrix_transform.hpp>
#include <glm/ext/quaternion_common.hpp>
#include <glm/ext/quaternion_exponential.hpp>
#include <glm/ext/quaternion_geometric.hpp>
#include <glm/ext/quaternion_relational.hpp>
#include <glm/ext/quaternion_transform.hpp>
#include <glm/ext/quaternion_trigonometric.hpp>
#include <glm/ext/scalar_common.hpp>
#include <glm/ext/scalar_constants.hpp>
#include <glm/ext/scalar_relational.hpp>
#include <glm/ext/scalar_ulp.hpp>
#include <glm/ext/vector_common.hpp>
#include <glm/ext/vector_relational.hpp>
#include <glm/ext/vector_ulp.hpp>

// Recommended extensions
#include <glm/gtc/color_space.hpp>
#include <glm/gtc/constants.hpp>
#include <glm/gtc/epsilon.hpp>
#include <glm/gtc/integer.hpp>
#include <glm/gtc/matrix_access.hpp>
#include <glm/gtc/matrix_inverse.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/noise.hpp>
#include <glm/gtc/packing.hpp>
#include <glm/gtc/random.hpp>
#include <glm/gtc/reciprocal.hpp>
#include <glm/gtc/round.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/ulp.hpp>

// Unstable extensions
#include <glm/gtx/polar_coordinates.hpp>

#endif

#if GLM_COMPILER & GLM_COMPILER_VC
#pragma warning(push)
#pragma warning(disable : 4127)
#elif GLM_COMPILER & GLM_COMPILER_GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#elif GLM_COMPILER & GLM_COMPILER_CLANG
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmissing-braces"
#endif

//TYPES

#define UNBRACKET(...) __VA_ARGS__

// type identifiers
#define PyGLM_TYPE_UNKNOWN 0
#define PyGLM_TYPE_VEC 1
#define PyGLM_TYPE_MAT 2
#define PyGLM_TYPE_QUA 3

// type definitions
#pragma region type definitions
struct shape_helper {
	PyObject_HEAD
		uint8_t shape;
};

template<int L, typename T>
struct vec {
	PyObject_HEAD
		uint8_t shape;
	glm::vec<L, T> super_type;
};

template<int L, typename T>
struct vecIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	vec<L, T>* sequence;
};

struct mvec_helper {
	PyObject_HEAD
		uint8_t shape;
	void* super_type;
	PyObject* master;
};

template<int L, typename T>
struct mvec {
	PyObject_HEAD
		uint8_t shape;
		glm::vec<L, T>* super_type;
	PyObject* master;
};

template<int L, typename T>
struct mvecIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	mvec<L, T>* sequence;
};

template<int C, int R, typename T>
struct mat {
	PyObject_HEAD
		uint8_t shape;
		glm::mat<C, R, T> super_type;
};

template<int C, int R, typename T>
struct matIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	mat<C, R, T>* sequence;
};

template<typename T>
struct qua {
	PyObject_HEAD
		glm::qua<T> super_type;
};

template<typename T>
struct quaIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	qua<T>* sequence;
};
#pragma endregion

// forward declarations
#pragma region forward declarations
#pragma region vec
template<int L, typename T>
static int vec_getbuffer(vec<L, T>* self, Py_buffer* view, int flags);

void vec_releasebuffer(PyObject* self, Py_buffer* view);

template<int L>
static Py_ssize_t vec_len(PyObject* self);

template<typename T>
static PyObject* vec1_sq_item(vec<1, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec2_sq_item(vec<2, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec3_sq_item(vec<3, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec4_sq_item(vec<4, T> * self, Py_ssize_t index);

template<typename T>
static int vec1_sq_ass_item(vec<1, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec2_sq_ass_item(vec<2, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec3_sq_ass_item(vec<3, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec4_sq_ass_item(vec<4, T> * self, Py_ssize_t index, PyObject * value);

template<int L, typename T>
static int vec_contains(vec<L, T> * self, PyObject * value);

template<int L, typename T>
static PyObject * vec_add(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_sub(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_mul(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_mod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_divmod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * vec_neg(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_pos(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_abs(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_iadd(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_isub(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_imul(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_imod(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_ipow(vec<L, T>* self, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * vec_floordiv(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_div(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_ifloordiv(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_idiv(vec<L, T>* self, PyObject *obj);

static void vec_dealloc(PyObject* self);

static PyObject* generic_copy(PyObject* self, PyObject*);

static PyObject* generic_deepcopy(PyObject* self, PyObject* memo);

template<typename T>
static PyObject* vec1_str(vec<1, T>* self);
template<typename T>
static PyObject* vec2_str(vec<2, T>* self);
template<typename T>
static PyObject* vec3_str(vec<3, T>* self);
template<typename T>
static PyObject* vec4_str(vec<4, T>* self);

template<typename T>
static PyObject* vec1_repr(vec<1, T>* self);
template<typename T>
static PyObject* vec2_repr(vec<2, T>* self);
template<typename T>
static PyObject* vec3_repr(vec<3, T>* self);
template<typename T>
static PyObject* vec4_repr(vec<4, T>* self);

template<int L, typename T>
static PyObject* vec_getattr(PyObject* obj, PyObject* name);

template<int L, typename T>
static PyObject* vec_richcompare(vec<L, T>* self, PyObject* other, int comp_type);

template<int L, typename T>
static PyObject* vec_geniter(vec<L, T>* self);

template<typename T>
static int vec1_init(vec<1, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec2_init(vec<2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec3_init(vec<3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec4_init(vec<4, T> *self, PyObject *args, PyObject *kwds);

template<int L, typename T>
static PyObject* vec_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<int L, typename T>
static void vecIter_dealloc(vecIter<L, T> *rgstate);

template<typename T>
static PyObject* vec1Iter_next(vecIter<1, T> *rgstate);
template<typename T>
static PyObject* vec2Iter_next(vecIter<2, T> *rgstate);
template<typename T>
static PyObject* vec3Iter_next(vecIter<3, T> *rgstate);
template<typename T>
static PyObject* vec4Iter_next(vecIter<4, T> *rgstate);

template<int L, typename T>
static PyObject* vecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMemberDef hfvec1_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<1, float>), super_type.x), 0, (char*)"vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hfvec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec1NumMethods = {
	(binaryfunc)vec_add<1, float>, //nb_add
	(binaryfunc)vec_sub<1, float>, //nb_subtract
	(binaryfunc)vec_mul<1, float>, //nb_multiply
	(binaryfunc)vec_mod<1, float>, //nb_remainder
	(binaryfunc)vec_divmod<1, float>, //nb_divmod
	(ternaryfunc)vec_pow<1, float>, //nb_power
	(unaryfunc)vec_neg<1, float>, //nb_negative
	(unaryfunc)vec_pos<1, float>, //nb_positive
	(unaryfunc)vec_abs<1, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<1, float>, //nb_inplace_add
	(binaryfunc)vec_isub<1, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<1, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<1, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<1, float>, //nb_floor_divide
	(binaryfunc)vec_div<1, float>,
	(binaryfunc)vec_ifloordiv<1, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.vec1",             /* tp_name */
	sizeof(vec<1, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<float>,                         /* tp_repr */
	&hfvec1NumMethods,             /* tp_as_number */
	&hfvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfvec1_methods,             /* tp_methods */
	hfvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, float>,                 /* tp_new */
};
static PyTypeObject hfvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec1Iter",             /* tp_name */
	sizeof(vecIter<1, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, float>,                 /* tp_new */
};

static PyMemberDef hfvec2_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<2, float>), super_type.x), 0, (char*)"vec2.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<2, float>), super_type.y), 0, (char*)"vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hfvec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec2NumMethods = {
	(binaryfunc)vec_add<2, float>, //nb_add
	(binaryfunc)vec_sub<2, float>, //nb_subtract
	(binaryfunc)vec_mul<2, float>, //nb_multiply
	(binaryfunc)vec_mod<2, float>, //nb_remainder
	(binaryfunc)vec_divmod<2, float>, //nb_divmod
	(ternaryfunc)vec_pow<2, float>, //nb_power
	(unaryfunc)vec_neg<2, float>, //nb_negative
	(unaryfunc)vec_pos<2, float>, //nb_positive
	(unaryfunc)vec_abs<2, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<2, float>, //nb_inplace_add
	(binaryfunc)vec_isub<2, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<2, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<2, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<2, float>, //nb_floor_divide
	(binaryfunc)vec_div<2, float>,
	(binaryfunc)vec_ifloordiv<2, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.vec2",             /* tp_name */
	sizeof(vec<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<float>,                         /* tp_repr */
	&hfvec2NumMethods,             /* tp_as_number */
	&hfvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfvec2_methods,             /* tp_methods */
	hfvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, float>,                 /* tp_new */
};
static PyTypeObject hfvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec2Iter",             /* tp_name */
	sizeof(vecIter<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, float>,                 /* tp_new */
};

static PyMemberDef hfvec3_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.x), 0, (char*)"vec3.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.y), 0, (char*)"vec3.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.z), 0, (char*)"vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hfvec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec3NumMethods = {
	(binaryfunc)vec_add<3, float>, //nb_add
	(binaryfunc)vec_sub<3, float>, //nb_subtract
	(binaryfunc)vec_mul<3, float>, //nb_multiply
	(binaryfunc)vec_mod<3, float>, //nb_remainder
	(binaryfunc)vec_divmod<3, float>, //nb_divmod
	(ternaryfunc)vec_pow<3, float>, //nb_power
	(unaryfunc)vec_neg<3, float>, //nb_negative
	(unaryfunc)vec_pos<3, float>, //nb_positive
	(unaryfunc)vec_abs<3, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<3, float>, //nb_inplace_add
	(binaryfunc)vec_isub<3, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<3, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<3, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<3, float>, //nb_floor_divide
	(binaryfunc)vec_div<3, float>,
	(binaryfunc)vec_ifloordiv<3, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.vec3",             /* tp_name */
	sizeof(vec<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<float>,                         /* tp_repr */
	&hfvec3NumMethods,             /* tp_as_number */
	&hfvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfvec3_methods,             /* tp_methods */
	hfvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, float>,                 /* tp_new */
};
static PyTypeObject hfvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec3Iter",             /* tp_name */
	sizeof(vecIter<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, float>,                 /* tp_new */
};

static PyMemberDef hfvec4_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.x), 0, (char*)"vec4.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.y), 0, (char*)"vec4.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.z), 0, (char*)"vec4.z" },
	{ (char*)"w", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.w), 0, (char*)"vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hfvec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec4NumMethods = {
	(binaryfunc)vec_add<4, float>, //nb_add
	(binaryfunc)vec_sub<4, float>, //nb_subtract
	(binaryfunc)vec_mul<4, float>, //nb_multiply
	(binaryfunc)vec_mod<4, float>, //nb_remainder
	(binaryfunc)vec_divmod<4, float>, //nb_divmod
	(ternaryfunc)vec_pow<4, float>, //nb_power
	(unaryfunc)vec_neg<4, float>, //nb_negative
	(unaryfunc)vec_pos<4, float>, //nb_positive
	(unaryfunc)vec_abs<4, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<4, float>, //nb_inplace_add
	(binaryfunc)vec_isub<4, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<4, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<4, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<4, float>, //nb_floor_divide
	(binaryfunc)vec_div<4, float>,
	(binaryfunc)vec_ifloordiv<4, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.vec4",             /* tp_name */
	sizeof(vec<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<float>,                         /* tp_repr */
	&hfvec4NumMethods,             /* tp_as_number */
	&hfvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfvec4_methods,             /* tp_methods */
	hfvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, float>,                 /* tp_new */
};
static PyTypeObject hfvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec4Iter",             /* tp_name */
	sizeof(vecIter<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMemberDef hdvec1_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<1, double>), super_type.x), 0, (char*)"dvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hdvec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec1NumMethods = {
	(binaryfunc)vec_add<1, double>, //nb_add
	(binaryfunc)vec_sub<1, double>, //nb_subtract
	(binaryfunc)vec_mul<1, double>, //nb_multiply
	(binaryfunc)vec_mod<1, double>, //nb_remainder
	(binaryfunc)vec_divmod<1, double>, //nb_divmod
	(ternaryfunc)vec_pow<1, double>, //nb_power
	(unaryfunc)vec_neg<1, double>, //nb_negative
	(unaryfunc)vec_pos<1, double>, //nb_positive
	(unaryfunc)vec_abs<1, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<1, double>, //nb_inplace_add
	(binaryfunc)vec_isub<1, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<1, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<1, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<1, double>, //nb_floor_divide
	(binaryfunc)vec_div<1, double>,
	(binaryfunc)vec_ifloordiv<1, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dvec1",             /* tp_name */
	sizeof(vec<1, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<double>,                         /* tp_repr */
	&hdvec1NumMethods,             /* tp_as_number */
	&hdvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdvec1_methods,             /* tp_methods */
	hdvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, double>,                 /* tp_new */
};
static PyTypeObject hdvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec1Iter",             /* tp_name */
	sizeof(vecIter<1, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, double>,                 /* tp_new */
};

static PyMemberDef hdvec2_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<2, double>), super_type.x), 0, (char*)"dvec2.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<2, double>), super_type.y), 0, (char*)"dvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hdvec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec2NumMethods = {
	(binaryfunc)vec_add<2, double>, //nb_add
	(binaryfunc)vec_sub<2, double>, //nb_subtract
	(binaryfunc)vec_mul<2, double>, //nb_multiply
	(binaryfunc)vec_mod<2, double>, //nb_remainder
	(binaryfunc)vec_divmod<2, double>, //nb_divmod
	(ternaryfunc)vec_pow<2, double>, //nb_power
	(unaryfunc)vec_neg<2, double>, //nb_negative
	(unaryfunc)vec_pos<2, double>, //nb_positive
	(unaryfunc)vec_abs<2, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<2, double>, //nb_inplace_add
	(binaryfunc)vec_isub<2, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<2, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<2, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<2, double>, //nb_floor_divide
	(binaryfunc)vec_div<2, double>,
	(binaryfunc)vec_ifloordiv<2, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dvec2",             /* tp_name */
	sizeof(vec<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<double>,                         /* tp_repr */
	&hdvec2NumMethods,             /* tp_as_number */
	&hdvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdvec2_methods,             /* tp_methods */
	hdvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, double>,                 /* tp_new */
};
static PyTypeObject hdvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec2Iter",             /* tp_name */
	sizeof(vecIter<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, double>,                 /* tp_new */
};

static PyMemberDef hdvec3_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.x), 0, (char*)"dvec3.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.y), 0, (char*)"dvec3.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.z), 0, (char*)"dvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hdvec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec3NumMethods = {
	(binaryfunc)vec_add<3, double>, //nb_add
	(binaryfunc)vec_sub<3, double>, //nb_subtract
	(binaryfunc)vec_mul<3, double>, //nb_multiply
	(binaryfunc)vec_mod<3, double>, //nb_remainder
	(binaryfunc)vec_divmod<3, double>, //nb_divmod
	(ternaryfunc)vec_pow<3, double>, //nb_power
	(unaryfunc)vec_neg<3, double>, //nb_negative
	(unaryfunc)vec_pos<3, double>, //nb_positive
	(unaryfunc)vec_abs<3, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<3, double>, //nb_inplace_add
	(binaryfunc)vec_isub<3, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<3, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<3, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<3, double>, //nb_floor_divide
	(binaryfunc)vec_div<3, double>,
	(binaryfunc)vec_ifloordiv<3, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dvec3",             /* tp_name */
	sizeof(vec<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<double>,                         /* tp_repr */
	&hdvec3NumMethods,             /* tp_as_number */
	&hdvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdvec3_methods,             /* tp_methods */
	hdvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, double>,                 /* tp_new */
};
static PyTypeObject hdvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec3Iter",             /* tp_name */
	sizeof(vecIter<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, double>,                 /* tp_new */
};

static PyMemberDef hdvec4_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.x), 0, (char*)"dvec4.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.y), 0, (char*)"dvec4.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.z), 0, (char*)"dvec4.z" },
	{ (char*)"w", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.w), 0, (char*)"dvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hdvec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec4NumMethods = {
	(binaryfunc)vec_add<4, double>, //nb_add
	(binaryfunc)vec_sub<4, double>, //nb_subtract
	(binaryfunc)vec_mul<4, double>, //nb_multiply
	(binaryfunc)vec_mod<4, double>, //nb_remainder
	(binaryfunc)vec_divmod<4, double>, //nb_divmod
	(ternaryfunc)vec_pow<4, double>, //nb_power
	(unaryfunc)vec_neg<4, double>, //nb_negative
	(unaryfunc)vec_pos<4, double>, //nb_positive
	(unaryfunc)vec_abs<4, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<4, double>, //nb_inplace_add
	(binaryfunc)vec_isub<4, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<4, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<4, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<4, double>, //nb_floor_divide
	(binaryfunc)vec_div<4, double>,
	(binaryfunc)vec_ifloordiv<4, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dvec4",             /* tp_name */
	sizeof(vec<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<double>,                         /* tp_repr */
	&hdvec4NumMethods,             /* tp_as_number */
	&hdvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdvec4_methods,             /* tp_methods */
	hdvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, double>,                 /* tp_new */
};
static PyTypeObject hdvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec4Iter",             /* tp_name */
	sizeof(vecIter<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region int8
static PyMemberDef hi8vec1_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<1, glm::i8>), super_type.x), 0, (char*)"i8vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi8vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i8>, //nb_add
	(binaryfunc)vec_sub<1, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i8vec1",             /* tp_name */
	sizeof(vec<1, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::i8>,                         /* tp_repr */
	&hi8vec1NumMethods,             /* tp_as_number */
	&hi8vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi8vec1_methods,             /* tp_methods */
	hi8vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec2_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<2, glm::i8>), super_type.x), 0, (char*)"i8vec2.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<2, glm::i8>), super_type.y), 0, (char*)"i8vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi8vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i8>, //nb_add
	(binaryfunc)vec_sub<2, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i8vec2",             /* tp_name */
	sizeof(vec<2, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::i8>,                         /* tp_repr */
	&hi8vec2NumMethods,             /* tp_as_number */
	&hi8vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi8vec2_methods,             /* tp_methods */
	hi8vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec3_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.x), 0, (char*)"i8vec3.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.y), 0, (char*)"i8vec3.y" },
	{ (char*)"z", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.z), 0, (char*)"i8vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi8vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i8>, //nb_add
	(binaryfunc)vec_sub<3, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i8vec3",             /* tp_name */
	sizeof(vec<3, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::i8>,                         /* tp_repr */
	&hi8vec3NumMethods,             /* tp_as_number */
	&hi8vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi8vec3_methods,             /* tp_methods */
	hi8vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec4_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.x), 0, (char*)"i8vec4.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.y), 0, (char*)"i8vec4.y" },
	{ (char*)"z", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.z), 0, (char*)"i8vec4.z" },
	{ (char*)"w", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.w), 0, (char*)"i8vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi8vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i8>, //nb_add
	(binaryfunc)vec_sub<4, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i8vec4",             /* tp_name */
	sizeof(vec<4, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::i8>,                         /* tp_repr */
	&hi8vec4NumMethods,             /* tp_as_number */
	&hi8vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi8vec4_methods,             /* tp_methods */
	hi8vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i8>,                 /* tp_new */
};
#pragma endregion
#pragma region int16
static PyMemberDef hi16vec1_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<1, glm::i16>), super_type.x), 0, (char*)"i16vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi16vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i16>, //nb_add
	(binaryfunc)vec_sub<1, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i16vec1",             /* tp_name */
	sizeof(vec<1, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::i16>,                         /* tp_repr */
	&hi16vec1NumMethods,             /* tp_as_number */
	&hi16vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi16vec1_methods,             /* tp_methods */
	hi16vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec2_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<2, glm::i16>), super_type.x), 0, (char*)"i16vec2.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<2, glm::i16>), super_type.y), 0, (char*)"i16vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi16vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i16>, //nb_add
	(binaryfunc)vec_sub<2, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i16vec2",             /* tp_name */
	sizeof(vec<2, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::i16>,                         /* tp_repr */
	&hi16vec2NumMethods,             /* tp_as_number */
	&hi16vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi16vec2_methods,             /* tp_methods */
	hi16vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec3_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.x), 0, (char*)"i16vec3.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.y), 0, (char*)"i16vec3.y" },
	{ (char*)"z", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.z), 0, (char*)"i16vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi16vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i16>, //nb_add
	(binaryfunc)vec_sub<3, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i16vec3",             /* tp_name */
	sizeof(vec<3, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::i16>,                         /* tp_repr */
	&hi16vec3NumMethods,             /* tp_as_number */
	&hi16vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi16vec3_methods,             /* tp_methods */
	hi16vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec4_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.x), 0, (char*)"i16vec4.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.y), 0, (char*)"i16vec4.y" },
	{ (char*)"z", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.z), 0, (char*)"i16vec4.z" },
	{ (char*)"w", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.w), 0, (char*)"i16vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi16vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i16>, //nb_add
	(binaryfunc)vec_sub<4, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i16vec4",             /* tp_name */
	sizeof(vec<4, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::i16>,                         /* tp_repr */
	&hi16vec4NumMethods,             /* tp_as_number */
	&hi16vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi16vec4_methods,             /* tp_methods */
	hi16vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i16>,                 /* tp_new */
};
#pragma endregion
#pragma region int32
static PyMemberDef hivec1_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<1, glm::i32>), super_type.x), 0, (char*)"ivec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hivec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i32>, //nb_add
	(binaryfunc)vec_sub<1, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.ivec1",             /* tp_name */
	sizeof(vec<1, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::i32>,                         /* tp_repr */
	&hivec1NumMethods,             /* tp_as_number */
	&hivec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hivec1_methods,             /* tp_methods */
	hivec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec2_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<2, glm::i32>), super_type.x), 0, (char*)"ivec2.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<2, glm::i32>), super_type.y), 0, (char*)"ivec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hivec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i32>, //nb_add
	(binaryfunc)vec_sub<2, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.ivec2",             /* tp_name */
	sizeof(vec<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::i32>,                         /* tp_repr */
	&hivec2NumMethods,             /* tp_as_number */
	&hivec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hivec2_methods,             /* tp_methods */
	hivec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec3_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.x), 0, (char*)"ivec3.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.y), 0, (char*)"ivec3.y" },
	{ (char*)"z", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.z), 0, (char*)"ivec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hivec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i32>, //nb_add
	(binaryfunc)vec_sub<3, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.ivec3",             /* tp_name */
	sizeof(vec<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::i32>,                         /* tp_repr */
	&hivec3NumMethods,             /* tp_as_number */
	&hivec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hivec3_methods,             /* tp_methods */
	hivec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec4_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.x), 0, (char*)"ivec4.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.y), 0, (char*)"ivec4.y" },
	{ (char*)"z", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.z), 0, (char*)"ivec4.z" },
	{ (char*)"w", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.w), 0, (char*)"ivec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hivec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i32>, //nb_add
	(binaryfunc)vec_sub<4, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.ivec4",             /* tp_name */
	sizeof(vec<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::i32>,                         /* tp_repr */
	&hivec4NumMethods,             /* tp_as_number */
	&hivec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hivec4_methods,             /* tp_methods */
	hivec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region int64
static PyMemberDef hi64vec1_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<1, glm::i64>), super_type.x), 0, (char*)"i64vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi64vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i64>, //nb_add
	(binaryfunc)vec_sub<1, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i64vec1",             /* tp_name */
	sizeof(vec<1, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::i64>,                         /* tp_repr */
	&hi64vec1NumMethods,             /* tp_as_number */
	&hi64vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi64vec1_methods,             /* tp_methods */
	hi64vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec2_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<2, glm::i64>), super_type.x), 0, (char*)"i64vec2.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<2, glm::i64>), super_type.y), 0, (char*)"i64vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi64vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i64>, //nb_add
	(binaryfunc)vec_sub<2, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i64vec2",             /* tp_name */
	sizeof(vec<2, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::i64>,                         /* tp_repr */
	&hi64vec2NumMethods,             /* tp_as_number */
	&hi64vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi64vec2_methods,             /* tp_methods */
	hi64vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec3_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.x), 0, (char*)"i64vec3.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.y), 0, (char*)"i64vec3.y" },
	{ (char*)"z", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.z), 0, (char*)"i64vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi64vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i64>, //nb_add
	(binaryfunc)vec_sub<3, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i64vec3",             /* tp_name */
	sizeof(vec<3, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::i64>,                         /* tp_repr */
	&hi64vec3NumMethods,             /* tp_as_number */
	&hi64vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi64vec3_methods,             /* tp_methods */
	hi64vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec4_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.x), 0, (char*)"i64vec4.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.y), 0, (char*)"i64vec4.y" },
	{ (char*)"z", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.z), 0, (char*)"i64vec4.z" },
	{ (char*)"w", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.w), 0, (char*)"i64vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hi64vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i64>, //nb_add
	(binaryfunc)vec_sub<4, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.i64vec4",             /* tp_name */
	sizeof(vec<4, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::i64>,                         /* tp_repr */
	&hi64vec4NumMethods,             /* tp_as_number */
	&hi64vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hi64vec4_methods,             /* tp_methods */
	hi64vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i64>,                 /* tp_new */
};
#pragma endregion
#pragma region uint8
static PyMemberDef hu8vec1_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<1, glm::u8>), super_type.x), 0, (char*)"u8vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu8vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u8>, //nb_add
	(binaryfunc)vec_sub<1, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u8vec1",             /* tp_name */
	sizeof(vec<1, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::u8>,                         /* tp_repr */
	&hu8vec1NumMethods,             /* tp_as_number */
	&hu8vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu8vec1_methods,             /* tp_methods */
	hu8vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec2_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<2, glm::u8>), super_type.x), 0, (char*)"u8vec2.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<2, glm::u8>), super_type.y), 0, (char*)"u8vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu8vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u8>, //nb_add
	(binaryfunc)vec_sub<2, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u8vec2",             /* tp_name */
	sizeof(vec<2, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::u8>,                         /* tp_repr */
	&hu8vec2NumMethods,             /* tp_as_number */
	&hu8vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu8vec2_methods,             /* tp_methods */
	hu8vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec3_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.x), 0, (char*)"u8vec3.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.y), 0, (char*)"u8vec3.y" },
	{ (char*)"z", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.z), 0, (char*)"u8vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu8vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u8>, //nb_add
	(binaryfunc)vec_sub<3, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u8vec3",             /* tp_name */
	sizeof(vec<3, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::u8>,                         /* tp_repr */
	&hu8vec3NumMethods,             /* tp_as_number */
	&hu8vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu8vec3_methods,             /* tp_methods */
	hu8vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec4_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.x), 0, (char*)"u8vec4.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.y), 0, (char*)"u8vec4.y" },
	{ (char*)"z", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.z), 0, (char*)"u8vec4.z" },
	{ (char*)"w", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.w), 0, (char*)"u8vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu8vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u8>, //nb_add
	(binaryfunc)vec_sub<4, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u8vec4",             /* tp_name */
	sizeof(vec<4, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::u8>,                         /* tp_repr */
	&hu8vec4NumMethods,             /* tp_as_number */
	&hu8vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu8vec4_methods,             /* tp_methods */
	hu8vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u8>,                 /* tp_new */
};
#pragma endregion
#pragma region uint16
static PyMemberDef hu16vec1_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<1, glm::u16>), super_type.x), 0, (char*)"u16vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu16vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u16>, //nb_add
	(binaryfunc)vec_sub<1, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u16vec1",             /* tp_name */
	sizeof(vec<1, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::u16>,                         /* tp_repr */
	&hu16vec1NumMethods,             /* tp_as_number */
	&hu16vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu16vec1_methods,             /* tp_methods */
	hu16vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec2_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<2, glm::u16>), super_type.x), 0, (char*)"u16vec2.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<2, glm::u16>), super_type.y), 0, (char*)"u16vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu16vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u16>, //nb_add
	(binaryfunc)vec_sub<2, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u16vec2",             /* tp_name */
	sizeof(vec<2, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::u16>,                         /* tp_repr */
	&hu16vec2NumMethods,             /* tp_as_number */
	&hu16vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu16vec2_methods,             /* tp_methods */
	hu16vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec3_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.x), 0, (char*)"u16vec3.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.y), 0, (char*)"u16vec3.y" },
	{ (char*)"z", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.z), 0, (char*)"u16vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu16vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u16>, //nb_add
	(binaryfunc)vec_sub<3, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u16vec3",             /* tp_name */
	sizeof(vec<3, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::u16>,                         /* tp_repr */
	&hu16vec3NumMethods,             /* tp_as_number */
	&hu16vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu16vec3_methods,             /* tp_methods */
	hu16vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec4_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.x), 0, (char*)"u16vec4.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.y), 0, (char*)"u16vec4.y" },
	{ (char*)"z", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.z), 0, (char*)"u16vec4.z" },
	{ (char*)"w", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.w), 0, (char*)"u16vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu16vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u16>, //nb_add
	(binaryfunc)vec_sub<4, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u16vec4",             /* tp_name */
	sizeof(vec<4, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::u16>,                         /* tp_repr */
	&hu16vec4NumMethods,             /* tp_as_number */
	&hu16vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu16vec4_methods,             /* tp_methods */
	hu16vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u16>,                 /* tp_new */
};
#pragma endregion
#pragma region uint32
static PyMemberDef huvec1_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<1, glm::u32>), super_type.x), 0, (char*)"uvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef huvec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u32>, //nb_add
	(binaryfunc)vec_sub<1, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.uvec1",             /* tp_name */
	sizeof(vec<1, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::u32>,                         /* tp_repr */
	&huvec1NumMethods,             /* tp_as_number */
	&huvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	huvec1_methods,             /* tp_methods */
	huvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec2_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<2, glm::u32>), super_type.x), 0, (char*)"uvec2.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<2, glm::u32>), super_type.y), 0, (char*)"uvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef huvec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u32>, //nb_add
	(binaryfunc)vec_sub<2, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.uvec2",             /* tp_name */
	sizeof(vec<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::u32>,                         /* tp_repr */
	&huvec2NumMethods,             /* tp_as_number */
	&huvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	huvec2_methods,             /* tp_methods */
	huvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec3_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.x), 0, (char*)"uvec3.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.y), 0, (char*)"uvec3.y" },
	{ (char*)"z", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.z), 0, (char*)"uvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef huvec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u32>, //nb_add
	(binaryfunc)vec_sub<3, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.uvec3",             /* tp_name */
	sizeof(vec<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::u32>,                         /* tp_repr */
	&huvec3NumMethods,             /* tp_as_number */
	&huvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	huvec3_methods,             /* tp_methods */
	huvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec4_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.x), 0, (char*)"uvec4.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.y), 0, (char*)"uvec4.y" },
	{ (char*)"z", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.z), 0, (char*)"uvec4.z" },
	{ (char*)"w", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.w), 0, (char*)"uvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef huvec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u32>, //nb_add
	(binaryfunc)vec_sub<4, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.uvec4",             /* tp_name */
	sizeof(vec<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::u32>,                         /* tp_repr */
	&huvec4NumMethods,             /* tp_as_number */
	&huvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	huvec4_methods,             /* tp_methods */
	huvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma region uint64
static PyMemberDef hu64vec1_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<1, glm::u64>), super_type.x), 0, (char*)"u64vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu64vec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u64>, //nb_add
	(binaryfunc)vec_sub<1, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u64vec1",             /* tp_name */
	sizeof(vec<1, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<glm::u64>,                         /* tp_repr */
	&hu64vec1NumMethods,             /* tp_as_number */
	&hu64vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu64vec1_methods,             /* tp_methods */
	hu64vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec2_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<2, glm::u64>), super_type.x), 0, (char*)"u64vec2.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<2, glm::u64>), super_type.y), 0, (char*)"u64vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu64vec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u64>, //nb_add
	(binaryfunc)vec_sub<2, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u64vec2",             /* tp_name */
	sizeof(vec<2, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<glm::u64>,                         /* tp_repr */
	&hu64vec2NumMethods,             /* tp_as_number */
	&hu64vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu64vec2_methods,             /* tp_methods */
	hu64vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec3_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.x), 0, (char*)"u64vec3.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.y), 0, (char*)"u64vec3.y" },
	{ (char*)"z", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.z), 0, (char*)"u64vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu64vec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u64>, //nb_add
	(binaryfunc)vec_sub<3, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u64vec3",             /* tp_name */
	sizeof(vec<3, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<glm::u64>,                         /* tp_repr */
	&hu64vec3NumMethods,             /* tp_as_number */
	&hu64vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu64vec3_methods,             /* tp_methods */
	hu64vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec4_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.x), 0, (char*)"u64vec4.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.y), 0, (char*)"u64vec4.y" },
	{ (char*)"z", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.z), 0, (char*)"u64vec4.z" },
	{ (char*)"w", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.w), 0, (char*)"u64vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hu64vec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u64>, //nb_add
	(binaryfunc)vec_sub<4, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.u64vec4",             /* tp_name */
	sizeof(vec<4, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<glm::u64>,                         /* tp_repr */
	&hu64vec4NumMethods,             /* tp_as_number */
	&hu64vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hu64vec4_methods,             /* tp_methods */
	hu64vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u64>,                 /* tp_new */
};
#pragma endregion
#pragma region bool
static PyMemberDef hbvec1_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<1, bool>), super_type.x), 0, (char*)"bvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hbvec1_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.bvec1",             /* tp_name */
	sizeof(vec<1, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_repr<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hbvec1_methods,             /* tp_methods */
	hbvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, bool>,                 /* tp_new */
};
static PyTypeObject hbvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec1Iter",             /* tp_name */
	sizeof(vecIter<1, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, bool>,                 /* tp_new */
};

static PyMemberDef hbvec2_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<2, bool>), super_type.x), 0, (char*)"bvec2.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<2, bool>), super_type.y), 0, (char*)"bvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hbvec2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.bvec2",             /* tp_name */
	sizeof(vec<2, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_repr<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hbvec2_methods,             /* tp_methods */
	hbvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, bool>,                 /* tp_new */
};
static PyTypeObject hbvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec2Iter",             /* tp_name */
	sizeof(vecIter<2, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, bool>,                 /* tp_new */
};

static PyMemberDef hbvec3_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.x), 0, (char*)"bvec3.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.y), 0, (char*)"bvec3.y" },
	{ (char*)"z", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.z), 0, (char*)"bvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hbvec3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.bvec3",             /* tp_name */
	sizeof(vec<3, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_repr<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hbvec3_methods,             /* tp_methods */
	hbvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, bool>,                 /* tp_new */
};
static PyTypeObject hbvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec3Iter",             /* tp_name */
	sizeof(vecIter<3, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, bool>,                 /* tp_new */
};

static PyMemberDef hbvec4_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.x), 0, (char*)"bvec4.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.y), 0, (char*)"bvec4.y" },
	{ (char*)"z", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.z), 0, (char*)"bvec4.z" },
	{ (char*)"w", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.w), 0, (char*)"bvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyMethodDef hbvec4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.bvec4",             /* tp_name */
	sizeof(vec<4, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_repr<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hbvec4_methods,             /* tp_methods */
	hbvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, bool>,                 /* tp_new */
};
static PyTypeObject hbvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec4Iter",             /* tp_name */
	sizeof(vecIter<4, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, bool>,                 /* tp_new */
};
#pragma endregion

#pragma endregion
#pragma region mvec
template<int L, typename T>
static int mvec_getbuffer(mvec<L, T>* self, Py_buffer* view, int flags);

void mvec_releasebuffer(PyObject* self, Py_buffer* view);

template<int L>
static Py_ssize_t mvec_len(PyObject* self);

template<typename T>
static PyObject* mvec2_sq_item(mvec<2, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* mvec3_sq_item(mvec<3, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* mvec4_sq_item(mvec<4, T> * self, Py_ssize_t index);

template<typename T>
static int mvec2_sq_ass_item(mvec<2, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int mvec3_sq_ass_item(mvec<3, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int mvec4_sq_ass_item(mvec<4, T> * self, Py_ssize_t index, PyObject * value);

template<int L, typename T>
static int mvec_contains(mvec<L, T> * self, PyObject * value);

template<int L, typename T>
static PyObject * mvec_add(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_sub(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_mul(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_mod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_divmod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * mvec_neg(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_pos(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_abs(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_iadd(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_isub(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_imul(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_imod(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_ipow(mvec<L, T>* self, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * mvec_floordiv(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_div(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_ifloordiv(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_idiv(mvec<L, T>* self, PyObject *obj);

static void mvec_dealloc(PyObject* self);

template<int L, typename T>
static PyObject* mvec_copy(PyObject* self, PyObject*);

template<int L, typename T>
static PyObject* mvec_deepcopy(PyObject* self, PyObject* memo);

template<typename T>
static PyObject* mvec2_str(mvec<2, T>* self);
template<typename T>
static PyObject* mvec3_str(mvec<3, T>* self);
template<typename T>
static PyObject* mvec4_str(mvec<4, T>* self);

template<int L, typename T>
static PyObject* mvec_getattr(PyObject* obj, PyObject* name);

template<typename T>
static int mvec2_setattr(mvec<2, T>* obj, PyObject* name, PyObject* value);
template<typename T>
static int mvec3_setattr(mvec<3, T>* obj, PyObject* name, PyObject* value);
template<typename T>
static int mvec4_setattr(mvec<4, T>* obj, PyObject* name, PyObject* value);

template<int L, typename T>
static PyObject* mvec_richcompare(mvec<L, T>* self, PyObject* other, int comp_type);

template<int L, typename T>
static PyObject* mvec_geniter(mvec<L, T>* self);

template<int L, typename T>
static void mvecIter_dealloc(mvecIter<L, T> *rgstate);

template<typename T>
static PyObject* mvec2Iter_next(mvecIter<2, T> *rgstate);
template<typename T>
static PyObject* mvec3Iter_next(mvecIter<3, T> *rgstate);
template<typename T>
static PyObject* mvec4Iter_next(mvecIter<4, T> *rgstate);

template<int L, typename T>
static PyObject* mvecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMethodDef hfmvec2_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<2, float>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<2, float>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfmvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec2NumMethods = {
	(binaryfunc)mvec_add<2, float>, //nb_add
	(binaryfunc)mvec_sub<2, float>, //nb_subtract
	(binaryfunc)mvec_mul<2, float>, //nb_multiply
	(binaryfunc)mvec_mod<2, float>, //nb_remainder
	(binaryfunc)mvec_divmod<2, float>, //nb_divmod
	(ternaryfunc)mvec_pow<2, float>, //nb_power
	(unaryfunc)mvec_neg<2, float>, //nb_negative
	(unaryfunc)mvec_pos<2, float>, //nb_positive
	(unaryfunc)mvec_abs<2, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<2, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<2, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<2, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<2, float>, //nb_floor_divide
	(binaryfunc)mvec_div<2, float>,
	(binaryfunc)mvec_ifloordiv<2, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mvec2",             /* tp_name */
	sizeof(mvec<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<float>,                         /* tp_repr */
	&hfmvec2NumMethods,             /* tp_as_number */
	&hfmvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, float>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<float>,                         /* tp_setattro */
	&hfmvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmvec2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, float>,                 /* tp_new */
};

static PyMethodDef hfmvec3_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<3, float>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<3, float>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfmvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec3NumMethods = {
	(binaryfunc)mvec_add<3, float>, //nb_add
	(binaryfunc)mvec_sub<3, float>, //nb_subtract
	(binaryfunc)mvec_mul<3, float>, //nb_multiply
	(binaryfunc)mvec_mod<3, float>, //nb_remainder
	(binaryfunc)mvec_divmod<3, float>, //nb_divmod
	(ternaryfunc)mvec_pow<3, float>, //nb_power
	(unaryfunc)mvec_neg<3, float>, //nb_negative
	(unaryfunc)mvec_pos<3, float>, //nb_positive
	(unaryfunc)mvec_abs<3, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<3, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<3, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<3, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<3, float>, //nb_floor_divide
	(binaryfunc)mvec_div<3, float>,
	(binaryfunc)mvec_ifloordiv<3, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mvec3",             /* tp_name */
	sizeof(mvec<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<float>,                         /* tp_repr */
	&hfmvec3NumMethods,             /* tp_as_number */
	&hfmvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, float>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<float>,                         /* tp_setattro */
	&hfmvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmvec3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, float>,                 /* tp_new */
};

static PyMethodDef hfmvec4_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<4, float>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<4, float>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfmvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec4NumMethods = {
	(binaryfunc)mvec_add<4, float>, //nb_add
	(binaryfunc)mvec_sub<4, float>, //nb_subtract
	(binaryfunc)mvec_mul<4, float>, //nb_multiply
	(binaryfunc)mvec_mod<4, float>, //nb_remainder
	(binaryfunc)mvec_divmod<4, float>, //nb_divmod
	(ternaryfunc)mvec_pow<4, float>, //nb_power
	(unaryfunc)mvec_neg<4, float>, //nb_negative
	(unaryfunc)mvec_pos<4, float>, //nb_positive
	(unaryfunc)mvec_abs<4, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<4, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<4, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<4, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<4, float>, //nb_floor_divide
	(binaryfunc)mvec_div<4, float>,
	(binaryfunc)mvec_ifloordiv<4, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mvec4",             /* tp_name */
	sizeof(mvec<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<float>,                         /* tp_repr */
	&hfmvec4NumMethods,             /* tp_as_number */
	&hfmvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, float>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<float>,                         /* tp_setattro */
	&hfmvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmvec4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMethodDef hdmvec2_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<2, double>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<2, double>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdmvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec2NumMethods = {
	(binaryfunc)mvec_add<2, double>, //nb_add
	(binaryfunc)mvec_sub<2, double>, //nb_subtract
	(binaryfunc)mvec_mul<2, double>, //nb_multiply
	(binaryfunc)mvec_mod<2, double>, //nb_remainder
	(binaryfunc)mvec_divmod<2, double>, //nb_divmod
	(ternaryfunc)mvec_pow<2, double>, //nb_power
	(unaryfunc)mvec_neg<2, double>, //nb_negative
	(unaryfunc)mvec_pos<2, double>, //nb_positive
	(unaryfunc)mvec_abs<2, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<2, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<2, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<2, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<2, double>, //nb_floor_divide
	(binaryfunc)mvec_div<2, double>,
	(binaryfunc)mvec_ifloordiv<2, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmvec2",             /* tp_name */
	sizeof(mvec<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<double>,                         /* tp_repr */
	&hdmvec2NumMethods,             /* tp_as_number */
	&hdmvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, double>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<double>,                         /* tp_setattro */
	&hdmvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmvec2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, double>,                 /* tp_new */
};

static PyMethodDef hdmvec3_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<3, double>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<3, double>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdmvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec3NumMethods = {
	(binaryfunc)mvec_add<3, double>, //nb_add
	(binaryfunc)mvec_sub<3, double>, //nb_subtract
	(binaryfunc)mvec_mul<3, double>, //nb_multiply
	(binaryfunc)mvec_mod<3, double>, //nb_remainder
	(binaryfunc)mvec_divmod<3, double>, //nb_divmod
	(ternaryfunc)mvec_pow<3, double>, //nb_power
	(unaryfunc)mvec_neg<3, double>, //nb_negative
	(unaryfunc)mvec_pos<3, double>, //nb_positive
	(unaryfunc)mvec_abs<3, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<3, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<3, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<3, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<3, double>, //nb_floor_divide
	(binaryfunc)mvec_div<3, double>,
	(binaryfunc)mvec_ifloordiv<3, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmvec3",             /* tp_name */
	sizeof(mvec<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<double>,                         /* tp_repr */
	&hdmvec3NumMethods,             /* tp_as_number */
	&hdmvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, double>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<double>,                         /* tp_setattro */
	&hdmvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmvec3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, double>,                 /* tp_new */
};

static PyMethodDef hdmvec4_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<4, double>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<4, double>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdmvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec4NumMethods = {
	(binaryfunc)mvec_add<4, double>, //nb_add
	(binaryfunc)mvec_sub<4, double>, //nb_subtract
	(binaryfunc)mvec_mul<4, double>, //nb_multiply
	(binaryfunc)mvec_mod<4, double>, //nb_remainder
	(binaryfunc)mvec_divmod<4, double>, //nb_divmod
	(ternaryfunc)mvec_pow<4, double>, //nb_power
	(unaryfunc)mvec_neg<4, double>, //nb_negative
	(unaryfunc)mvec_pos<4, double>, //nb_positive
	(unaryfunc)mvec_abs<4, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<4, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<4, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<4, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<4, double>, //nb_floor_divide
	(binaryfunc)mvec_div<4, double>,
	(binaryfunc)mvec_ifloordiv<4, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmvec4",             /* tp_name */
	sizeof(mvec<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<double>,                         /* tp_repr */
	&hdmvec4NumMethods,             /* tp_as_number */
	&hdmvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, double>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<double>,                         /* tp_setattro */
	&hdmvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmvec4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region int32
static PyMethodDef himvec2_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<2, glm::i32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<2, glm::i32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs himvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec2NumMethods = {
	(binaryfunc)mvec_add<2, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<2, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<2, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<2, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<2, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<2, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imvec2",             /* tp_name */
	sizeof(mvec<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<glm::i32>,                         /* tp_repr */
	&himvec2NumMethods,             /* tp_as_number */
	&himvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<glm::i32>,                         /* tp_setattro */
	&himvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himvec2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himvec3_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<3, glm::i32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<3, glm::i32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs himvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec3NumMethods = {
	(binaryfunc)mvec_add<3, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<3, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<3, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<3, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<3, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<3, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imvec3",             /* tp_name */
	sizeof(mvec<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<glm::i32>,                         /* tp_repr */
	&himvec3NumMethods,             /* tp_as_number */
	&himvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<glm::i32>,                         /* tp_setattro */
	&himvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himvec3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himvec4_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<4, glm::i32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<4, glm::i32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs himvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec4NumMethods = {
	(binaryfunc)mvec_add<4, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<4, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<4, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<4, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<4, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<4, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imvec4",             /* tp_name */
	sizeof(mvec<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<glm::i32>,                         /* tp_repr */
	&himvec4NumMethods,             /* tp_as_number */
	&himvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<glm::i32>,                         /* tp_setattro */
	&himvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himvec4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region uint32
static PyMethodDef humvec2_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<2, glm::u32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<2, glm::u32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs humvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec2NumMethods = {
	(binaryfunc)mvec_add<2, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<2, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<2, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<2, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<2, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umvec2",             /* tp_name */
	sizeof(mvec<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<glm::u32>,                         /* tp_repr */
	&humvec2NumMethods,             /* tp_as_number */
	&humvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<glm::u32>,                         /* tp_setattro */
	&humvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humvec2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humvec3_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<3, glm::u32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<3, glm::u32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs humvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec3NumMethods = {
	(binaryfunc)mvec_add<3, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<3, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<3, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<3, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<3, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umvec3",             /* tp_name */
	sizeof(mvec<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<glm::u32>,                         /* tp_repr */
	&humvec3NumMethods,             /* tp_as_number */
	&humvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<glm::u32>,                         /* tp_setattro */
	&humvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humvec3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humvec4_methods[] = {
	{ "__copy__", (PyCFunction)mvec_copy<4, glm::u32>, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)mvec_deepcopy<4, glm::u32>, METH_O, "Create a (deep)copy of this instance"},
	{ NULL }  /* Sentinel */
};
static PyBufferProcs humvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec4NumMethods = {
	(binaryfunc)mvec_add<4, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<4, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<4, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<4, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<4, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umvec4",             /* tp_name */
	sizeof(mvec<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<glm::u32>,                         /* tp_repr */
	&humvec4NumMethods,             /* tp_as_number */
	&humvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<glm::u32>,                         /* tp_setattro */
	&humvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humvec4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma region mat
template<int C>
static PyObject* mat_length(PyObject * self, PyObject* arg);

template<int C, int R, typename T>
static int mat_getbuffer(mat<C, R, T>* self, Py_buffer* view, int flags);

void mat_releasebuffer(PyObject* self, Py_buffer* view);

template<int C>
static Py_ssize_t mat_len(PyObject* self);

template<typename T>
static PyObject* mat2x2_mp_item(mat<2, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat2x3_mp_item(mat<2, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat2x4_mp_item(mat<2, 4, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x2_mp_item(mat<3, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x3_mp_item(mat<3, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x4_mp_item(mat<3, 4, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x2_mp_item(mat<4, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x3_mp_item(mat<4, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x4_mp_item(mat<4, 4, T> * self, PyObject* key);

template<typename T>
static int mat2x2_mp_ass_item(mat<2, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat2x3_mp_ass_item(mat<2, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat2x4_mp_ass_item(mat<2, 4, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x2_mp_ass_item(mat<3, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x3_mp_ass_item(mat<3, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x4_mp_ass_item(mat<3, 4, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x2_mp_ass_item(mat<4, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x3_mp_ass_item(mat<4, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x4_mp_ass_item(mat<4, 4, T> * self, PyObject* key, PyObject * value);

template<int C, int R, typename T>
static int mat_contains(mat<C, R, T> * self, PyObject * value);

template<int C, int R, typename T>
static PyObject * matsq_add(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_add(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_sub(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_sub(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_mul(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_neg(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * mat_pos(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * mat_abs(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * matsq_iadd(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_iadd(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * matsq_isub(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_isub(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_imul(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_div(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_div(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_idiv(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_idiv(mat<C, R, T>* self, PyObject *obj);

static void mat_dealloc(PyObject* self);

template<typename T>
static PyObject* mat2x2_str(mat<2, 2, T>* self);
template<typename T>
static PyObject* mat2x3_str(mat<2, 3, T>* self);
template<typename T>
static PyObject* mat2x4_str(mat<2, 4, T>* self);
template<typename T>
static PyObject* mat3x2_str(mat<3, 2, T>* self);
template<typename T>
static PyObject* mat3x3_str(mat<3, 3, T>* self);
template<typename T>
static PyObject* mat3x4_str(mat<3, 4, T>* self);
template<typename T>
static PyObject* mat4x2_str(mat<4, 2, T>* self);
template<typename T>
static PyObject* mat4x3_str(mat<4, 3, T>* self);
template<typename T>
static PyObject* mat4x4_str(mat<4, 4, T>* self);

template<typename T>
static PyObject* mat2x2_repr(mat<2, 2, T>* self);
template<typename T>
static PyObject* mat2x3_repr(mat<2, 3, T>* self);
template<typename T>
static PyObject* mat2x4_repr(mat<2, 4, T>* self);
template<typename T>
static PyObject* mat3x2_repr(mat<3, 2, T>* self);
template<typename T>
static PyObject* mat3x3_repr(mat<3, 3, T>* self);
template<typename T>
static PyObject* mat3x4_repr(mat<3, 4, T>* self);
template<typename T>
static PyObject* mat4x2_repr(mat<4, 2, T>* self);
template<typename T>
static PyObject* mat4x3_repr(mat<4, 3, T>* self);
template<typename T>
static PyObject* mat4x4_repr(mat<4, 4, T>* self);

template<int C, int R, typename T>
static PyObject* mat_richcompare(mat<C, R, T>* self, PyObject* other, int comp_type);

template<int C, int R, typename T>
static PyObject* mat_geniter(mat<C, R, T>* self);

template<typename T>
static int mat2x2_init(mat<2, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat2x3_init(mat<2, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat2x4_init(mat<2, 4, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x2_init(mat<3, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x3_init(mat<3, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x4_init(mat<3, 4, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x2_init(mat<4, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x3_init(mat<4, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x4_init(mat<4, 4, T> *self, PyObject *args, PyObject *kwds);

template<int C, int R, typename T>
static PyObject* mat_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<int C, int R, typename T>
static void matIter_dealloc(matIter<C, R, T> *rgstate);

template<int C, int R, typename T>
static PyObject* matIter_next(matIter<C, R, T> *rgstate);

template<int C, int R, typename T>
static PyObject* matIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMethodDef hfmat2x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x2"},
	{ NULL }
};
static PyBufferProcs hfmat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x2NumMethods = {
	(binaryfunc)matsq_add<2, 2, float>, //nb_add
	(binaryfunc)matsq_sub<2, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, float>, //nb_negative
	(unaryfunc)mat_pos<2, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<2, 2, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<2, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<2, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<2, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat2x2",             /* tp_name */
	sizeof(mat<2, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_repr<float>,                         /* tp_repr */
	&hfmat2x2NumMethods,             /* tp_as_number */
	&hfmat2x2SeqMethods,                         /* tp_as_sequence */
	&hfmat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x2( <mat2x2 compatible type(s)> )\n2 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat2x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x3"},
	{ NULL }
};
static PyBufferProcs hfmat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, float>, //nb_add
	(binaryfunc)mat_sub<2, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, float>, //nb_negative
	(unaryfunc)mat_pos<2, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<2, 3, float>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat2x3",             /* tp_name */
	sizeof(mat<2, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_repr<float>,                         /* tp_repr */
	&hfmat2x3NumMethods,             /* tp_as_number */
	&hfmat2x3SeqMethods,                         /* tp_as_sequence */
	&hfmat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x3( <mat2x3 compatible type(s)> )\n2 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat2x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x4"},
	{ NULL }
};
static PyBufferProcs hfmat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, float>, //nb_add
	(binaryfunc)mat_sub<2, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, float>, //nb_negative
	(unaryfunc)mat_pos<2, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<2, 4, float>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat2x4",             /* tp_name */
	sizeof(mat<2, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_repr<float>,                         /* tp_repr */
	&hfmat2x4NumMethods,             /* tp_as_number */
	&hfmat2x4SeqMethods,                         /* tp_as_sequence */
	&hfmat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x4( <mat2x4 compatible type(s)> )\n2 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x2"},
	{ NULL }
};
static PyBufferProcs hfmat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, float>, //nb_add
	(binaryfunc)mat_sub<3, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, float>, //nb_negative
	(unaryfunc)mat_pos<3, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<3, 2, float>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat3x2",             /* tp_name */
	sizeof(mat<3, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_repr<float>,                         /* tp_repr */
	&hfmat3x2NumMethods,             /* tp_as_number */
	&hfmat3x2SeqMethods,                         /* tp_as_sequence */
	&hfmat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x2( <mat3x2 compatible type(s)> )\n3 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x3"},
	{ NULL }
};
static PyBufferProcs hfmat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x3NumMethods = {
	(binaryfunc)matsq_add<3, 3, float>, //nb_add
	(binaryfunc)matsq_sub<3, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, float>, //nb_negative
	(unaryfunc)mat_pos<3, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<3, 3, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<3, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<3, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<3, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat3x3",             /* tp_name */
	sizeof(mat<3, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_repr<float>,                         /* tp_repr */
	&hfmat3x3NumMethods,             /* tp_as_number */
	&hfmat3x3SeqMethods,                         /* tp_as_sequence */
	&hfmat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x3( <mat3x3 compatible type(s)> )\n3 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x4"},
	{ NULL }
};
static PyBufferProcs hfmat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, float>, //nb_add
	(binaryfunc)mat_sub<3, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, float>, //nb_negative
	(unaryfunc)mat_pos<3, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<3, 4, float>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat3x4",             /* tp_name */
	sizeof(mat<3, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_repr<float>,                         /* tp_repr */
	&hfmat3x4NumMethods,             /* tp_as_number */
	&hfmat3x4SeqMethods,                         /* tp_as_sequence */
	&hfmat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x4( <mat3x4 compatible type(s)> )\n3 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x2"},
	{ NULL }
};
static PyBufferProcs hfmat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, float>, //nb_add
	(binaryfunc)mat_sub<4, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, float>, //nb_negative
	(unaryfunc)mat_pos<4, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<4, 2, float>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat4x2",             /* tp_name */
	sizeof(mat<4, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_repr<float>,                         /* tp_repr */
	&hfmat4x2NumMethods,             /* tp_as_number */
	&hfmat4x2SeqMethods,                         /* tp_as_sequence */
	&hfmat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x2( <mat4x2 compatible type(s)> )\n4 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x3"},
	{ NULL }
};
static PyBufferProcs hfmat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, float>, //nb_add
	(binaryfunc)mat_sub<4, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, float>, //nb_negative
	(unaryfunc)mat_pos<4, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<4, 3, float>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat4x3",             /* tp_name */
	sizeof(mat<4, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_repr<float>,                         /* tp_repr */
	&hfmat4x3NumMethods,             /* tp_as_number */
	&hfmat4x3SeqMethods,                         /* tp_as_sequence */
	&hfmat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x3( <mat4x3 compatible type(s)> )\n4 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x4"},
	{ NULL }
};
static PyBufferProcs hfmat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x4NumMethods = {
	(binaryfunc)matsq_add<4, 4, float>, //nb_add
	(binaryfunc)matsq_sub<4, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, float>, //nb_negative
	(unaryfunc)mat_pos<4, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<4, 4, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<4, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<4, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<4, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.mat4x4",             /* tp_name */
	sizeof(mat<4, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_repr<float>,                         /* tp_repr */
	&hfmat4x4NumMethods,             /* tp_as_number */
	&hfmat4x4SeqMethods,                         /* tp_as_sequence */
	&hfmat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x4( <mat4x4 compatible type(s)> )\n4 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMethodDef hdmat2x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x2"},
	{ NULL }
};
static PyBufferProcs hdmat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x2NumMethods = {
	(binaryfunc)matsq_add<2, 2, double>, //nb_add
	(binaryfunc)matsq_sub<2, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, double>, //nb_negative
	(unaryfunc)mat_pos<2, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<2, 2, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<2, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<2, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<2, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat2x2",             /* tp_name */
	sizeof(mat<2, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_repr<double>,                         /* tp_repr */
	&hdmat2x2NumMethods,             /* tp_as_number */
	&hdmat2x2SeqMethods,                         /* tp_as_sequence */
	&hdmat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x2( <dmat2x2 compatible type(s)> )\n2 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat2x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x3"},
	{ NULL }
};
static PyBufferProcs hdmat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, double>, //nb_add
	(binaryfunc)mat_sub<2, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, double>, //nb_negative
	(unaryfunc)mat_pos<2, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<2, 3, double>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat2x3",             /* tp_name */
	sizeof(mat<2, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_repr<double>,                         /* tp_repr */
	&hdmat2x3NumMethods,             /* tp_as_number */
	&hdmat2x3SeqMethods,                         /* tp_as_sequence */
	&hdmat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x3( <dmat2x3 compatible type(s)> )\n2 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat2x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x4"},
	{ NULL }
};
static PyBufferProcs hdmat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, double>, //nb_add
	(binaryfunc)mat_sub<2, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, double>, //nb_negative
	(unaryfunc)mat_pos<2, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<2, 4, double>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat2x4",             /* tp_name */
	sizeof(mat<2, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_repr<double>,                         /* tp_repr */
	&hdmat2x4NumMethods,             /* tp_as_number */
	&hdmat2x4SeqMethods,                         /* tp_as_sequence */
	&hdmat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x4( <dmat2x4 compatible type(s)> )\n2 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x2"},
	{ NULL }
};
static PyBufferProcs hdmat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, double>, //nb_add
	(binaryfunc)mat_sub<3, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, double>, //nb_negative
	(unaryfunc)mat_pos<3, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<3, 2, double>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat3x2",             /* tp_name */
	sizeof(mat<3, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_repr<double>,                         /* tp_repr */
	&hdmat3x2NumMethods,             /* tp_as_number */
	&hdmat3x2SeqMethods,                         /* tp_as_sequence */
	&hdmat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x2( <dmat3x2 compatible type(s)> )\n3 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x3"},
	{ NULL }
};
static PyBufferProcs hdmat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x3NumMethods = {
	(binaryfunc)matsq_add<3, 3, double>, //nb_add
	(binaryfunc)matsq_sub<3, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, double>, //nb_negative
	(unaryfunc)mat_pos<3, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<3, 3, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<3, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<3, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<3, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat3x3",             /* tp_name */
	sizeof(mat<3, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_repr<double>,                         /* tp_repr */
	&hdmat3x3NumMethods,             /* tp_as_number */
	&hdmat3x3SeqMethods,                         /* tp_as_sequence */
	&hdmat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x3( <dmat3x3 compatible type(s)> )\n3 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x4"},
	{ NULL }
};
static PyBufferProcs hdmat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, double>, //nb_add
	(binaryfunc)mat_sub<3, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, double>, //nb_negative
	(unaryfunc)mat_pos<3, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<3, 4, double>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat3x4",             /* tp_name */
	sizeof(mat<3, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_repr<double>,                         /* tp_repr */
	&hdmat3x4NumMethods,             /* tp_as_number */
	&hdmat3x4SeqMethods,                         /* tp_as_sequence */
	&hdmat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x4( <dmat3x4 compatible type(s)> )\n3 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x2"},
	{ NULL }
};
static PyBufferProcs hdmat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, double>, //nb_add
	(binaryfunc)mat_sub<4, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, double>, //nb_negative
	(unaryfunc)mat_pos<4, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<4, 2, double>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat4x2",             /* tp_name */
	sizeof(mat<4, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_repr<double>,                         /* tp_repr */
	&hdmat4x2NumMethods,             /* tp_as_number */
	&hdmat4x2SeqMethods,                         /* tp_as_sequence */
	&hdmat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x2( <dmat4x2 compatible type(s)> )\n4 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x3"},
	{ NULL }
};
static PyBufferProcs hdmat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, double>, //nb_add
	(binaryfunc)mat_sub<4, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, double>, //nb_negative
	(unaryfunc)mat_pos<4, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<4, 3, double>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat4x3",             /* tp_name */
	sizeof(mat<4, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_repr<double>,                         /* tp_repr */
	&hdmat4x3NumMethods,             /* tp_as_number */
	&hdmat4x3SeqMethods,                         /* tp_as_sequence */
	&hdmat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x3( <dmat4x3 compatible type(s)> )\n4 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x4"},
	{ NULL }
};
static PyBufferProcs hdmat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x4NumMethods = {
	(binaryfunc)matsq_add<4, 4, double>, //nb_add
	(binaryfunc)matsq_sub<4, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, double>, //nb_negative
	(unaryfunc)mat_pos<4, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<4, 4, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<4, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<4, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<4, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.dmat4x4",             /* tp_name */
	sizeof(mat<4, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_repr<double>,                         /* tp_repr */
	&hdmat4x4NumMethods,             /* tp_as_number */
	&hdmat4x4SeqMethods,                         /* tp_as_sequence */
	&hdmat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x4( <dmat4x4 compatible type(s)> )\n4 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region i32
static PyMethodDef himat2x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x2"},
	{ NULL }
};
static PyBufferProcs himat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x2NumMethods = {
	(binaryfunc)mat_add<2, 2, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<2, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat2x2",             /* tp_name */
	sizeof(mat<2, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_repr<glm::i32>,                         /* tp_repr */
	&himat2x2NumMethods,             /* tp_as_number */
	&himat2x2SeqMethods,                         /* tp_as_sequence */
	&himat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x2( <imat2x2 compatible type(s)> )\n2 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat2x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x3"},
	{ NULL }
};
static PyBufferProcs himat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, glm::i32>, //nb_add
	(binaryfunc)mat_sub<2, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat2x3",             /* tp_name */
	sizeof(mat<2, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_repr<glm::i32>,                         /* tp_repr */
	&himat2x3NumMethods,             /* tp_as_number */
	&himat2x3SeqMethods,                         /* tp_as_sequence */
	&himat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x3( <imat2x3 compatible type(s)> )\n2 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat2x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x4"},
	{ NULL }
};
static PyBufferProcs himat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, glm::i32>, //nb_add
	(binaryfunc)mat_sub<2, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat2x4",             /* tp_name */
	sizeof(mat<2, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_repr<glm::i32>,                         /* tp_repr */
	&himat2x4NumMethods,             /* tp_as_number */
	&himat2x4SeqMethods,                         /* tp_as_sequence */
	&himat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x4( <imat2x4 compatible type(s)> )\n2 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x2"},
	{ NULL }
};
static PyBufferProcs himat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, glm::i32>, //nb_add
	(binaryfunc)mat_sub<3, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat3x2",             /* tp_name */
	sizeof(mat<3, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_repr<glm::i32>,                         /* tp_repr */
	&himat3x2NumMethods,             /* tp_as_number */
	&himat3x2SeqMethods,                         /* tp_as_sequence */
	&himat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x2( <imat3x2 compatible type(s)> )\n3 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x3"},
	{ NULL }
};
static PyBufferProcs himat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x3NumMethods = {
	(binaryfunc)mat_add<3, 3, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<3, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat3x3",             /* tp_name */
	sizeof(mat<3, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_repr<glm::i32>,                         /* tp_repr */
	&himat3x3NumMethods,             /* tp_as_number */
	&himat3x3SeqMethods,                         /* tp_as_sequence */
	&himat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x3( <imat3x3 compatible type(s)> )\n3 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x4"},
	{ NULL }
};
static PyBufferProcs himat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, glm::i32>, //nb_add
	(binaryfunc)mat_sub<3, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat3x4",             /* tp_name */
	sizeof(mat<3, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_repr<glm::i32>,                         /* tp_repr */
	&himat3x4NumMethods,             /* tp_as_number */
	&himat3x4SeqMethods,                         /* tp_as_sequence */
	&himat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x4( <imat3x4 compatible type(s)> )\n3 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x2"},
	{ NULL }
};
static PyBufferProcs himat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, glm::i32>, //nb_add
	(binaryfunc)mat_sub<4, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat4x2",             /* tp_name */
	sizeof(mat<4, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_repr<glm::i32>,                         /* tp_repr */
	&himat4x2NumMethods,             /* tp_as_number */
	&himat4x2SeqMethods,                         /* tp_as_sequence */
	&himat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x2( <imat4x2 compatible type(s)> )\n4 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x3"},
	{ NULL }
};
static PyBufferProcs himat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, glm::i32>, //nb_add
	(binaryfunc)mat_sub<4, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat4x3",             /* tp_name */
	sizeof(mat<4, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_repr<glm::i32>,                         /* tp_repr */
	&himat4x3NumMethods,             /* tp_as_number */
	&himat4x3SeqMethods,                         /* tp_as_sequence */
	&himat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x3( <imat4x3 compatible type(s)> )\n4 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x4"},
	{ NULL }
};
static PyBufferProcs himat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x4NumMethods = {
	(binaryfunc)mat_add<4, 4, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<4, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.imat4x4",             /* tp_name */
	sizeof(mat<4, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_repr<glm::i32>,                         /* tp_repr */
	&himat4x4NumMethods,             /* tp_as_number */
	&himat4x4SeqMethods,                         /* tp_as_sequence */
	&himat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x4( <imat4x4 compatible type(s)> )\n4 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region u32
static PyMethodDef humat2x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x2"},
	{ NULL }
};
static PyBufferProcs humat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x2NumMethods = {
	(binaryfunc)mat_add<2, 2, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<2, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat2x2",             /* tp_name */
	sizeof(mat<2, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_repr<glm::u32>,                         /* tp_repr */
	&humat2x2NumMethods,             /* tp_as_number */
	&humat2x2SeqMethods,                         /* tp_as_sequence */
	&humat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x2( <umat2x2 compatible type(s)> )\n2 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat2x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x3"},
	{ NULL }
};
static PyBufferProcs humat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, glm::u32>, //nb_add
	(binaryfunc)mat_sub<2, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat2x3",             /* tp_name */
	sizeof(mat<2, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_repr<glm::u32>,                         /* tp_repr */
	&humat2x3NumMethods,             /* tp_as_number */
	&humat2x3SeqMethods,                         /* tp_as_sequence */
	&humat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x3( <umat2x3 compatible type(s)> )\n2 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat2x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x4"},
	{ NULL }
};
static PyBufferProcs humat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, glm::u32>, //nb_add
	(binaryfunc)mat_sub<2, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat2x4",             /* tp_name */
	sizeof(mat<2, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_repr<glm::u32>,                         /* tp_repr */
	&humat2x4NumMethods,             /* tp_as_number */
	&humat2x4SeqMethods,                         /* tp_as_sequence */
	&humat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x4( <umat2x4 compatible type(s)> )\n2 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x2"},
	{ NULL }
};
static PyBufferProcs humat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, glm::u32>, //nb_add
	(binaryfunc)mat_sub<3, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat3x2",             /* tp_name */
	sizeof(mat<3, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_repr<glm::u32>,                         /* tp_repr */
	&humat3x2NumMethods,             /* tp_as_number */
	&humat3x2SeqMethods,                         /* tp_as_sequence */
	&humat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x2( <umat3x2 compatible type(s)> )\n3 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x3"},
	{ NULL }
};
static PyBufferProcs humat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x3NumMethods = {
	(binaryfunc)mat_add<3, 3, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<3, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat3x3",             /* tp_name */
	sizeof(mat<3, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_repr<glm::u32>,                         /* tp_repr */
	&humat3x3NumMethods,             /* tp_as_number */
	&humat3x3SeqMethods,                         /* tp_as_sequence */
	&humat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x3( <umat3x3 compatible type(s)> )\n3 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x4"},
	{ NULL }
};
static PyBufferProcs humat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, glm::u32>, //nb_add
	(binaryfunc)mat_sub<3, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat3x4",             /* tp_name */
	sizeof(mat<3, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_repr<glm::u32>,                         /* tp_repr */
	&humat3x4NumMethods,             /* tp_as_number */
	&humat3x4SeqMethods,                         /* tp_as_sequence */
	&humat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x4( <umat3x4 compatible type(s)> )\n3 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x2_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x2"},
	{ NULL }
};
static PyBufferProcs humat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, glm::u32>, //nb_add
	(binaryfunc)mat_sub<4, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat4x2",             /* tp_name */
	sizeof(mat<4, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_repr<glm::u32>,                         /* tp_repr */
	&humat4x2NumMethods,             /* tp_as_number */
	&humat4x2SeqMethods,                         /* tp_as_sequence */
	&humat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x2( <umat4x2 compatible type(s)> )\n4 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x3_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x3"},
	{ NULL }
};
static PyBufferProcs humat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, glm::u32>, //nb_add
	(binaryfunc)mat_sub<4, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat4x3",             /* tp_name */
	sizeof(mat<4, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_repr<glm::u32>,                         /* tp_repr */
	&humat4x3NumMethods,             /* tp_as_number */
	&humat4x3SeqMethods,                         /* tp_as_sequence */
	&humat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x3( <umat4x3 compatible type(s)> )\n4 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x4_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x4"},
	{ NULL }
};
static PyBufferProcs humat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x4NumMethods = {
	(binaryfunc)mat_add<4, 4, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<4, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm.umat4x4",             /* tp_name */
	sizeof(mat<4, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_repr<glm::u32>,                         /* tp_repr */
	&humat4x4NumMethods,             /* tp_as_number */
	&humat4x4SeqMethods,                         /* tp_as_sequence */
	&humat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x4( <umat4x4 compatible type(s)> )\n4 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma region qua
static PyObject* qua_length(PyObject * self, PyObject* arg);

template<typename T>
static int qua_getbuffer(qua<T>* self, Py_buffer* view, int flags);

void qua_releasebuffer(PyObject* self, Py_buffer* view);

static Py_ssize_t qua_len(PyObject* self);

template<typename T>
static PyObject* qua_sq_item(qua<T> * self, Py_ssize_t index);

template<typename T>
static int qua_sq_ass_item(qua<T> * self, Py_ssize_t index, PyObject * value);

template<typename T>
static int qua_contains(qua<T> * self, PyObject * value);

template<typename T>
static PyObject * qua_add(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_sub(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_mul(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_neg(qua<T> *obj);

template<typename T>
static PyObject * qua_pos(qua<T> *obj);

template<typename T>
static PyObject * qua_iadd(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_isub(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_imul(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_div(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_idiv(qua<T>* self, PyObject *obj);

static void qua_dealloc(PyObject* self);

template<typename T>
static PyObject* qua_str(qua<T>* self);

template<typename T>
static PyObject* qua_repr(qua<T>* self);

template<typename T>
static PyObject* qua_richcompare(qua<T>* self, PyObject* other, int comp_type);

template<typename T>
static PyObject* qua_geniter(qua<T>* self);

template<typename T>
static int qua_init(qua<T> *self, PyObject *args, PyObject *kwds);

template<typename T>
static PyObject* qua_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<typename T>
static void quaIter_dealloc(quaIter<T> *rgstate);

template<typename T>
static PyObject* quaIter_next(quaIter<T> *rgstate);

template<typename T>
static PyObject* quaIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMethodDef hfqua_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)qua_length, METH_NOARGS, "returns the length of glm::quat"},
	{ NULL }
};

static PyMemberDef hfqua_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.x), 0, (char*)"quat.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.y), 0, (char*)"quat.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.z), 0, (char*)"quat.z" },
	{ (char*)"w", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.w), 0, (char*)"quat.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfquaBufferMethods = {
	(getbufferproc)qua_getbuffer<float>,
	(releasebufferproc)qua_releasebuffer,
};
static PySequenceMethods hfquaSeqMethods = {
	(lenfunc)qua_len, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)qua_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)qua_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)qua_contains<float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfquaNumMethods = {
	(binaryfunc)qua_add<float>, //nb_add
	(binaryfunc)qua_sub<float>, //nb_subtract
	(binaryfunc)qua_mul<float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)qua_neg<float>, //nb_negative
	(unaryfunc)qua_pos<float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)qua_iadd<float>, //nb_inplace_add
	(binaryfunc)qua_isub<float>, //nb_inplace_subtract
	(binaryfunc)qua_imul<float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)qua_div<float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)qua_idiv<float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfquaType = {
	PyObject_HEAD_INIT(NULL)
	"glm.quat",             /* tp_name */
	sizeof(qua<float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)qua_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)qua_repr<float>,                         /* tp_repr */
	&hfquaNumMethods,             /* tp_as_number */
	&hfquaSeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)qua_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfquaBufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"quat( <quat compatible type(s)> )\n4 components quaternion of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)qua_richcompare<float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)qua_geniter<float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfqua_methods,             /* tp_methods */
	hfqua_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)qua_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)qua_new<float>,                 /* tp_new */
};
static PyTypeObject hfquaIterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"quaIter",             /* tp_name */
	sizeof(quaIter<float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)quaIter_dealloc<float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"quat iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)quaIter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)quaIter_new<float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMethodDef hdqua_methods[] = {
	{ "__copy__", (PyCFunction)generic_copy, METH_NOARGS, "Create a copy of this instance"},
	{ "__deepcopy__", (PyCFunction)generic_deepcopy, METH_O, "Create a (deep)copy of this instance"},
	{"length", (PyCFunction)qua_length, METH_NOARGS, "returns the length of glm::dquat"},
	{ NULL }
};

static PyMemberDef hdqua_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.x), 0, (char*)"dquat.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.y), 0, (char*)"dquat.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.z), 0, (char*)"dquat.z" },
	{ (char*)"w", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.w), 0, (char*)"dquat.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdquaBufferMethods = {
	(getbufferproc)qua_getbuffer<double>,
	(releasebufferproc)qua_releasebuffer,
};
static PySequenceMethods hdquaSeqMethods = {
	(lenfunc)qua_len, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)qua_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)qua_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)qua_contains<double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdquaNumMethods = {
	(binaryfunc)qua_add<double>, //nb_add
	(binaryfunc)qua_sub<double>, //nb_subtract
	(binaryfunc)qua_mul<double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)qua_neg<double>, //nb_negative
	(unaryfunc)qua_pos<double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)qua_iadd<double>, //nb_inplace_add
	(binaryfunc)qua_isub<double>, //nb_inplace_subtract
	(binaryfunc)qua_imul<double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)qua_div<double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)qua_idiv<double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdquaType = {
	PyObject_HEAD_INIT(NULL)
	"glm.dquat",             /* tp_name */
	sizeof(qua<double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)qua_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)qua_repr<double>,                         /* tp_repr */
	&hdquaNumMethods,             /* tp_as_number */
	&hdquaSeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)qua_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdquaBufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dquat( <dquat compatible type(s)> )\n4 components quaternion of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)qua_richcompare<double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)qua_geniter<double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdqua_methods,             /* tp_methods */
	hdqua_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)qua_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)qua_new<double>,                 /* tp_new */
};
static PyTypeObject hdquaIterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dquatIter",             /* tp_name */
	sizeof(quaIter<double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)quaIter_dealloc<double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dquat iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)quaIter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)quaIter_new<double>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma endregion

// INTERNAL FUNCTIONS
#pragma region internal functions

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
PyObject* ctypes_void_p = NULL;
PyObject* ctypes_cast = NULL;
PyObject* ctypes_float_p = NULL;
PyObject* ctypes_double_p = NULL;
PyObject* ctypes_int64_p = NULL;
PyObject* ctypes_int32_p = NULL;
PyObject* ctypes_int16_p = NULL;
PyObject* ctypes_int8_p = NULL;
PyObject* ctypes_uint64_p = NULL;
PyObject* ctypes_uint32_p = NULL;
PyObject* ctypes_uint16_p = NULL;
PyObject* ctypes_uint8_p = NULL;
PyObject* ctypes_bool_p = NULL;

PyObject* PyGLM_VERSION_STRING = NULL;
PyObject* PyGLM_LICENSE_STRING = NULL;

#define PyGLM_FREXP_WARNING 1

int PyGLM_SHOW_WARNINGS = PyGLM_FREXP_WARNING;

#if defined(_M_IX86) || defined(__i386__)
PyObject* PyGLM_CtypesVoidP_FromVoidP(void* p) {
	PyObject* argList = Py_BuildValue("(K)", (unsigned long)p);
	PyObject* out = PyObject_CallObject(ctypes_void_p, argList);
	Py_DECREF(argList);
	return out;
}
unsigned long PyGLM_UnsignedLongLong_FromCtypesP(PyObject* ptr) {
	PyObject* ptr_as_c_void_p = PyObject_CallFunctionObjArgs(ctypes_cast, ptr, ctypes_void_p, NULL);
	PyObject* ptr_value = PyObject_GetAttrString(ptr_as_c_void_p, "value");
	unsigned long out = PyLong_AsUnsignedLong(ptr_value);
	Py_DECREF(ptr_value);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#else
PyObject* PyGLM_CtypesVoidP_FromVoidP(void* p) {
	PyObject* argList = Py_BuildValue("(K)", (unsigned long long)p);
	PyObject* out = PyObject_CallObject(ctypes_void_p, argList);
	Py_DECREF(argList);
	return out;
}
unsigned long long PyGLM_UnsignedLongLong_FromCtypesP(PyObject* ptr) {
	PyObject* ptr_as_c_void_p = PyObject_CallFunctionObjArgs(ctypes_cast, ptr, ctypes_void_p, NULL);
	PyObject* ptr_value = PyObject_GetAttrString(ptr_as_c_void_p, "value");
	unsigned long long out = PyLong_AsUnsignedLongLong(ptr_value);
	Py_DECREF(ptr_value);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#endif

PyObject* PyGLM_ToCtypesP(float* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_float_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(double* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_double_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int64* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int64_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int32* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int32_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int16* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int16_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int8* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int8_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint64* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint64_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint32* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint32_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint16* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint16_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint8* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint8_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(bool* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_bool_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#endif

template<int L, typename T>
static PyTypeObject* PyGLM_VEC_TYPE() {
	if (std::is_same<vec<L, T>, vec<1, float> >::value) {
		return (PyTypeObject*)&hfvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, float> >::value) {
		return (PyTypeObject*)&hfvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, float> >::value) {
		return (PyTypeObject*)&hfvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, float> >::value) {
		return (PyTypeObject*)&hfvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, double> >::value) {
		return (PyTypeObject*)&hdvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, double> >::value) {
		return (PyTypeObject*)&hdvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, double> >::value) {
		return (PyTypeObject*)&hdvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, double> >::value) {
		return (PyTypeObject*)&hdvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i32> >::value) {
		return (PyTypeObject*)&hivec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i32> >::value) {
		return (PyTypeObject*)&hivec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i32> >::value) {
		return (PyTypeObject*)&hivec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i32> >::value) {
		return (PyTypeObject*)&hivec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u32> >::value) {
		return (PyTypeObject*)&huvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u32> >::value) {
		return (PyTypeObject*)&huvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u32> >::value) {
		return (PyTypeObject*)&huvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u32> >::value) {
		return (PyTypeObject*)&huvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, bool> >::value) {
		return (PyTypeObject*)&hbvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, bool> >::value) {
		return (PyTypeObject*)&hbvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, bool> >::value) {
		return (PyTypeObject*)&hbvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, bool> >::value) {
		return (PyTypeObject*)&hbvec4Type;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_VECITER_TYPE() {
	if (std::is_same<vecIter<L, T>, vecIter<1, float> >::value) {
		return (PyTypeObject*)&hfvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, float> >::value) {
		return (PyTypeObject*)&hfvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, float> >::value) {
		return (PyTypeObject*)&hfvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, float> >::value) {
		return (PyTypeObject*)&hfvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, double> >::value) {
		return (PyTypeObject*)&hdvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, double> >::value) {
		return (PyTypeObject*)&hdvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, double> >::value) {
		return (PyTypeObject*)&hdvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, double> >::value) {
		return (PyTypeObject*)&hdvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i32> >::value) {
		return (PyTypeObject*)&hivec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i32> >::value) {
		return (PyTypeObject*)&hivec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i32> >::value) {
		return (PyTypeObject*)&hivec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i32> >::value) {
		return (PyTypeObject*)&hivec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u32> >::value) {
		return (PyTypeObject*)&huvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u32> >::value) {
		return (PyTypeObject*)&huvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u32> >::value) {
		return (PyTypeObject*)&huvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u32> >::value) {
		return (PyTypeObject*)&huvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, bool> >::value) {
		return (PyTypeObject*)&hbvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, bool> >::value) {
		return (PyTypeObject*)&hbvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, bool> >::value) {
		return (PyTypeObject*)&hbvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, bool> >::value) {
		return (PyTypeObject*)&hbvec4IterType;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_MVEC_TYPE() {
	if (std::is_same<mvec<L, T>, mvec<2, float> >::value) {
		return (PyTypeObject*)&hfmvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, float> >::value) {
		return (PyTypeObject*)&hfmvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, float> >::value) {
		return (PyTypeObject*)&hfmvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, double> >::value) {
		return (PyTypeObject*)&hdmvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, double> >::value) {
		return (PyTypeObject*)&hdmvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, double> >::value) {
		return (PyTypeObject*)&hdmvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, glm::i32> >::value) {
		return (PyTypeObject*)&himvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, glm::i32> >::value) {
		return (PyTypeObject*)&himvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, glm::i32> >::value) {
		return (PyTypeObject*)&himvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, glm::u32> >::value) {
		return (PyTypeObject*)&humvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, glm::u32> >::value) {
		return (PyTypeObject*)&humvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, glm::u32> >::value) {
		return (PyTypeObject*)&humvec4Type;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_MVECITER_TYPE() {
	if (std::is_same<mvecIter<L, T>, mvecIter<2, float> >::value) {
		return (PyTypeObject*)&hfmvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, float> >::value) {
		return (PyTypeObject*)&hfmvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, float> >::value) {
		return (PyTypeObject*)&hfmvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, double> >::value) {
		return (PyTypeObject*)&hdmvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, double> >::value) {
		return (PyTypeObject*)&hdmvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, double> >::value) {
		return (PyTypeObject*)&hdmvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, glm::i32> >::value) {
		return (PyTypeObject*)&himvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, glm::i32> >::value) {
		return (PyTypeObject*)&himvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, glm::i32> >::value) {
		return (PyTypeObject*)&himvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, glm::u32> >::value) {
		return (PyTypeObject*)&humvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, glm::u32> >::value) {
		return (PyTypeObject*)&humvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, glm::u32> >::value) {
		return (PyTypeObject*)&humvec4IterType;
	}
	return (PyTypeObject*)0;
}

template<int C, int R, typename T>
static PyTypeObject* PyGLM_MAT_TYPE() {
	if (std::is_same<mat<C, R, T>, mat<2, 2, float> >::value) {
		return (PyTypeObject*)&hfmat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, float> >::value) {
		return (PyTypeObject*)&hfmat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, float> >::value) {
		return (PyTypeObject*)&hfmat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, float> >::value) {
		return (PyTypeObject*)&hfmat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, float> >::value) {
		return (PyTypeObject*)&hfmat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, float> >::value) {
		return (PyTypeObject*)&hfmat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, float> >::value) {
		return (PyTypeObject*)&hfmat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, float> >::value) {
		return (PyTypeObject*)&hfmat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, float> >::value) {
		return (PyTypeObject*)&hfmat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, double> >::value) {
		return (PyTypeObject*)&hdmat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, double> >::value) {
		return (PyTypeObject*)&hdmat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, double> >::value) {
		return (PyTypeObject*)&hdmat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, double> >::value) {
		return (PyTypeObject*)&hdmat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, double> >::value) {
		return (PyTypeObject*)&hdmat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, double> >::value) {
		return (PyTypeObject*)&hdmat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, double> >::value) {
		return (PyTypeObject*)&hdmat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, double> >::value) {
		return (PyTypeObject*)&hdmat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, double> >::value) {
		return (PyTypeObject*)&hdmat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x4Type;
	}
	return (PyTypeObject*)0;
}

template<int C, int R, typename T>
static PyTypeObject* PyGLM_MATITER_TYPE() {
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, float> >::value) {
		return (PyTypeObject*)&hfmat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, float> >::value) {
		return (PyTypeObject*)&hfmat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, float> >::value) {
		return (PyTypeObject*)&hfmat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, float> >::value) {
		return (PyTypeObject*)&hfmat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, float> >::value) {
		return (PyTypeObject*)&hfmat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, float> >::value) {
		return (PyTypeObject*)&hfmat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, float> >::value) {
		return (PyTypeObject*)&hfmat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, float> >::value) {
		return (PyTypeObject*)&hfmat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, float> >::value) {
		return (PyTypeObject*)&hfmat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, double> >::value) {
		return (PyTypeObject*)&hdmat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, double> >::value) {
		return (PyTypeObject*)&hdmat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, double> >::value) {
		return (PyTypeObject*)&hdmat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, double> >::value) {
		return (PyTypeObject*)&hdmat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, double> >::value) {
		return (PyTypeObject*)&hdmat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, double> >::value) {
		return (PyTypeObject*)&hdmat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, double> >::value) {
		return (PyTypeObject*)&hdmat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, double> >::value) {
		return (PyTypeObject*)&hdmat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, double> >::value) {
		return (PyTypeObject*)&hdmat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x4IterType;
	}
	return (PyTypeObject*)0;
}

template<typename T>
static PyTypeObject* PyGLM_QUA_TYPE() {
	if (std::is_same<qua<T>, qua<float> >::value) {
		return (PyTypeObject*)&hfquaType;
	}
	if (std::is_same<qua<T>, qua<double> >::value) {
		return (PyTypeObject*)&hdquaType;
	}
	return (PyTypeObject*)0;
}

template<typename T>
static PyTypeObject* PyGLM_QUAITER_TYPE() {
	if (std::is_same<quaIter<T>, quaIter<float> >::value) {
		return (PyTypeObject*)&hfquaIterType;
	}
	if (std::is_same<quaIter<T>, quaIter<double> >::value) {
		return (PyTypeObject*)&hdquaIterType;
	}
	return (PyTypeObject*)0;
}


#define Py_IS_NOTIMPLEMENTED(op) (op == NULL || (PyObject*)op == Py_NotImplemented) // find out if op is NULL or NotImplemented

#define PyGLM_ASSERT(cond, msg) if (!cond) {PyErr_SetString(PyExc_AssertionError, msg); return NULL;}

#define PyObject_IterCheck(op) ((op)->ob_type->tp_iter != 0)

#define PyGLM_TYPE_AS_CSTRING(op) op->ob_type->tp_name

#define PyGLM_TypeCheck(op, tp) (Py_TYPE(op) == tp) 

#define PyGLM_String_AsString(name) PyBytes_AsString(PyUnicode_AsASCIIString(name));

// error functions
#define PyGLM_TYPEERROR_O(str, obj) PyErr_Format(PyExc_TypeError, "%s'%s'", str, PyGLM_TYPE_AS_CSTRING(obj));
#define PyGLM_TYPEERROR_2O(str, obj1, obj2) PyErr_Format(PyExc_TypeError, "%s'%s' and '%s'", str, PyGLM_TYPE_AS_CSTRING(obj1), PyGLM_TYPE_AS_CSTRING(obj2));

#define PyGLM_Arg_Unpack_1O(args, name, arg1) if(!PyArg_UnpackTuple(args, name, 1, 1, &arg1)) return NULL
#define PyGLM_Arg_Unpack_2O(args, name, arg1, arg2) if(!PyArg_UnpackTuple(args, name, 2, 2, &arg1, &arg2)) return NULL
#define PyGLM_Arg_Unpack_3O(args, name, arg1, arg2, arg3) if(!PyArg_UnpackTuple(args, name, 3, 3, &arg1, &arg2, &arg3)) return NULL
#define PyGLM_Arg_Unpack_4O(args, name, arg1, arg2, arg3, arg4) if(!PyArg_UnpackTuple(args, name, 4, 4, &arg1, &arg2, &arg3, &arg4)) return NULL
#define PyGLM_Arg_Unpack_5O(args, name, arg1, arg2, arg3, arg4, arg5) if(!PyArg_UnpackTuple(args, name, 5, 5, &arg1, &arg2, &arg3, &arg4, &arg5)) return NULL
#define PyGLM_Arg_Unpack_6O(args, name, arg1, arg2, arg3, arg4, arg5, arg6) if(!PyArg_UnpackTuple(args, name, 6, 6, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) return NULL


bool PyGLM_Number_Check(PyObject* arg) {
	if (PyFloat_Check(arg) || PyLong_Check(arg) || PyBool_Check(arg)) {
		return true;
	}
	if (arg->ob_type->tp_as_number != NULL && arg->ob_type->tp_as_number->nb_float != NULL) {
		PyObject* temp = PyNumber_Float(arg);
		if (temp != NULL) {
			Py_DECREF(temp);
			return true;
		}
		PyErr_Clear();
	}
	return false;
}

double PyGLM_Number_AsDouble(PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyFloat_AS_DOUBLE(arg);
	}
	if (PyLong_Check(arg)) {
		return PyLong_AsDouble(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1.0 : 0.0;
	}
	PyObject* arg_as_float = PyNumber_Float(arg);
	double out = PyFloat_AS_DOUBLE(arg_as_float);
	Py_DECREF(arg_as_float);
	return out;
}

long PyGLM_Number_AsLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AS_LONG(arg);
	}
	if (PyFloat_Check(arg)) {
		return (long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1 : 0;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	long out = PyLong_AS_LONG(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

unsigned long PyGLM_Number_AsUnsignedLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AsUnsignedLong(arg);
	}
	if (PyFloat_Check(arg)) {
		return (unsigned long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1UL : 0UL;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	unsigned long out = PyLong_AsUnsignedLong(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

long long PyGLM_Number_AsLongLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AsLongLong(arg);
	}
	if (PyFloat_Check(arg)) {
		return (long long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1LL : 0LL;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	long long out = PyLong_AsLongLong(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

unsigned long long PyGLM_Number_AsUnsignedLongLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AsUnsignedLongLong(arg);
	}
	if (PyFloat_Check(arg)) {
		return (unsigned long long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1ull : 0ull;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	unsigned long long out = PyLong_AsUnsignedLongLong(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

bool PyGLM_Number_AsBool(PyObject* arg) {
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? true : false;
	}
	if (PyLong_Check(arg)) {
		return (bool)PyLong_AS_LONG(arg);
	}
	if (PyFloat_Check(arg)) {
		return (bool)PyFloat_AS_DOUBLE(arg);
	}
	PyObject* arg_as_bool = PyNumber_Long(arg);
	bool out = (bool)PyLong_AS_LONG(arg_as_bool);
	Py_DECREF(arg_as_bool);
	return out;
}

float PyGLM_Number_AsFloat(PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return (float)PyFloat_AS_DOUBLE(arg);
	}
	if (PyLong_Check(arg)) {
		return (float)PyLong_AS_LONG(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1.f : 0.f;
	}
	PyObject* arg_as_float = PyNumber_Float(arg);
	float out = (float)PyFloat_AS_DOUBLE(arg_as_float);
	Py_DECREF(arg_as_float);
	return out;
}

template<typename T>
static T PyGLM_Number_FromPyObject(PyObject* value) {
	if (std::numeric_limits<T>::is_iec559) {
		if (std::is_same<T, double>::value) {
			return (T)PyGLM_Number_AsDouble(value);
		}
		return static_cast<T>(PyGLM_Number_AsFloat(value));
	}
	else if (std::numeric_limits<T>::is_integer) {
		if (std::is_same<T, long long>::value) {
			return (T)PyGLM_Number_AsLongLong(value);
		}
		if (std::is_same<T, unsigned long long>::value) {
			return (T)PyGLM_Number_AsUnsignedLongLong(value);
		}
		if (std::is_same<T, unsigned long>::value || !std::is_signed<T>::value) {
			return (T)PyGLM_Number_AsUnsignedLong(value);
		}
		return static_cast<T>(PyGLM_Number_AsLong(value));
	}
	else if (std::is_same<T, bool>::value) {
		return (T)PyGLM_Number_AsBool(value);
	}
	return (T)0;
}

template<typename T>
static PyObject* PyGLM_PyObject_FromNumber(T value) {
	if (std::numeric_limits<T>::is_iec559) {
		return PyFloat_FromDouble(static_cast<double>(value));
	}
	else if (std::numeric_limits<T>::is_integer) {
		if (std::is_same<T, long long>::value) {
			return PyLong_FromLongLong((long long)value);
		}
		if (std::is_same<T, unsigned long long>::value) {
			return PyLong_FromUnsignedLongLong((unsigned long long)value);
		}
		if (std::is_same<T, unsigned long>::value || !std::is_signed<T>::value) {
			return PyLong_FromUnsignedLong((unsigned long)value);
		}
		return PyLong_FromLong((long)value);
	}
	else if (std::is_same<T, bool>::value) {
		if (value) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	return NULL;
}

// type checkers
#pragma region type checkers
#define _SUB_PyGLM_GET_TYPE(o) ((o->ob_type->tp_dealloc == NULL) ? PyGLM_TYPE_UNKNOWN : (o->ob_type->tp_dealloc == (destructor)vec_dealloc) ? PyGLM_TYPE_VEC : (o->ob_type->tp_dealloc == (destructor)mat_dealloc) ? PyGLM_TYPE_MAT : (o->ob_type->tp_dealloc == (destructor)qua_dealloc) ? PyGLM_TYPE_QUA : (o->ob_type->tp_dealloc == (destructor)mvec_dealloc) ? PyGLM_TYPE_VEC : PyGLM_TYPE_UNKNOWN)
#define PyGLM_GET_TYPE(o) _SUB_PyGLM_GET_TYPE(((PyObject*)o))

#define PyGLM_VEC_SHAPE_CHECK(o, L) (((shape_helper*)o)->shape == L)
#define PyGLM_MAT_SHAPE_CHECK(o, C, R) (((shape_helper*)o)->shape == (C + (R << 3)))

#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
bool PyGLM_Vec1i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 1 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 1) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);

	Py_DECREF(iterator);

	if (value0 == NULL || !PyGLM_Number_Check(value0)) {
		Py_XDECREF(value0);

		return false;
	}
	Py_DECREF(value0);

	return true;
}

bool PyGLM_Vec2i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 2 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 2) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);

	Py_DECREF(iterator);

	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1)) {
		Py_XDECREF(value0);
		Py_XDECREF(value1);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);

	return true;
}

bool PyGLM_Vec3i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 3 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 2))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 3) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);
	PyObject* value2 = PyIter_Next(iterator);


	Py_DECREF(iterator);


	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2)) {

		Py_XDECREF(value0);
		Py_XDECREF(value1);
		Py_XDECREF(value2);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);
	Py_DECREF(value2);

	return true;
}

bool PyGLM_Vec4i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 4 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 2)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 3))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 4) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);
	PyObject* value2 = PyIter_Next(iterator);
	PyObject* value3 = PyIter_Next(iterator);


	Py_DECREF(iterator);


	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2) || value3 == NULL || !PyGLM_Number_Check(value3)) {

		Py_XDECREF(value0);
		Py_XDECREF(value1);
		Py_XDECREF(value2);
		Py_XDECREF(value3);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);
	Py_DECREF(value2);
	Py_DECREF(value3);

	return true;
}

#define PyGLM_Veci_Check(L, o) ((L == 1) ? PyGLM_Vec1i_Check(o) : (L == 2) ? PyGLM_Vec2i_Check(o) : (L == 3) ? PyGLM_Vec3i_Check(o) : PyGLM_Vec4i_Check(o))

template<typename T>
static bool get_view_format_equal(char* value) {
	char& v_char = value[0];
	if (v_char == 'f') {
		return std::is_same<T, float>::value;
	}
	if (v_char == 'd') {
		return std::is_same<T, double>::value;
	}
	if (v_char == 'c') {
		return std::is_same<T, std::int8_t>::value;
	}
	if (v_char == 'b') {
		return std::is_same<T, std::uint8_t>::value;
	}
	if (v_char == 'h') {
		return std::is_same<T, std::int16_t>::value;
	}
	if (v_char == 'H') {
		return std::is_same<T, std::uint16_t>::value;
	}
	if (v_char == 'i') {
		return std::is_same<T, std::int32_t>::value;
	}
	if (v_char == 'I') {
		return std::is_same<T, std::uint32_t>::value;
	}
	if (v_char == 'L') {
		return std::is_same<T, std::int64_t>::value;
	}
	if (v_char == 'K') {
		return std::is_same<T, std::uint64_t>::value;
	}
	if (v_char == 'p') {
		return std::is_same<T, bool>::value;
	}
	return false;
}

template<typename T>
static bool PyGLM_Matb_Check(int C, int R, PyObject* o) {
	if (!PyObject_CheckBuffer(o)) {
		return false;
	}
	Py_buffer view;
	if (PyObject_GetBuffer(o, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (((view.ndim != 2 || view.shape[0] != static_cast<Py_ssize_t>(C) || view.shape[1] != static_cast<Py_ssize_t>(R) || !get_view_format_equal<T>(view.format)) && (view.ndim != 1 || view.shape[0] != static_cast<Py_ssize_t>(C * R * sizeof(T)) || view.format[0] != 'B')))) {
		PyBuffer_Release(&view);
		return false;
	}
	PyBuffer_Release(&view);
	return true;
}

template<typename T>
static bool PyGLM_Vecb_Check(int L, PyObject* o) {
	if (!PyObject_CheckBuffer(o)) {
		return false;
	}
	Py_buffer view;
	if (PyObject_GetBuffer(o, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != static_cast<Py_ssize_t>(L) || !get_view_format_equal<T>(view.format)) && (view.shape[0] != static_cast<Py_ssize_t>(L * sizeof(T)) || view.format[0] != 'B')))) {
		PyBuffer_Release(&view);
		return false;
	}
	PyBuffer_Release(&view);
	return true;
}

#define PyGLM_Vec_Check(L, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_VEC_TYPE<L, T>())) || Py_TYPE(o) == PyGLM_MVEC_TYPE<L, T>() || ((PyGLM_GET_TYPE(o) == PyGLM_TYPE_UNKNOWN) && (PyGLM_Vecb_Check<T>(L, (PyObject*)o))))

#define PyGLM_Vec_Check_IgnoreType(L, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_VEC_TYPE<L, T>())) || Py_TYPE(o) == PyGLM_MVEC_TYPE<L, T>() || ((PyGLM_GET_TYPE(o) == PyGLM_TYPE_UNKNOWN || (PyGLM_GET_TYPE(o) == PyGLM_TYPE_VEC && PyGLM_VEC_SHAPE_CHECK(o, L))) && ((PyGLM_Vecb_Check<T>(L, (PyObject*)o)) || (PyGLM_Veci_Check(L, o)))))

#define PyGLM_Qua_Check(T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_QUA_TYPE<T>())) || ((PyGLM_GET_TYPE(o) == PyGLM_TYPE_UNKNOWN || (PyGLM_GET_TYPE(o) == PyGLM_TYPE_QUA)) && PyGLM_Vecb_Check<T>(4, (PyObject*)o)))

#define PyGLM_Mat_Check(C, R, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<C, R, T>())) || ((PyGLM_GET_TYPE(o) == PyGLM_TYPE_UNKNOWN || (PyGLM_GET_TYPE(o) == PyGLM_TYPE_MAT && PyGLM_MAT_SHAPE_CHECK(o, C, R))) && PyGLM_Matb_Check<T>(C, R, (PyObject*)o)))

#else
#define PyGLM_Vec_Check(L, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_VEC_TYPE<L, T>())) || Py_TYPE(o) == PyGLM_MVEC_TYPE<L, T>())

#define PyGLM_Vec_Check_IgnoreType PyGLM_Vec_Check

#define PyGLM_Qua_Check(T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_QUA_TYPE<T>())))

#define PyGLM_Mat_Check(C, R, T, o) PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<C, R, T>()))
#endif



#pragma endregion

// unpackers
#pragma region unpackers
template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<1, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<1, T>()))) {
		out = ((vec<1, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != 1 || !get_view_format_equal<T>(view.format)) && (view.shape[0] != 1 * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
		}
		else {
			memcpy(&out.x, view.buf, sizeof(out));
			return true;
		}
	}
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 1) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0)) {

				Py_XDECREF(value0);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);

			out = glm::vec<1, T>(value0_as_T);


			Py_DECREF(value0);

			return true;
		}
	}
#endif
	return false;
}

template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<2, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET (PyGLM_VEC_TYPE<2, T>()))) {
		out = ((vec<2, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<2, T>()) {
		out = *((mvec<2, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != 2 || !get_view_format_equal<T>(view.format)) && (view.shape[0] != 2 * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
		}
		else {
			memcpy(glm::value_ptr(out), view.buf, sizeof(out));
			return true;
		}
	}
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 2) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);

			out = glm::vec<2, T>(value0_as_T, value1_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);

			return true;
		}
	}
#endif
	return false;
}
template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<3, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<3, T>()))) {
		out = ((vec<3, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<3, T>()) {
		out = *((mvec<3, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != 3 || !get_view_format_equal<T>(view.format)) && (view.shape[0] != 3 * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
		}
		else {
			memcpy(glm::value_ptr(out), view.buf, sizeof(out));
			return true;
		}
	}
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 3) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);
			PyObject* value2 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);
				Py_XDECREF(value2);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);
			T value2_as_T = PyGLM_Number_FromPyObject<T>(value2);

			out = glm::vec<3, T>(value0_as_T, value1_as_T, value2_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);
			Py_DECREF(value2);

			return true;
		}
	}
#endif
	return false;
}

template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<4, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<4, T>()))) {
		out = ((vec<4, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<4, T>()) {
		out = *((mvec<4, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != 4 || !get_view_format_equal<T>(view.format)) && (view.shape[0] != 4 * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
		}
		else {
			memcpy(glm::value_ptr(out), view.buf, sizeof(out));
			return true;
		}
	}
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 4) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);
			PyObject* value2 = PyIter_Next(value_iter);
			PyObject* value3 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2) || value3 == NULL || !PyGLM_Number_Check(value3)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);
				Py_XDECREF(value2);
				Py_XDECREF(value3);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);
			T value2_as_T = PyGLM_Number_FromPyObject<T>(value2);
			T value3_as_T = PyGLM_Number_FromPyObject<T>(value3);

			out = glm::vec<4, T>(value0_as_T, value1_as_T, value2_as_T, value3_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);
			Py_DECREF(value2);
			Py_DECREF(value3);

			return true;
		}
	}
#endif
	return false;
}

template<int L, typename T>
static glm::vec<L, T> unpack_vec(PyObject* value) {
	glm::vec<L, T> out;
	unpack_vec(value, out);
	return out;
}

template<int C, int R, typename T>
static bool unpack_mat(PyObject* value, glm::mat<C, R, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET (PyGLM_MAT_TYPE<C, R, T>()))) {
		out = ((mat<C, R, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (((view.ndim != 2 || view.shape[0] != C || view.shape[1] != R || !get_view_format_equal<T>(view.format)) && (view.ndim != 1 || view.shape[0] != C * R * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
			return false;
		}
		memcpy(glm::value_ptr(out), view.buf, sizeof(out));
		return true;
	}
#endif
	return false;
}

template<int C, int R, typename T>
static glm::mat<C, R, T> unpack_mat(PyObject* value) {
	glm::mat<C, R, T> out;
	unpack_mat(value, out);
	return out;
}

template<typename T>
static bool unpack_qua(PyObject* value, glm::qua<T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_QUA_TYPE<T>()))) {
		out = ((qua<T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_CheckBuffer(value)) {
		Py_buffer view;
		if (PyObject_GetBuffer(value, &view, PyBUF_RECORDS_RO | PyBUF_C_CONTIGUOUS) == -1 || (view.ndim != 1 || ((view.shape[0] != 4 || !get_view_format_equal<T>(view.format)) && (view.shape[0] != 4 * sizeof(T) || view.format[0] != 'B')))) {
			PyBuffer_Release(&view);
			return false;
		}
		memcpy(glm::value_ptr(out), view.buf, sizeof(out));
		return true;
	}
#endif
	return false;
}

template<typename T>
static glm::qua<T> unpack_qua(PyObject* value) {
	glm::qua<T> out;
	unpack_qua(value, out);
	return out;
}
#pragma endregion

// packers
#pragma region packers

template<int L, typename T>
static PyObject*
pack_vec(glm::vec<L, T> value) {
	PyTypeObject* vecType = PyGLM_VEC_TYPE<L, T>();
	vec<L, T>* out = (vec<L, T>*)vecType->tp_alloc(vecType, 0);

	if (out != NULL) {
		out->shape = L;
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<int L, typename T>
static PyObject*
pack_mvec(glm::vec<L, T>* value, PyObject* master) {
	PyTypeObject* mvecType = PyGLM_MVEC_TYPE<L, T>();
	mvec<L, T>* out = (mvec<L, T>*)mvecType->tp_alloc(mvecType, 0);

	if (out != NULL) {
		out->shape = L;
		out->super_type = value;
		out->master = master;
		Py_INCREF(master);
	}

	return (PyObject*)out;
}

template<int C, int R, typename T>
static PyObject*
pack_mat(glm::mat<C, R, T> value) {
	PyTypeObject* matType = PyGLM_MAT_TYPE<C, R, T>();
	mat<C, R, T>* out = (mat<C, R, T>*)matType->tp_alloc(matType, 0);

	if (out != NULL) {
		out->shape = C + (R << 3);
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<typename T>
static PyObject*
pack_qua(glm::qua<T> value) {
	PyTypeObject* quaType = PyGLM_QUA_TYPE<T>();
	qua<T>* out = (qua<T>*)quaType->tp_alloc(quaType, 0);

	if (out != NULL) {
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<typename T>
static PyObject*
pack(T value) {
	return PyGLM_PyObject_FromNumber(value);
}

template<int L, typename T>
static PyObject*
pack(glm::vec<L, T> value) {
	return pack_vec(value);
}

template<int C, int R, typename T>
static PyObject*
pack(glm::mat<C, R, T> value) {
	return pack_mat(value);
}

template<typename T>
static PyObject*
pack(glm::qua<T> value) {
	return pack_qua(value);
}
#pragma endregion

#pragma endregion

// TYPE DEFINITIONS

// type vec
#pragma region type vec
static void
vec_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<int L, typename T>
static PyObject *
vec_new(PyTypeObject *type, PyObject *, PyObject *)
{
	vec<L, T> *self = (vec<L, T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->shape = L;
		self->super_type = glm::vec<L, T>();
	}

	return (PyObject *)self;
}


template<typename T>
static int
vec1_init(vec<1, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", NULL };

	PyObject * arg = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|O", const_cast<char**>(kwlist),
		&arg)) {
		if (arg == NULL) {
			return 0;
		}
		if (PyGLM_Number_Check(arg)) {
			self->super_type = glm::vec<1, T>(PyGLM_Number_FromPyObject<T>(arg));
			return 0;
		}
		if (PyGLM_Vec_Check_IgnoreType(1, T, arg)) {
			self->super_type = unpack_vec<1, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check_IgnoreType(2, T, arg)) {
			self->super_type = unpack_vec<2, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check_IgnoreType(3, T, arg)) {
			self->super_type = unpack_vec<3, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check_IgnoreType(4, T, arg)) {
			self->super_type = unpack_vec<4, T>(arg);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
		return -1;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
	return -1;
}

template<typename T>
static int
vec2_init(vec<2, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO", const_cast<char**>(kwlist),
		&arg1, &arg2)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<2, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			if (PyGLM_Vec_Check_IgnoreType(2, T, arg1)) {
				self->super_type = unpack_vec<2, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check_IgnoreType(3, T, arg1)) {
				self->super_type = unpack_vec<3, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check_IgnoreType(4, T, arg1)) {
				self->super_type = unpack_vec<4, T>(arg1);
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			self->super_type = glm::vec<2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
	return -1;
}

template<typename T>
static int
vec3_init(vec<3, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<3, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			if (PyGLM_Vec_Check_IgnoreType(3, T, arg1)) {
				self->super_type = unpack_vec<3, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check_IgnoreType(4, T, arg1)) {
				self->super_type = unpack_vec<4, T>(arg1);
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
					return -1;
				}
				self->super_type = glm::vec<3, T>(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			if (PyGLM_Number_Check(arg2)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
					return -1;
				}
				self->super_type = glm::vec<3, T>(o, PyGLM_Number_FromPyObject<T>(arg2));
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
			self->super_type = glm::vec<3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
	return -1;
}

template<typename T>
static int
vec4_init(vec<4, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", "w", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;
	PyObject * arg4 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3, &arg4)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			glm::vec<4, T> o;

			if (unpack_vec(arg1, o)) {
				self->super_type = o;
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			if (PyGLM_Number_Check(arg2)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(o, PyGLM_Number_FromPyObject<T>(arg2));
				return 0;
			}
			glm::vec<2, T> o;
			if (!unpack_vec(arg1, o)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			glm::vec<2, T> o2;
			if (!unpack_vec(arg2, o2)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			self->super_type = glm::vec<4, T>(o, o2);
			return 0;
		}
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				if (PyGLM_Number_Check(arg2)) {
					glm::vec<2, T> o;
					if (!unpack_vec(arg3, o)) {
						PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
						return -1;
					}
					self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), o);
					return 0;
				}
				if (PyGLM_Number_Check(arg3)) {
					glm::vec<2, T> o;
					if (!unpack_vec(arg2, o)) {
						PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
						return -1;
					}
					self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), o, PyGLM_Number_FromPyObject<T>(arg3));
					return 0;
				}
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			if (PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(o, PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3));
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
			self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
	return -1;
}

// unaryfunc
template<int L, typename T>
static PyObject *
vec_neg(vec<L, T> *obj)
{
	return pack_vec<L, T>(-obj->super_type);
}

template<int L, typename T>
static PyObject *
vec_pos(vec<L, T> *obj)
{
	return pack_vec<L, T>(obj->super_type);
}

template<int L, typename T>
static PyObject *
vec_abs(vec<L, T> *obj)
{
	return pack_vec<L, T>(glm::abs(obj->super_type));
}

// binaryfunc
template<int L, typename T>
static PyObject *
vec_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) + (((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o + o2);
}

template<int L, typename T>
static PyObject *
vec_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) - ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o - o2);
}

template<int L, typename T>
static PyObject *
vec_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) * ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o * o2);
}

template<int L, typename T>
static PyObject *
vec_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) / ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return  pack_vec<L, T>(o / o2);
}

template<int L, typename T>
static PyObject *
vec_mod(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(glm::mod(glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1)), ((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for %: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(glm::mod(o, glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj2))));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(glm::mod(o, o2));
}

template<int L, typename T>
static PyObject *
vec_floordiv(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(floor(PyGLM_Number_FromPyObject<T>(obj1) / ((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for //: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(floor(o / PyGLM_Number_FromPyObject<T>(obj2)));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(floor(o / o2));
}

template<int L, typename T>
static PyObject *
vec_divmod(PyObject * obj1, PyObject * obj2) {
	PyObject *arg1, *arg2;
	arg1 = vec_floordiv<L, T>(obj1, obj2);
	arg2 = vec_mod<L, T>(obj1, obj2);
	if (arg1 == NULL || arg2 == NULL) {
		return NULL;
	}
	PyObject* out = PyTuple_Pack(2, arg1, arg2);
	Py_DECREF(arg1);
	Py_DECREF(arg2);
	return out;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
vec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3) {
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		T f = PyGLM_Number_FromPyObject<T>(obj1);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type), o3));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		T f = PyGLM_Number_FromPyObject<T>(obj2);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(o, glm::vec<L, T>(f)));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), o3));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}



	// obj1 and obj2 can be interpreted as a vec
	if (obj3 == Py_None) {
		return pack_vec<L, T>(glm::pow(o, o2));
	}

	if (PyGLM_Number_Check(obj3)) {
		T f2 = PyGLM_Number_FromPyObject<T>(obj3);
		return pack_vec<L, T>(glm::mod(glm::pow(o, o2), glm::vec<L, T>(f2)));
	}

	glm::vec<L, T> o3;

	if (!unpack_vec(obj3, o3)) {
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
		return NULL;
	}

	return pack_vec<L, T>(glm::mod(glm::pow(o, o2), o3));
}

// inplace
// binaryfunc
template<int L, typename T>
static PyObject *
vec_iadd(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_add<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_isub(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_sub<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_imul(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_mul<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_idiv(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_div<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_imod(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_mod<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_ifloordiv(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_floordiv<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
vec_ipow(vec<L, T> *self, PyObject *obj1, PyObject *) // obj2 is unused. It points to an invalid address!
{
	vec<L, T> * temp = (vec<L, T>*)vec_pow<L, T>((PyObject*)self, obj1, Py_None);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
vec1_str(vec<1, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 17 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g )", &name[4], (double)self->super_type.x);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec2_str(vec<2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 31 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec3_str(vec<3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 45 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g, %12.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec4_str(vec<4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 59 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g, %12.6g, %12.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec1_repr(vec<1, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 17 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g )", &name[4], (double)self->super_type.x);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec2_repr(vec<2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 31 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec3_repr(vec<3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 45 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec4_repr(vec<4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 59 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g, %.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int L>
static Py_ssize_t vec_len(PyObject *) {
	return (Py_ssize_t)L;
}

template<typename T>
static PyObject* vec1_sq_item(vec<1, T> * self, Py_ssize_t index) {
	if (index == 0) {
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	}
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return NULL;
}

template<typename T>
static PyObject* vec2_sq_item(vec<2, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* vec3_sq_item(vec<3, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.z);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* vec4_sq_item(vec<4, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.z);
	case 3:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.w);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static int vec1_sq_ass_item(vec<1, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	if (index == 0) {
		self->super_type.x = f;
		return 0;
	}
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return -1;
}

template<typename T>
static int vec2_sq_ass_item(vec<2, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int vec3_sq_ass_item(vec<3, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	case 2:
		self->super_type.z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int vec4_sq_ass_item(vec<4, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	case 2:
		self->super_type.z = f;
		return 0;
	case 3:
		self->super_type.w = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<int L, typename T>
static int vec_contains(vec<L, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < L; i++) {
			if (f == self->super_type[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<int L, typename T>
static PyObject * vec_richcompare(vec<L, T> * self, PyObject * other, int comp_type) {
	glm::vec<L, T> o2;

	if (!unpack_vec(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_LT:
		return pack_vec<L, T>(glm::lessThan(self->super_type, o2));
		break;
	case Py_LE:
		return pack_vec<L, T>(glm::lessThanEqual(self->super_type, o2));
		break;
	case Py_GT:
		return pack_vec<L, T>(glm::greaterThan(self->super_type, o2));
		break;
	case Py_GE:
		return pack_vec<L, T>(glm::greaterThanEqual(self->super_type, o2));
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

template<typename T>
static bool unswizzle_vec(vec<1, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<2, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<3, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type.z;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<4, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type.z;
		return true;
	}
	if (c == 'w' || c == 'a' || c == 'p') {
		out = self->super_type.w;
		return true;
	}
	return false;
}

//template<int L, typename T>
//static bool unswizzle_vec(vec<L, T>* self, char c, T& out) {
//	if (L == 2) {
//		return unswizzle_vec2<T>(self, c, out);
//	}
//	if (L == 3) {
//		return unswizzle_vec3<T>(self, c, out);
//	}
//	return unswizzle_vec4<T>(self, c, out);
//}

template<int L, typename T>
static PyObject * vec_getattr(PyObject * obj, PyObject * name) {
	char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);

	if (len >= 4 && name_as_ccp[0] == '_' && name_as_ccp[1] == '_' && name_as_ccp[len - 1] == '_' && name_as_ccp[len - 2] == '_') {
		return PyObject_GenericGetAttr(obj, name);
	}
	if (len == 1) {
		T x;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x)) {
			return PyGLM_PyObject_FromNumber<T>((T)x);
		}
	}
	else if (len == 2) {
		T x;
		T y;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y)) {
			return pack_vec<2, T>(glm::vec<2, T>(x, y));
		}
	}
	else if (len == 3) {
		T x;
		T y;
		T z;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[2], z)) {
			return pack_vec<3, T>(glm::vec<3, T>(x, y, z));
		}
	}
	else if (len == 4) {
		T x;
		T y;
		T z;
		T w;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[2], z) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[3], w)) {
			return pack_vec<4, T>(glm::vec<4, T>(x, y, z, w));
		}
	}
	return PyObject_GenericGetAttr(obj, name);
}

// iterator

template<int L, typename T>
static PyObject *
vecIter_new(PyTypeObject *type, PyObject *args, PyObject *)
{
	vec<L, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	vecIter<L, T> *rgstate = (vecIter<L, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static void
vecIter_dealloc(vecIter<L, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
vec1Iter_next(vecIter<1, T> *rgstate)
{
	if (rgstate->seq_index++ == 0) {
		return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
	}
	rgstate->seq_index = 1;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec2Iter_next(vecIter<2, T> *rgstate)
{
	if (rgstate->seq_index < 2) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		}
	}
	rgstate->seq_index = 2;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec3Iter_next(vecIter<3, T> *rgstate)
{
	if (rgstate->seq_index < 3) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.z);
		}
	}
	rgstate->seq_index = 3;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec4Iter_next(vecIter<4, T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.z);
		case 3:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.w);
		}
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int L, typename T>
static PyObject * vec_geniter(vec<L, T>* self) {
	vecIter<L, T> *rgstate = (vecIter<L, T> *)(PyGLM_VECITER_TYPE<L, T>()->tp_alloc(PyGLM_VECITER_TYPE<L, T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static int
vec_getbuffer(vec<L, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	if ((flags & PyBUF_RECORDS_RO) != PyBUF_RECORDS_RO || (flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS || (flags & PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS) {
		PyErr_SetString(PyExc_BufferError, "This type of buffer is not supported.");
		view->obj = NULL;
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0];
	view->len = sizeof(glm::vec<L, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ?	const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ?				const_cast<char*>("d") : \
		(std::is_same <T, std::int8_t>::value) ?		const_cast<char*>("b") : \
		(std::is_same <T, std::uint8_t>::value) ?		const_cast<char*>("B") : \
		(std::is_same <T, std::int16_t>::value) ?		const_cast<char*>("h") : \
		(std::is_same <T, std::uint16_t>::value) ?		const_cast<char*>("H") : \
		(std::is_same <T, std::int32_t>::value) ?		const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ?		const_cast<char*>("I") : \
		(std::is_same <T, std::int64_t>::value) ?		const_cast<char*>("q") : \
		(std::is_same <T, std::uint64_t>::value) ?		const_cast<char*>("Q") : \
		(std::is_same <T, bool>::value) ?				const_cast<char*>("?") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = L;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
vec_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}

static PyObject*
generic_copy(PyObject* self, PyObject*) {
	return PyObject_Call((PyObject*)(self->ob_type), PyTuple_Pack(1, self), NULL);
}

static PyObject*
generic_deepcopy(PyObject* self, PyObject* memo) {
	PyObject* copy = generic_copy(self, NULL);
	PyDict_SetItem(memo, PyLong_FromVoidPtr((void*)self), copy);
	return copy;
}

template<int L, typename T>
static PyObject*
mvec_copy(PyObject* self, PyObject*) {
	return pack_vec(*((mvec<L, T>*)self)->super_type);
}

template<int L, typename T>
static PyObject*
mvec_deepcopy(PyObject* self, PyObject* memo) {
	PyObject* copy = mvec_copy<L, T>(self, NULL);
	PyDict_SetItem(memo, PyLong_FromVoidPtr((void*)self), copy);
	return copy;
}

#pragma endregion 

// type mvec
#pragma region type mvec
static void
mvec_dealloc(PyObject* self)
{
	Py_XDECREF(((mvec_helper*)self)->master);
	self->ob_type->tp_free(self);
}

// unaryfunc
template<int L, typename T>
static PyObject *
mvec_neg(mvec<L, T> *obj)
{
	return pack_vec<L, T>(-*obj->super_type);
}

template<int L, typename T>
static PyObject *
mvec_pos(mvec<L, T> *obj)
{
	return pack_vec<L, T>(*obj->super_type);
}

template<int L, typename T>
static PyObject *
mvec_abs(mvec<L, T> *obj)
{
	return pack_vec<L, T>(glm::abs(*obj->super_type));
}

// binaryfunc
template<int L, typename T>
static PyObject *
mvec_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) + *(((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o + o2);
}

template<int L, typename T>
static PyObject *
mvec_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) - *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o - o2);
}

template<int L, typename T>
static PyObject *
mvec_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) * *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o * o2);
}

template<int L, typename T>
static PyObject *
mvec_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) / *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return  pack_vec<L, T>(o / o2);
}

template<int L, typename T>
static PyObject *
mvec_mod(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(glm::mod(glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1)), *((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for %: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(glm::mod(o, glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj2))));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(glm::mod(o, o2));
}

template<int L, typename T>
static PyObject *
mvec_floordiv(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(floor(PyGLM_Number_FromPyObject<T>(obj1) / *((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for //: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(floor(o / PyGLM_Number_FromPyObject<T>(obj2)));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(floor(o / o2));
}

template<int L, typename T>
static PyObject *
mvec_divmod(PyObject * obj1, PyObject * obj2) {
	PyObject *arg1, *arg2;
	arg1 = mvec_floordiv<L, T>(obj1, obj2);
	arg2 = mvec_mod<L, T>(obj1, obj2);
	if (arg1 == NULL || arg2 == NULL) {
		return NULL;
	}
	PyObject* out = PyTuple_Pack(2, arg1, arg2);
	Py_DECREF(arg1);
	Py_DECREF(arg2);
	return out;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
mvec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3) {
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		T f = PyGLM_Number_FromPyObject<T>(obj1);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type), o3));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: 'glm.vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		T f = PyGLM_Number_FromPyObject<T>(obj2);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(o, glm::vec<L, T>(f)));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), o3));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}



	// obj1 and obj2 can be interpreted as a mvec
	if (obj3 == Py_None) {
		return pack_vec<L, T>(glm::pow(o, o2));
	}

	if (PyGLM_Number_Check(obj3)) {
		T f2 = PyGLM_Number_FromPyObject<T>(obj3);
		return pack_vec<L, T>(glm::mod(glm::pow(o, o2), glm::vec<L, T>(f2)));
	}

	glm::vec<L, T> o3;

	if (!unpack_vec(obj3, o3)) {
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
		return NULL;
	}

	return pack_vec<L, T>(glm::mod(glm::pow(o, o2), o3));
}

// inplace
// binaryfunc
template<int L, typename T>
static PyObject *
mvec_iadd(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_add<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_isub(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_sub<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_imul(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_mul<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_idiv(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_div<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_imod(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_mod<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_ifloordiv(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_floordiv<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
mvec_ipow(mvec<L, T> *self, PyObject *obj1, PyObject *) // obj2 is unused. It points to an invalid address!
{
	vec<L, T> * temp = (vec<L, T>*)mvec_pow<L, T>((PyObject*)self, obj1, Py_None);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
mvec2_str(mvec<2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 32 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g )", &name[4], (double)self->super_type->x, (double)self->super_type->y);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mvec3_str(mvec<3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 46 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g, %12.6g )", &name[4], (double)self->super_type->x, (double)self->super_type->y, (double)self->super_type->z);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mvec4_str(mvec<4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 60 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g, %12.6g, %12.6g )", &name[4], (double)self->super_type->x, (double)self->super_type->y, (double)self->super_type->z, (double)self->super_type->w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int L>
static Py_ssize_t mvec_len(PyObject *) {
	return (Py_ssize_t)L;
}

template<typename T>
static PyObject* mvec2_sq_item(mvec<2, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* mvec3_sq_item(mvec<3, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->z);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* mvec4_sq_item(mvec<4, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->z);
	case 3:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->w);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static int mvec2_sq_ass_item(mvec<2, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int mvec3_sq_ass_item(mvec<3, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	case 2:
		self->super_type->z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int mvec4_sq_ass_item(mvec<4, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	case 2:
		self->super_type->z = f;
		return 0;
	case 3:
		self->super_type->w = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<int L, typename T>
static int mvec_contains(mvec<L, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < L; i++) {
			if (f == (*self->super_type)[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<int L, typename T>
static PyObject * mvec_richcompare(mvec<L, T> * self, PyObject * other, int comp_type) {
	glm::vec<L, T> o2;

	if (!unpack_vec(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (*self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (*self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_LT:
		return pack_vec<L, T>(glm::lessThan(*self->super_type, o2));
		break;
	case Py_LE:
		return pack_vec<L, T>(glm::lessThanEqual(*self->super_type, o2));
		break;
	case Py_GT:
		return pack_vec<L, T>(glm::greaterThan(*self->super_type, o2));
		break;
	case Py_GE:
		return pack_vec<L, T>(glm::greaterThanEqual(*self->super_type, o2));
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

template<typename T>
static bool unswizzle_mvec(mvec<2, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_mvec(mvec<3, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type->z;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_mvec(mvec<4, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type->z;
		return true;
	}
	if (c == 'w' || c == 'a' || c == 'p') {
		out = self->super_type->w;
		return true;
	}
	return false;
}

//template<int L, typename T>
//static bool unswizzle_mvec(mvec<L, T>* self, char c, T& out) {
//	if (L == 2) {
//		return unswizzle_mvec2<T>(self, c, out);
//	}
//	if (L == 3) {
//		return unswizzle_mvec3<T>(self, c, out);
//	}
//	return unswizzle_mvec4<T>(self, c, out);
//}

template<int L, typename T>
static PyObject * mvec_getattr(PyObject * obj, PyObject * name) {
	char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);

	if (len >= 4 && name_as_ccp[0] == '_' && name_as_ccp[1] == '_' && name_as_ccp[len - 1] == '_' && name_as_ccp[len - 2] == '_') {
		return PyObject_GenericGetAttr(obj, name);
	}
	if (len == 1) {
		T x;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x)) {
			return PyGLM_PyObject_FromNumber<T>((T)x);
		}
	}
	else if (len == 2) {
		T x;
		T y;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y)) {
			return pack_vec<2, T>(glm::vec<2, T>(x, y));
		}
	}
	else if (len == 3) {
		T x;
		T y;
		T z;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[2], z)) {
			return pack_vec<3, T>(glm::vec<3, T>(x, y, z));
		}
	}
	else if (len == 4) {
		T x;
		T y;
		T z;
		T w;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[2], z) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[3], w)) {
			return pack_vec<4, T>(glm::vec<4, T>(x, y, z, w));
		}
	}
	return PyObject_GenericGetAttr(obj, name);
}

template<typename T>
static int mvec2_setattr(mvec<2, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}
template<typename T>
static int mvec3_setattr(mvec<3, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'z') {
		obj->super_type->z = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}
template<typename T>
static int mvec4_setattr(mvec<4, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'z') {
		obj->super_type->z = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'w') {
		obj->super_type->w = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}

// iterator

template<int L, typename T>
static PyObject *
mvecIter_new(PyTypeObject *type, PyObject *args, PyObject *)
{
	mvec<L, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	mvecIter<L, T> *rgstate = (mvecIter<L, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static void
mvecIter_dealloc(mvecIter<L, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
mvec2Iter_next(mvecIter<2, T> *rgstate)
{
	if (rgstate->seq_index < 2) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		}
	}
	rgstate->seq_index = 2;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
mvec3Iter_next(mvecIter<3, T> *rgstate)
{
	if (rgstate->seq_index < 3) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->z);
		}
	}
	rgstate->seq_index = 3;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
mvec4Iter_next(mvecIter<4, T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->z);
		case 3:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->w);
		}
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int L, typename T>
static PyObject * mvec_geniter(mvec<L, T>* self) {
	mvecIter<L, T> *rgstate = (mvecIter<L, T> *)(PyGLM_MVECITER_TYPE<L, T>()->tp_alloc(PyGLM_MVECITER_TYPE<L, T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static int
mvec_getbuffer(mvec<L, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	if ((flags & PyBUF_RECORDS_RO) != PyBUF_RECORDS_RO || (flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS || (flags & PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS) {
		PyErr_SetString(PyExc_BufferError, "This type of buffer is not supported.");
		view->obj = NULL;
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)self->super_type;
	view->len = sizeof(glm::vec<L, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : \
		(std::is_same <T, std::int32_t>::value) ? const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ? const_cast<char*>("I") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = L;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
mvec_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}
#pragma endregion 

// type vec
#pragma region type mat
template<int C>
static PyObject* mat_length(PyObject *, PyObject*) {
	return PyLong_FromLong(C);
}

static void
mat_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<int C, int R, typename T>
static PyObject *
mat_new(PyTypeObject *type, PyObject *, PyObject *)
{
	mat<C, R, T> *self = (mat<C, R, T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->shape = C + (R << 3);
		self->super_type = glm::mat<C, R, T>();
	}
	return (PyObject *)self;
}


template<typename T>
static int
mat2x2_init(mat<2, 2, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	
	if (!PyArg_UnpackTuple(args, "mat2x2", 0, 4,
		&arg1, &arg2, &arg3, &arg4)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
		
	if (arg1 == NULL) {
		return 0;
	}
	
	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
	
	if (arg3 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
			return -1;
		}
		self->super_type = glm::mat<2, 2, T>(o, o2);
		return 0;
	}
	
	if (arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
	
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
		self->super_type = glm::mat<2, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
	return -1;
}

template<typename T>
static int
mat2x3_init(mat<2, 3, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;

	if (!PyArg_UnpackTuple(args, "mat2x3", 0, 6,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (arg3 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
			return -1;
		}
		self->super_type = glm::mat<2, 3, T>(o, o2);
		return 0;
	}

	if (arg4 == NULL || arg5 == NULL || arg6 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {
		self->super_type = glm::mat<2, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
	return -1;
}

template<typename T>
static int
mat2x4_init(mat<2, 4, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;

	if (!PyArg_UnpackTuple(args, "mat2x4", 0, 8,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (arg3 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
			return -1;
		}
		self->super_type = glm::mat<2, 4, T>(o, o2);
		return 0;
	}

	if (arg4 == NULL || arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8)) {
		self->super_type = glm::mat<2, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
	return -1;
}

template<typename T>
static int
mat3x2_init(mat<3, 2, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x2", 0, 6,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		glm::vec<2, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		self->super_type = glm::mat<3, 2, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {
		self->super_type = glm::mat<3, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
	return -1;
}

template<typename T>
static int
mat3x3_init(mat<3, 3, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x3", 0, 9,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		glm::vec<3, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		self->super_type = glm::mat<3, 3, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9)) {
		self->super_type = glm::mat<3, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
	return -1;
}

template<typename T>
static int
mat3x4_init(mat<3, 4, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x4", 0, 12,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		glm::vec<4, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		self->super_type = glm::mat<3, 4, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12)) {
		self->super_type = glm::mat<3, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
	return -1;
}

template<typename T>
static int
mat4x2_init(mat<4, 2, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x2", 0, 8,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		self->super_type = glm::mat<4, 2, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8)) {
		self->super_type = glm::mat<4, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
	return -1;
}

template<typename T>
static int
mat4x3_init(mat<4, 3, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x3", 0, 12,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		self->super_type = glm::mat<4, 3, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12)) {
		self->super_type = glm::mat<4, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
	return -1;
}

template<typename T>
static int
mat4x4_init(mat<4, 4, T> *self, PyObject *args, PyObject *)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;
	PyObject *arg13 = NULL;
	PyObject *arg14 = NULL;
	PyObject *arg15 = NULL;
	PyObject *arg16 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x4", 0, 16,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13, &arg14, &arg15, &arg16)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		self->super_type = glm::mat<4, 4, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL || arg13 == NULL || arg14 == NULL || arg15 == NULL || arg16 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12) && PyGLM_Number_Check(arg13) && PyGLM_Number_Check(arg14) && PyGLM_Number_Check(arg15) && PyGLM_Number_Check(arg16)) {
		self->super_type = glm::mat<4, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12), PyGLM_Number_FromPyObject<T>(arg13), PyGLM_Number_FromPyObject<T>(arg14), PyGLM_Number_FromPyObject<T>(arg15), PyGLM_Number_FromPyObject<T>(arg16));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
	return -1;
}

// unaryfunc
template<int C, int R, typename T>
static PyObject *
mat_neg(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(-obj->super_type);
}

template<int C, int R, typename T>
static PyObject *
mat_pos(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(obj->super_type);
}

template<int C, int R, typename T>
static PyObject *
mat_abs(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(glm::abs(obj->super_type));
}

// binaryfunc
template<int C, int R, typename T>
static PyObject *
matsq_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) + (((mat<C, R, T>*)obj2)->super_type));
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm.mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o + o2);
}

template<int C, int R, typename T>
static PyObject *
mat_add(PyObject *obj1, PyObject *obj2)
{
	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm.mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o + o2);
}

template<int C, int R, typename T>
static PyObject *
matsq_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) - (((mat<C, R, T>*)obj2)->super_type));
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm.mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o - o2);
}

template<int C, int R, typename T>
static PyObject *
mat_sub(PyObject *obj1, PyObject *obj2)
{
	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm.mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o - o2);
}

template<int C, int R, typename T>
static PyObject *
mat_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat(PyGLM_Number_FromPyObject<T>(obj1) * ((mat<C, R, T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(R, T, obj1)) { // obj1 is a col_type
		glm::vec<R, T> o;
		unpack_vec(obj1, o);

		return pack_vec(o * ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T> (obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for *: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(C, T, obj2)) { // obj2 is a row_type
		glm::vec<C, T> o2;
		unpack_vec(obj2, o2);

		return pack_vec(o * o2);
	}

	if (PyGLM_Mat_Check(2, C, T, obj2)) {
		glm::mat<2, C, T> o2;
		unpack_mat<2, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	if (PyGLM_Mat_Check(3, C, T, obj2)) {
		glm::mat<3, C, T> o2;
		unpack_mat<3, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	if (PyGLM_Mat_Check(4, C, T, obj2)) {
		glm::mat<4, C, T> o2;
		unpack_mat<4, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	Py_RETURN_NOTIMPLEMENTED;
}

template<int C, int R, typename T>
static PyObject *
matsq_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) / ((mat<C, R, T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(R, T, obj1)) { // obj1 is a col_type
		glm::vec<R, T> o;
		unpack_vec(obj1, o);

		return pack_vec(o / ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T>(obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for /: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(C, T, obj2)) { // obj2 is a row_type
		glm::vec<C, T> o2;
		unpack_vec(obj2, o2);

		return pack_vec(o / o2);
	}

	if (PyGLM_Mat_Check(C, R, T, obj2)) {
		glm::mat<C, R, T> o2;
		unpack_mat<C, R, T>(obj2, o2);

		return pack_mat(o / o2);
	}
	Py_RETURN_NOTIMPLEMENTED;
}

template<int C, int R, typename T>
static PyObject *
mat_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat(PyGLM_Number_FromPyObject<T>(obj1) / ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T>(obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for /: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o / PyGLM_Number_FromPyObject<T>(obj2));
	}
	Py_RETURN_NOTIMPLEMENTED;
}

// inplace
// binaryfunc
template<int C, int R, typename T>
static PyObject *
matsq_iadd(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_add<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_iadd(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_add<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
matsq_isub(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_sub<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_isub(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_sub<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_imul(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_mul<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Mat_Check(C, R, T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
matsq_idiv(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_div<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Mat_Check(C, R, T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_idiv(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_div<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}



template<typename T>
static PyObject *
mat2x2_str(mat<2, 2, T>* self)
{
	char * out = (char*)malloc((64) * sizeof(char));
	snprintf(out, 64, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x3_str(mat<2, 3, T>* self)
{
	char * out = (char*)malloc((94) * sizeof(char));
	snprintf(out, 94, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x4_str(mat<2, 4, T>* self)
{
	char * out = (char*)malloc((124) * sizeof(char));
	snprintf(out, 124, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x2_str(mat<3, 2, T>* self)
{
	char * out = (char*)malloc((96) * sizeof(char));
	snprintf(out, 96, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[2][0], (double)self->super_type[2][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x3_str(mat<3, 3, T>* self)
{
	char * out = (char*)malloc((141) * sizeof(char));
	snprintf(out, 141, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x4_str(mat<3, 4, T>* self)
{
	char * out = (char*)malloc((186) * sizeof(char));
	snprintf(out, 186, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[2][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x2_str(mat<4, 2, T>* self)
{
	char * out = (char*)malloc((128) * sizeof(char));
	snprintf(out, 128, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[3][0], (double)self->super_type[3][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x3_str(mat<4, 3, T>* self)
{
	char * out = (char*)malloc((188) * sizeof(char));
	snprintf(out, 188, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[3][0], (double)self->super_type[3][1], (double)self->super_type[3][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x4_str(mat<4, 4, T>* self)
{
	char * out = (char*)malloc((248) * sizeof(char));
	snprintf(out, 248, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[2][3], (double)self->super_type[3][0], (double)self->super_type[3][1], (double)self->super_type[3][2], (double)self->super_type[3][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x2_repr(mat<2, 2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 60 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g | %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x3_repr(mat<2, 3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 88 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g | %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x4_repr(mat<2, 4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 116 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x2_repr(mat<3, 2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 89 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g | %.6g, %.6g | %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[2][0], (double)self->super_type[2][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x3_repr(mat<3, 3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 131 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g | %.6g, %.6g, %.6g | %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x4_repr(mat<3, 4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 173 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[2][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x2_repr(mat<4, 2, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 118 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g | %.6g, %.6g | %.6g, %.6g | %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[3][0], (double)self->super_type[3][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x3_repr(mat<4, 3, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 174 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g | %.6g, %.6g, %.6g | %.6g, %.6g, %.6g | %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[3][0], (double)self->super_type[3][1], (double)self->super_type[3][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x4_repr(mat<4, 4, T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 230 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g | %.6g, %.6g, %.6g, %.6g )", &name[4], (double)self->super_type[0][0], (double)self->super_type[0][1], (double)self->super_type[0][2], (double)self->super_type[0][3], (double)self->super_type[1][0], (double)self->super_type[1][1], (double)self->super_type[1][2], (double)self->super_type[1][3], (double)self->super_type[2][0], (double)self->super_type[2][1], (double)self->super_type[2][2], (double)self->super_type[2][3], (double)self->super_type[3][0], (double)self->super_type[3][1], (double)self->super_type[3][2], (double)self->super_type[3][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int C>
static Py_ssize_t mat_len(PyObject *) {
	return (Py_ssize_t)C;
}

template<typename T>
static PyObject* mat2x2_mp_item(mat<2, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat2x3_mp_item(mat<2, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat2x4_mp_item(mat<2, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x2_mp_item(mat<3, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x3_mp_item(mat<3, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x4_mp_item(mat<3, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x2_mp_item(mat<4, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x3_mp_item(mat<4, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x4_mp_item(mat<4, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static int mat2x2_mp_ass_item(mat<2, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat2x3_mp_ass_item(mat<2, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat2x4_mp_ass_item(mat<2, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x2_mp_ass_item(mat<3, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x3_mp_ass_item(mat<3, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x4_mp_ass_item(mat<3, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x2_mp_ass_item(mat<4, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x3_mp_ass_item(mat<4, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x4_mp_ass_item(mat<4, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<int C, int R, typename T>
static int mat_contains(mat<C, R, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int n = 0; n < C; n++) {
			for (int m = 0; m < R; m++) {
				if (f == self->super_type[n][m]) {
					contains = true;
					break;
				}
			}
		}
		return (int)contains;
	}
	if (PyGLM_Vec_Check(R, T, value)) {
		glm::vec<R, T> o;
		unpack_vec(value, o);
		for (int n = 0; n < C; n++) {
			bool contains = true;
			for (int m = 0; m < R; m++) {
				if (o[m] != self->super_type[n][m]) {
					contains = false;
					break;
				}
			}
			if (contains) {
				return 1;
			}
		}
	}
	return 0;

}

template<int C, int R, typename T>
static PyObject * mat_richcompare(mat<C, R, T> * self, PyObject * other, int comp_type) {
	glm::mat<C, R, T> o2;

	if (!unpack_mat(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

// iterator

template<int C, int R, typename T>
static PyObject *
matIter_new(PyTypeObject *type, PyObject *args, PyObject *)
{
	mat<C, R, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	matIter<C, R, T> *rgstate = (matIter<C, R, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int C, int R, typename T>
static void
matIter_dealloc(matIter<C, R, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<int C, int R, typename T>
static PyObject *
matIter_next(matIter<C, R, T> *rgstate)
{
	if (rgstate->seq_index < C) {
		return pack_mvec<R, T>(&rgstate->sequence->super_type[rgstate->seq_index++], (PyObject*)rgstate->sequence);
	}
	rgstate->seq_index = C;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int C, int R, typename T>
static PyObject * mat_geniter(mat<C, R, T>* self) {
	PyTypeObject* matIterType = PyGLM_MATITER_TYPE<C, R, T>();
	matIter<C, R, T> *rgstate = (matIter<C, R, T> *)(matIterType->tp_alloc(matIterType, 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int C, int R, typename T>
static int
mat_getbuffer(mat<C, R, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	if ((flags & PyBUF_RECORDS_RO) != PyBUF_RECORDS_RO || (flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS || (flags & PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS) {
		PyErr_SetString(PyExc_BufferError, "This type of buffer is not supported.");
		view->obj = NULL;
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0][0];
	view->len = sizeof(glm::mat<C, R, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : \
		(std::is_same <T, std::int32_t>::value) ? const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ? const_cast<char*>("I") : NULL;
	view->ndim = 2;
	view->shape = (Py_ssize_t*)malloc(2 * sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = C;
		view->shape[1] = R;
	}
	view->strides = (Py_ssize_t*)malloc(2 * sizeof(Py_ssize_t));
	if (view->strides != NULL) {
		view->strides[0] = sizeof(typename glm::mat<C, R, T>::col_type);
		view->strides[1] = sizeof(T);
	}
	
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
mat_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
	free(view->strides);
}
#pragma endregion 

// type qua
#pragma region type qua
static PyObject* qua_length(PyObject*, PyObject*) {
	return PyLong_FromLong(4);
}

static void
qua_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<typename T>
static PyObject *
qua_new(PyTypeObject *type, PyObject *, PyObject *)
{
	qua<T> *self = (qua<T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->super_type = glm::qua<T>();
	}

	return (PyObject *)self;
}

template<typename T>
static int
qua_init(qua<T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", "w", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;
	PyObject * arg4 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3, &arg4)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Qua_Check(T, arg1)) {
				glm::qua<T> o;
				if (unpack_qua(arg1, o)) {
					self->super_type = o;
					return 0;
				}
			}
			else if (PyGLM_Vec_Check(3, T, arg1)) {
				glm::vec<3, T> o;
				if (unpack_vec(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			else if (PyGLM_Mat_Check(3, 3, T, arg1)) {
				glm::mat<3, 3, T> o;
				if (unpack_mat(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			else if (PyGLM_Mat_Check(4, 4, T, arg1)) {
				glm::mat<4, 4, T> o;
				if (unpack_mat(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
					return -1;
				}
				self->super_type = glm::qua<T>(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			glm::vec<3, T> o;
			if (!unpack_vec(arg1, o)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
				return -1;
			}
			glm::vec<3, T> o2;
			if (!unpack_vec(arg2, o2)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
				return -1;
			}
			self->super_type = glm::qua<T>(o, o2);
			return 0;
		}
		if (arg4 == NULL) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
			self->super_type = glm::qua<T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
	return -1;
}

// unaryfunc
template<typename T>
static PyObject *
qua_neg(qua<T> *obj)
{
	return pack_qua<T>(-obj->super_type);
}

template<typename T>
static PyObject *
qua_pos(qua<T> *obj)
{
	return pack_qua<T>(obj->super_type);
}

// binaryfunc
template<typename T>
static PyObject *
qua_add(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm.qua' and ", obj1);
		return NULL;
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o + o2);
}

template<typename T>
static PyObject *
qua_sub(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm.qua' and ", obj1);
		return NULL;
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o - o2);
}

template<typename T>
static PyObject *
qua_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_qua<T>(PyGLM_Number_FromPyObject<T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(3, T, obj1)) {
		return pack_vec<3, T>(unpack_vec<3, T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(4, T, obj1)) {
		return pack_vec<4, T>(unpack_vec<4, T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm.qua' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_qua<T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(3, T, obj2)) {
		return pack_vec<3, T>(o * unpack_vec<3, T>(obj2));
	}

	if (PyGLM_Vec_Check(4, T, obj2)) {
		return pack_vec<4, T>(o * unpack_vec<4, T>(obj2));
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o * o2);
}

template<typename T>
static PyObject *
qua_div(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm.qua' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_qua<T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	Py_RETURN_NOTIMPLEMENTED;
}

// inplace
// binaryfunc
template<typename T>
static PyObject *
qua_iadd(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_add<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_isub(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_sub<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_imul(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_mul<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Qua_Check(T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_idiv(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_div<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_str(qua<T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 59 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %12.6g, %12.6g, %12.6g, %12.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
qua_repr(qua<T>* self)
{
	const char* name = ((PyObject*)self)->ob_type->tp_name;
	size_t required_space = 59 + strlen(name) - 4;
	char * out = (char*)malloc((required_space) * sizeof(char));
	snprintf(out, required_space, "%s( %.6g, %.6g, %.6g, %.6g )", &name[4], (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

static Py_ssize_t qua_len(PyObject*) {
	return (Py_ssize_t)4;
}

template<typename T>
static PyObject* qua_sq_item(qua<T> * self, Py_ssize_t index) {
	if (index < 0 || index > 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	return PyGLM_PyObject_FromNumber<T>((T)self->super_type[(glm::length_t)index]);
}

template<typename T>
static int qua_sq_ass_item(qua<T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	if (index < 0 || index > 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
	self->super_type[(glm::length_t)index] = f;

	return 0;
}

template<typename T>
static int qua_contains(qua<T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < 4; i++) {
			if (f == self->super_type[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<typename T>
static PyObject * qua_richcompare(qua<T> * self, PyObject * other, int comp_type) {
	glm::qua<T> o2;

	if (!unpack_qua(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

// iterator

template<typename T>
static PyObject *
quaIter_new(PyTypeObject *type, PyObject *args, PyObject *)
{
	qua<T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	quaIter<T> *rgstate = (quaIter<T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<typename T>
static void
quaIter_dealloc(quaIter<T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
quaIter_next(quaIter<T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type[rgstate->seq_index++]);
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject * qua_geniter(qua<T>* self) {
	quaIter<T> *rgstate = (quaIter<T> *)(PyGLM_QUAITER_TYPE<T>()->tp_alloc(PyGLM_QUAITER_TYPE<T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<typename T>
static int
qua_getbuffer(qua<T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	if ((flags & PyBUF_RECORDS_RO) != PyBUF_RECORDS_RO || (flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS || (flags & PyBUF_ANY_CONTIGUOUS) == PyBUF_ANY_CONTIGUOUS) {
		PyErr_SetString(PyExc_BufferError, "This type of buffer is not supported.");
		view->obj = NULL;
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0];
	view->len = sizeof(glm::qua<T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = 4;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
qua_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}
#pragma endregion 

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)

#pragma region macro generator functions
#define PyGLM_MAKE_GLM_FUNC_V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V2__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_N_V__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Number_Check(arg)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN_VVV_VNN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Number_Check(arg)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}
#define PyGLM_MAKE_GLM_FUNC_NNN_VVV__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN_VVN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_MM__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg1), unpack_mat<2, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg1), unpack_mat<2, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 3, float>(arg1), unpack_mat<2, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 3, double>(arg1), unpack_mat<2, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 4, float>(arg1), unpack_mat<2, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 4, double>(arg1), unpack_mat<2, 4, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 2, float>(arg1), unpack_mat<3, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 2, double>(arg1), unpack_mat<3, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg1), unpack_mat<3, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg1), unpack_mat<3, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 4, float>(arg1), unpack_mat<3, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 4, double>(arg1), unpack_mat<3, 4, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 2, float>(arg1), unpack_mat<4, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 2, double>(arg1), unpack_mat<4, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 3, float>(arg1), unpack_mat<4, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 3, double>(arg1), unpack_mat<4, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg1), unpack_mat<4, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg1), unpack_mat<4, 4, double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_M__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 4, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 4, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_S__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_S_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC__rF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject*) {\
	return pack(glm::NAME<double>());\
}

#define PyGLM_MAKE_GLM_FUNC_M4V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5, *arg6;\
	PyGLM_Arg_Unpack_6O(args, #NAME, arg1, arg2, arg3, arg4, arg5, arg6);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5), PyGLM_Number_FromPyObject<float>(arg6)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4;\
	PyGLM_Arg_Unpack_4O(args, #NAME, arg1, arg2, arg3, arg4);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4;\
	PyGLM_Arg_Unpack_4O(args, #NAME, arg1, arg2, arg3, arg4);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2) && PyGLM_Mat_Check(4, 4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_mat<4, 4, float>(arg2), unpack_mat<4, 4, float>(arg3), unpack_vec<4, float>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2) && PyGLM_Mat_Check(4, 4, float, arg3) && PyGLM_Vec_Check(4, double, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_mat<4, 4, float>(arg2), unpack_mat<4, 4, float>(arg3), unpack_vec<4, double>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2) && PyGLM_Mat_Check(4, 4, double, arg3) && PyGLM_Vec_Check(4, float, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_mat<4, 4, double>(arg2), unpack_mat<4, 4, double>(arg3), unpack_vec<4, float>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2) && PyGLM_Mat_Check(4, 4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_mat<4, 4, double>(arg2), unpack_mat<4, 4, double>(arg3), unpack_vec<4, double>(arg4)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_QQN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_qua<float>(arg1), unpack_qua<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_qua<double>(arg1), unpack_qua<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_Q(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_M3_M4__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::uint>(arg1), unpack_vec<1, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u64>(arg1), unpack_vec<1, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u16>(arg1), unpack_vec<1, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u8>(arg1), unpack_vec<1, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, bool>(arg1), unpack_vec<1, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::uint>(arg1), unpack_vec<2, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u64>(arg1), unpack_vec<2, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u16>(arg1), unpack_vec<2, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u8>(arg1), unpack_vec<2, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, bool>(arg1), unpack_vec<2, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u64>(arg1), unpack_vec<3, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u16>(arg1), unpack_vec<3, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u8>(arg1), unpack_vec<3, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, bool>(arg1), unpack_vec<3, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::uint>(arg1), unpack_vec<4, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u64>(arg1), unpack_vec<4, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u16>(arg1), unpack_vec<4, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u8>(arg1), unpack_vec<4, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, bool>(arg1), unpack_vec<4, bool>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::uint>(arg1), unpack_vec<1, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u64>(arg1), unpack_vec<1, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u16>(arg1), unpack_vec<1, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u8>(arg1), unpack_vec<1, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::uint>(arg1), unpack_vec<2, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u64>(arg1), unpack_vec<2, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u16>(arg1), unpack_vec<2, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u8>(arg1), unpack_vec<2, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u64>(arg1), unpack_vec<3, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u16>(arg1), unpack_vec<3, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u8>(arg1), unpack_vec<3, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::uint>(arg1), unpack_vec<4, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u64>(arg1), unpack_vec<4, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u16>(arg1), unpack_vec<4, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u8>(arg1), unpack_vec<4, glm::u8>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV_QQ__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {\
		return pack(glm::NAME(unpack_qua<float>(arg1), unpack_qua<float>(arg2)));\
	}\
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {\
		return pack(glm::NAME(unpack_qua<double>(arg1), unpack_qua<double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_N_V__tiqsu(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Number_Check(arg)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<glm::i64>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tiqsu(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), PyGLM_Number_FromPyObject<int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), PyGLM_Number_FromPyObject<glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), PyGLM_Number_FromPyObject<glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), PyGLM_Number_FromPyObject<int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), PyGLM_Number_FromPyObject<glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), PyGLM_Number_FromPyObject<glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), PyGLM_Number_FromPyObject<int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), PyGLM_Number_FromPyObject<glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), PyGLM_Number_FromPyObject<glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), PyGLM_Number_FromPyObject<int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), PyGLM_Number_FromPyObject<glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), PyGLM_Number_FromPyObject<glm::i8>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV__tiqsu(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<glm::i64>(arg1), PyGLM_Number_FromPyObject<glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_VV(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::uint>(arg1), unpack_vec<1, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u64>(arg1), unpack_vec<1, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u16>(arg1), unpack_vec<1, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u8>(arg1), unpack_vec<1, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, bool>(arg1), unpack_vec<1, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::uint>(arg1), unpack_vec<2, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u64>(arg1), unpack_vec<2, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u16>(arg1), unpack_vec<2, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u8>(arg1), unpack_vec<2, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, bool>(arg1), unpack_vec<2, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u64>(arg1), unpack_vec<3, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u16>(arg1), unpack_vec<3, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u8>(arg1), unpack_vec<3, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, bool>(arg1), unpack_vec<3, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::uint>(arg1), unpack_vec<4, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u64>(arg1), unpack_vec<4, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u16>(arg1), unpack_vec<4, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u8>(arg1), unpack_vec<4, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, bool>(arg1), unpack_vec<4, bool>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}
#pragma endregion


static PyObject*
packDouble2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::uint, arg)) {
		glm::uvec2 o;
		unpack_vec(arg, o);
		return PyFloat_FromDouble(glm::packDouble2x32(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packDouble2x32(): ", arg);
	return NULL;
}

static PyObject*
packHalf1x16_(PyObject*, PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyLong_FromUnsignedLong((unsigned long)glm::packHalf1x16(PyGLM_Number_FromPyObject<float>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packHalf1x16(): ", arg);
	return NULL;
}

static PyObject*
packHalf2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packHalf2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packHalf2x16(): ", arg);
	return NULL;
}

static PyObject*
packHalf4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLongLong(glm::packHalf4x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packHalf4x16(): ", arg);
	return NULL;
}

static PyObject*
packI3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::vec<4, int> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packI3x10_1x2(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packI3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
packU3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, unsigned int, arg)) {
		glm::vec<4, unsigned int> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packU3x10_1x2(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packU3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
packF2x11_1x10_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packF2x11_1x10(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packF2x11_1x10(): ", arg);
	return NULL;
}

static PyObject*
packF3x9_E1x5_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packF3x9_E1x5(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packF3x9_E1x5(): ", arg);
	return NULL;
}

static PyObject*
packRGBM_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return pack(glm::packRGBM(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		return pack(glm::packRGBM(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packRGBM(): ", arg);
	return NULL;
}

static PyObject*
packHalf_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, float, arg)) {
		glm::vec<1, float> o;
		unpack_vec(arg, o);
		return pack(glm::packHalf(o));
	}
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		return pack(glm::packHalf(o));
	}
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return pack(glm::packHalf(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		return pack(glm::packHalf(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packHalf(): ", arg);
	return NULL;
}

static PyObject*
packInt2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::i8, arg)) {
		glm::vec<2, glm::i8> o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packInt2x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packInt2x8(): ", arg);
	return NULL;
}

static PyObject*
packInt4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, glm::i8, arg)) {
		glm::vec<4, glm::i8> o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packInt4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packInt4x8(): ", arg);
	return NULL;
}

static PyObject*
packInt2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::i16, arg)) {
		glm::vec<2, glm::i16> o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packInt2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packInt2x16(): ", arg);
	return NULL;
}

static PyObject*
packInt4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, glm::i16, arg)) {
		glm::vec<4, glm::i16> o;
		unpack_vec(arg, o);
		return PyLong_FromLongLong(glm::packInt4x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packInt4x16(): ", arg);
	return NULL;
}

static PyObject*
packInt2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::i32, arg)) {
		glm::vec<2, glm::i32> o;
		unpack_vec(arg, o);
		return PyLong_FromLongLong(glm::packInt2x32(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packInt2x32(): ", arg);
	return NULL;
}

static PyObject*
packUint2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::u8, arg)) {
		glm::vec<2, glm::u8> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUint2x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUint2x8(): ", arg);
	return NULL;
}

static PyObject*
packUint4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, glm::u8, arg)) {
		glm::vec<4, glm::u8> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUint4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUint4x8(): ", arg);
	return NULL;
}

static PyObject*
packUint2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::u16, arg)) {
		glm::vec<2, glm::u16> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUint2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUint2x16(): ", arg);
	return NULL;
}

static PyObject*
packUint4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, glm::u16, arg)) {
		glm::vec<4, glm::u16> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLongLong(glm::packUint4x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUint4x16(): ", arg);
	return NULL;
}

static PyObject*
packUint2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::u32, arg)) {
		glm::vec<2, glm::u32> o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLongLong(glm::packUint2x32(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUint2x32(): ", arg);
	return NULL;
}

static PyObject*
packSnorm1x8_(PyObject*, PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyLong_FromUnsignedLong((unsigned long)glm::packSnorm1x8(PyGLM_Number_FromPyObject<float>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm1x8(): ", arg);
	return NULL;
}

static PyObject*
packSnorm2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packSnorm2x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm2x8(): ", arg);
	return NULL;
}

static PyObject*
packSnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packSnorm4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
packSnorm1x16_(PyObject*, PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyLong_FromUnsignedLong((unsigned long)glm::packSnorm1x16(PyGLM_Number_FromPyObject<float>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm1x16(): ", arg);
	return NULL;
}

static PyObject*
packSnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packSnorm2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
packSnorm4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLongLong(glm::packSnorm4x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm4x16(): ", arg);
	return NULL;
}

static PyObject*
packSnorm3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong(glm::packSnorm3x10_1x2(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
packUnorm2x4_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm2x4(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm2x4(): ", arg);
	return NULL;
}

static PyObject*
packUnorm4x4_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm4x4(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm4x4(): ", arg);
	return NULL;
}

static PyObject*
packUnorm1x8_(PyObject*, PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm1x8(PyGLM_Number_FromPyObject<float>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm1x8(): ", arg);
	return NULL;
}

static PyObject*
packUnorm2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm2x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm2x8(): ", arg);
	return NULL;
}

static PyObject*
packUnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packUnorm4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
packUnorm1x16_(PyObject*, PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm1x16(PyGLM_Number_FromPyObject<float>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm1x16(): ", arg);
	return NULL;
}

static PyObject*
packUnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packUnorm2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
packUnorm4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLongLong(glm::packUnorm4x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm4x16(): ", arg);
	return NULL;
}

static PyObject*
packUnorm3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong(glm::packUnorm3x10_1x2(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
packUnorm1x5_1x6_1x5_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec3 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm1x5_1x6_1x5(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm1x5_1x6_1x5(): ", arg);
	return NULL;
}

static PyObject*
packUnorm3x5_1x1_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm3x5_1x1(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm3x5_1x1(): ", arg);
	return NULL;
}

static PyObject*
packUnorm2x3_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec3 o;
		unpack_vec(arg, o);
		return PyLong_FromUnsignedLong((unsigned long)glm::packUnorm2x3_1x2(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm2x3_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackDouble2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackDouble2x32(PyGLM_Number_FromPyObject<double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackDouble2x32(): ", arg);
	return NULL;
}

static PyObject*
unpackHalf1x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackHalf1x16(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackHalf1x16(): ", arg);
	return NULL;
}

static PyObject*
unpackHalf2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackHalf2x16(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackHalf2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackHalf4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackHalf4x16(PyGLM_Number_FromPyObject<glm::u64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackHalf4x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm1x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm1x8(PyGLM_Number_FromPyObject<glm::u8>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm1x8(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm2x8(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm2x8(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm1x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm1x16(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm1x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm2x16(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm4x16(PyGLM_Number_FromPyObject<glm::u64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm4x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm3x10_1x2(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm1x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm1x8(PyGLM_Number_FromPyObject<glm::u8>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm1x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm2x8(PyGLM_Number_FromPyObject<glm::u8>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm2x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm1x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm1x16(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm1x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm2x16(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm4x16(PyGLM_Number_FromPyObject<glm::u64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm4x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm3x10_1x2(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm2x4_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm2x4(PyGLM_Number_FromPyObject<glm::u8>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm2x4(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm4x4_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm4x4(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm4x4(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm1x5_1x6_1x5_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm1x5_1x6_1x5(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm1x5_1x6_1x5(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm3x5_1x1_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm3x5_1x1(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm3x5_1x1(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm2x3_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm2x3_1x2(PyGLM_Number_FromPyObject<glm::u8>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm2x3_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackSnorm4x8(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUnorm4x8(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackInt2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackInt2x8(PyGLM_Number_FromPyObject<glm::i16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackInt2x8(): ", arg);
	return NULL;
}

static PyObject*
unpackInt4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackInt4x8(PyGLM_Number_FromPyObject<glm::i32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackInt4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackInt2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackInt2x16(PyGLM_Number_FromPyObject<glm::i32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackInt2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackInt4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackInt4x16(PyGLM_Number_FromPyObject<glm::i64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackInt4x16(): ", arg);
	return NULL;
}

static PyObject*
unpackInt2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackInt2x32(PyGLM_Number_FromPyObject<glm::i64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackInt2x32(): ", arg);
	return NULL;
}

static PyObject*
unpackUint2x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUint2x8(PyGLM_Number_FromPyObject<glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUint2x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUint4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUint4x8(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUint4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUint2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUint2x16(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUint2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUint4x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUint4x16(PyGLM_Number_FromPyObject<glm::u64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUint4x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUint2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackUint2x32(PyGLM_Number_FromPyObject<glm::u64>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUint2x32(): ", arg);
	return NULL;
}

static PyObject*
unpackI3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackI3x10_1x2(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackI3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackU3x10_1x2_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackU3x10_1x2(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackU3x10_1x2(): ", arg);
	return NULL;
}

static PyObject*
unpackF2x11_1x10_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackF2x11_1x10(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackF2x11_1x10(): ", arg);
	return NULL;
}

static PyObject*
unpackF3x9_E1x5_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack(glm::unpackF3x9_E1x5(PyGLM_Number_FromPyObject<glm::u32>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackF3x9_E1x5(): ", arg);
	return NULL;
}

static PyObject*
unpackRGBM_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		return pack(glm::unpackRGBM(unpack_vec<4, float>(arg)));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		return pack(glm::unpackRGBM(unpack_vec<4, double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackRGBM(): ", arg);
	return NULL;
}

static PyObject*
unpackHalf_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, glm::u16, arg)) {
		return pack(glm::unpackHalf(unpack_vec<1, glm::u16>(arg)));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg)) {
		return pack(glm::unpackHalf(unpack_vec<2, glm::u16>(arg)));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg)) {
		return pack(glm::unpackHalf(unpack_vec<3, glm::u16>(arg)));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg)) {
		return pack(glm::unpackHalf(unpack_vec<4, glm::u16>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackHalf(): ", arg);
	return NULL;
}

static PyObject*
uaddCarry_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "uaddCarry", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "uaddCarry() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if(PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2) && Py_TYPE(arg3) == &huvec1Type) {
		glm::uvec1 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<1, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<2, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<3, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<4, glm::uint>*)arg3)->super_type));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for uaddCarry()");
	return NULL;
}

static PyObject*
usubBorrow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "usubBorrow", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "usubBorrow() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2) && Py_TYPE(arg3) == &huvec1Type) {
		glm::uvec1 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<1, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<2, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<3, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<4, glm::uint>*)arg3)->super_type));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for usubBorrow()");
	return NULL;
}

static PyObject*
umulExtended_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "umulExtended", arg1, arg2, arg3, arg4);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "umulExtended() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2) && Py_TYPE(arg3) == &huvec1Type && Py_TYPE(arg4) == &huvec1Type) {
		glm::uvec1 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<1, glm::uint>*)arg3)->super_type, ((vec<1, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type && Py_TYPE(arg4) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<2, glm::uint>*)arg3)->super_type, ((vec<2, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type && Py_TYPE(arg4) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<3, glm::uint>*)arg3)->super_type, ((vec<3, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type && Py_TYPE(arg4) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<4, glm::uint>*)arg3)->super_type, ((vec<4, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for umulExtended()");
	return NULL;
}

static PyObject*
imulExtended_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "imulExtended", arg1, arg2, arg3, arg4);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "imulExtended() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2) && Py_TYPE(arg3) == &hivec1Type && Py_TYPE(arg4) == &hivec1Type) {
		glm::ivec1 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<1, int>*)arg3)->super_type, ((vec<1, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2) && Py_TYPE(arg3) == &hivec2Type && Py_TYPE(arg4) == &hivec2Type) {
		glm::ivec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<2, int>*)arg3)->super_type, ((vec<2, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2) && Py_TYPE(arg3) == &hivec3Type && Py_TYPE(arg4) == &hivec3Type) {
		glm::ivec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<3, int>*)arg3)->super_type, ((vec<3, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2) && Py_TYPE(arg3) == &hivec4Type && Py_TYPE(arg4) == &hivec4Type) {
		glm::ivec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<4, int>*)arg3)->super_type, ((vec<4, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for imulExtended()");
	return NULL;
}

static PyObject*
bitfieldExtract_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "bitfieldExtract", arg1, arg2, arg3);
	if (PyLong_Check(arg2) && PyLong_Check(arg3)) {
		int i = (int)PyLong_AS_LONG(arg2), i2 = (int)PyLong_AS_LONG(arg3);
		if (PyLong_Check(arg1)) {
			return PyLong_FromLong(glm::bitfieldExtract(PyLong_AS_LONG(arg1), i, i2));
		}
		if (PyGLM_Vec_Check(1, int, arg1)) {
			glm::ivec1 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
		if (PyGLM_Vec_Check(2, int, arg1)) {
			glm::ivec2 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
		if (PyGLM_Vec_Check(3, int, arg1)) {
			glm::ivec3 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
		if (PyGLM_Vec_Check(4, int, arg1)) {
			glm::ivec4 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for bitfieldExtract()");
	return NULL;
}

static PyObject*
bitfieldInsert_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "bitfieldInsert", arg1, arg2, arg3, arg4);
	if (PyLong_Check(arg3) && PyLong_Check(arg4)) {
		int i = (int)PyLong_AS_LONG(arg3), i2 = (int)PyLong_AS_LONG(arg4);
		if (PyLong_Check(arg1) && PyLong_Check(arg2)) {
			return PyLong_FromLong(glm::bitfieldInsert(PyLong_AS_LONG(arg1), PyLong_AS_LONG(arg2), i, i2));
		}
		if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			glm::ivec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::ivec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::ivec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::ivec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for bitfieldInsert()");
	return NULL;
}

static PyObject* bitfieldReverse_(PyObject*, PyObject* arg) { 
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::bitfieldReverse(PyLong_AsUnsignedLong(arg))); 
	} 
	if (PyGLM_Vec_Check(1, glm::uint, arg)) {
		return pack_vec(glm::bitfieldReverse(unpack_vec<1, glm::uint>(arg)));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg)) { 
		return pack_vec(glm::bitfieldReverse(unpack_vec<2, glm::uint>(arg)));
	} 
	if (PyGLM_Vec_Check(3, glm::uint, arg)) {
		return pack_vec(glm::bitfieldReverse(unpack_vec<3, glm::uint>(arg)));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg)) {
		return pack_vec(glm::bitfieldReverse(unpack_vec<4, glm::uint>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for bitfieldReverse(): ", arg); 
	return NULL; 
}

static PyObject*
bitCount_(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::bitCount(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(1, int, arg)) {
		glm::ivec1 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for bitCount(): ", arg);
	return NULL;
}

static PyObject*
findLSB_(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::findLSB(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(1, int, arg)) {
		glm::ivec1 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for findLSB(): ", arg);
	return NULL;
}

static PyObject*
findMSB_(PyObject* , PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::findMSB(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(1, int, arg)) {
		glm::ivec1 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for findMSB(): ", arg);
	return NULL;
}

static PyObject*
equal(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "equal", 2, 3, &arg1, &arg2, &arg3)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			glm::vec<1, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {
			glm::vec<1, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {
			glm::vec<1, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {
			glm::vec<1, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {
			glm::vec<1, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {
			glm::vec<1, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {
			glm::vec<1, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {
			glm::vec<1, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {
			glm::vec<1, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::vec<2, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
			glm::vec<2, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
			glm::vec<2, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
			glm::vec<2, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
			glm::vec<2, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
			glm::vec<2, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
			glm::vec<2, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
			glm::vec<2, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
			glm::vec<2, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::vec<3, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
			glm::vec<3, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
			glm::vec<3, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
			glm::vec<3, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
			glm::vec<3, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
			glm::vec<3, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
			glm::vec<3, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
			glm::vec<3, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
			glm::vec<3, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::vec<4, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
			glm::vec<4, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
			glm::vec<4, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
			glm::vec<4, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
			glm::vec<4, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
			glm::vec<4, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
			glm::vec<4, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
			glm::vec<4, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
			glm::vec<4, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}

		//if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		//	glm::mat<2, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		//	glm::mat<2, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		//	glm::mat<2, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		//	glm::mat<2, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
		//	glm::mat<2, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
		//	glm::mat<2, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
		//	glm::mat<2, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
		//	glm::mat<2, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
		//	glm::mat<2, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
		//	glm::mat<2, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
		//	glm::mat<2, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
		//	glm::mat<2, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
		//	glm::mat<3, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
		//	glm::mat<3, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
		//	glm::mat<3, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
		//	glm::mat<3, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		//	glm::mat<3, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		//	glm::mat<3, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		//	glm::mat<3, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		//	glm::mat<3, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
		//	glm::mat<3, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
		//	glm::mat<3, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
		//	glm::mat<3, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
		//	glm::mat<3, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
		//	glm::mat<4, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
		//	glm::mat<4, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
		//	glm::mat<4, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
		//	glm::mat<4, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
		//	glm::mat<4, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
		//	glm::mat<4, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
		//	glm::mat<4, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
		//	glm::mat<4, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		//	glm::mat<4, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		//	glm::mat<4, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		//	glm::mat<4, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		//	glm::mat<4, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for equal(): ", arg1, arg2);
		return NULL;
	}
	if (PyLong_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::equal(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			pack(glm::equal(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(2, int, arg3)) {
		glm::vec<2, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(3, int, arg3)) {
		glm::vec<3, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(4, int, arg3)) {
		glm::vec<4, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
		glm::vec<1, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
		glm::vec<1, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}

	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
	return NULL;
}

static PyObject*
notEqual(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "notEqual", 2, 3, &arg1, &arg2, &arg3)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			glm::vec<1, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {
			glm::vec<1, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {
			glm::vec<1, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {
			glm::vec<1, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {
			glm::vec<1, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {
			glm::vec<1, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {
			glm::vec<1, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {
			glm::vec<1, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {
			glm::vec<1, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::vec<2, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
			glm::vec<2, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
			glm::vec<2, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
			glm::vec<2, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
			glm::vec<2, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
			glm::vec<2, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
			glm::vec<2, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
			glm::vec<2, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
			glm::vec<2, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::vec<3, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
			glm::vec<3, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
			glm::vec<3, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
			glm::vec<3, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
			glm::vec<3, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
			glm::vec<3, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
			glm::vec<3, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
			glm::vec<3, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
			glm::vec<3, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::vec<4, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
			glm::vec<4, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
			glm::vec<4, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
			glm::vec<4, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
			glm::vec<4, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
			glm::vec<4, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
			glm::vec<4, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
			glm::vec<4, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
			glm::vec<4, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}

		//if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		//	glm::mat<2, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		//	glm::mat<2, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		//	glm::mat<2, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		//	glm::mat<2, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
		//	glm::mat<2, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
		//	glm::mat<2, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
		//	glm::mat<2, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
		//	glm::mat<2, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
		//	glm::mat<2, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
		//	glm::mat<2, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
		//	glm::mat<2, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
		//	glm::mat<2, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
		//	glm::mat<3, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
		//	glm::mat<3, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
		//	glm::mat<3, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
		//	glm::mat<3, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		//	glm::mat<3, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		//	glm::mat<3, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		//	glm::mat<3, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		//	glm::mat<3, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
		//	glm::mat<3, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
		//	glm::mat<3, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
		//	glm::mat<3, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
		//	glm::mat<3, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
		//	glm::mat<4, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
		//	glm::mat<4, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
		//	glm::mat<4, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
		//	glm::mat<4, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
		//	glm::mat<4, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
		//	glm::mat<4, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
		//	glm::mat<4, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
		//	glm::mat<4, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		//	glm::mat<4, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		//	glm::mat<4, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		//	glm::mat<4, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		//	glm::mat<4, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for notEqual(): ", arg1, arg2);
		return NULL;
	}
	if (PyLong_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::notEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			pack(glm::notEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(2, int, arg3)) {
		glm::vec<2, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(3, int, arg3)) {
		glm::vec<3, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(4, int, arg3)) {
		glm::vec<4, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
		glm::vec<1, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
		glm::vec<1, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}

	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_VV(lessThan)
PyGLM_MAKE_GLM_FUNC_VV(lessThanEqual)
PyGLM_MAKE_GLM_FUNC_VV(greaterThan)
PyGLM_MAKE_GLM_FUNC_VV(greaterThanEqual)

//static PyObject*
//lessThan(PyObject*, PyObject* args) {
//	PyObject *arg1, *arg2;
//	PyGLM_Arg_Unpack_2O(args, "lessThan", arg1, arg2);
//	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
//		glm::vec<2, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
//		glm::vec<2, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
//		glm::vec<2, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
//		glm::vec<2, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
//		glm::vec<2, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
//		glm::vec<2, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
//		glm::vec<2, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
//		glm::vec<2, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
//		glm::vec<2, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
//		glm::vec<2, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
//		glm::vec<2, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
//		glm::vec<3, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
//		glm::vec<3, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
//		glm::vec<3, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
//		glm::vec<3, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
//		glm::vec<3, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
//		glm::vec<3, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
//		glm::vec<3, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
//		glm::vec<3, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
//		glm::vec<3, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
//		glm::vec<3, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
//		glm::vec<3, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
//		glm::vec<4, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
//		glm::vec<4, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
//		glm::vec<4, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
//		glm::vec<4, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
//		glm::vec<4, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
//		glm::vec<4, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
//		glm::vec<4, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
//		glm::vec<4, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
//		glm::vec<4, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
//		glm::vec<4, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
//		glm::vec<4, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThan(o, o2));
//	}
//	PyGLM_TYPEERROR_2O("invalid argument type(s) for lessThan(): ", arg1, arg2);
//	return NULL;
//}
//
//static PyObject*
//lessThanEqual(PyObject*, PyObject* args) {
//	PyObject *arg1, *arg2;
//	PyGLM_Arg_Unpack_2O(args, "lessThanEqual", arg1, arg2);
//	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
//		glm::vec<2, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
//		glm::vec<2, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
//		glm::vec<2, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
//		glm::vec<2, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
//		glm::vec<2, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
//		glm::vec<2, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
//		glm::vec<2, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
//		glm::vec<2, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
//		glm::vec<2, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
//		glm::vec<2, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
//		glm::vec<2, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
//		glm::vec<3, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
//		glm::vec<3, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
//		glm::vec<3, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
//		glm::vec<3, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
//		glm::vec<3, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
//		glm::vec<3, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
//		glm::vec<3, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
//		glm::vec<3, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
//		glm::vec<3, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
//		glm::vec<3, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
//		glm::vec<3, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
//		glm::vec<4, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
//		glm::vec<4, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
//		glm::vec<4, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
//		glm::vec<4, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
//		glm::vec<4, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
//		glm::vec<4, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
//		glm::vec<4, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
//		glm::vec<4, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
//		glm::vec<4, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
//		glm::vec<4, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
//		glm::vec<4, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::lessThanEqual(o, o2));
//	}
//	PyGLM_TYPEERROR_2O("invalid argument type(s) for lessThanEqual(): ", arg1, arg2);
//	return NULL;
//}
//
//static PyObject*
//greaterThan(PyObject*, PyObject* args) {
//	PyObject *arg1, *arg2;
//	PyGLM_Arg_Unpack_2O(args, "greaterThan", arg1, arg2);
//	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
//		glm::vec<2, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
//		glm::vec<2, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
//		glm::vec<2, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
//		glm::vec<2, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
//		glm::vec<2, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
//		glm::vec<2, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
//		glm::vec<2, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
//		glm::vec<2, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
//		glm::vec<2, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
//		glm::vec<2, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
//		glm::vec<2, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
//		glm::vec<3, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
//		glm::vec<3, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
//		glm::vec<3, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
//		glm::vec<3, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
//		glm::vec<3, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
//		glm::vec<3, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
//		glm::vec<3, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
//		glm::vec<3, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
//		glm::vec<3, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
//		glm::vec<3, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
//		glm::vec<3, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
//		glm::vec<4, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
//		glm::vec<4, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
//		glm::vec<4, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
//		glm::vec<4, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
//		glm::vec<4, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
//		glm::vec<4, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
//		glm::vec<4, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
//		glm::vec<4, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
//		glm::vec<4, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
//		glm::vec<4, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
//		glm::vec<4, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThan(o, o2));
//	}
//	PyGLM_TYPEERROR_2O("invalid argument type(s) for greaterThan(): ", arg1, arg2);
//	return NULL;
//}
//
//static PyObject*
//greaterThanEqual(PyObject*, PyObject* args) {
//	PyObject *arg1, *arg2;
//	PyGLM_Arg_Unpack_2O(args, "greaterThanEqual", arg1, arg2);
//	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
//		glm::vec<2, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
//		glm::vec<2, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
//		glm::vec<2, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
//		glm::vec<2, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
//		glm::vec<2, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
//		glm::vec<2, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
//		glm::vec<2, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
//		glm::vec<2, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
//		glm::vec<2, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
//		glm::vec<2, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
//		glm::vec<2, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
//		glm::vec<3, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
//		glm::vec<3, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
//		glm::vec<3, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
//		glm::vec<3, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
//		glm::vec<3, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
//		glm::vec<3, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
//		glm::vec<3, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
//		glm::vec<3, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
//		glm::vec<3, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
//		glm::vec<3, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
//		glm::vec<3, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
//		glm::vec<4, float> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
//		glm::vec<4, double> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
//		glm::vec<4, int> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
//		glm::vec<4, glm::uint> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
//		glm::vec<4, glm::i64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
//		glm::vec<4, glm::u64> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
//		glm::vec<4, glm::i16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
//		glm::vec<4, glm::u16> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
//		glm::vec<4, glm::i8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
//		glm::vec<4, glm::u8> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
//		glm::vec<4, bool> o, o2;
//		unpack_vec(arg1, o);
//		unpack_vec(arg2, o2);
//		return pack(glm::greaterThanEqual(o, o2));
//	}
//	PyGLM_TYPEERROR_2O("invalid argument type(s) for greaterThanEqual(): ", arg1, arg2);
//	return NULL;
//}

static PyObject*
any(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, bool, arg)) {
		if (glm::any(unpack_vec<1, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(2, bool, arg)) {
		if (glm::any(unpack_vec<2, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		if (glm::any(unpack_vec<3, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		if (glm::any(unpack_vec<4, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	PyGLM_TYPEERROR_O("invalid argument type for any(): ", arg);
	return NULL;
}

static PyObject*
all(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, bool, arg)) {
		if (glm::all(unpack_vec<1, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(2, bool, arg)) {
		if (glm::all(unpack_vec<2, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		if (glm::all(unpack_vec<3, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		if (glm::all(unpack_vec<4, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	PyGLM_TYPEERROR_O("invalid argument type for all(): ", arg);
	return NULL;
}

static PyObject*
not_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<1, bool>(arg)));
	}
	if (PyGLM_Vec_Check(2, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<2, bool>(arg)));
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<3, bool>(arg)));
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<4, bool>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for not_(): ", arg);
	return NULL;
}

static PyObject*
pow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "pow", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
		return pack(glm::pow(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
		return pack(glm::pow(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		return pack(glm::pow(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		return pack(glm::pow(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		return pack(glm::pow(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		return pack(glm::pow(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		return pack(glm::pow(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		return pack(glm::pow(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
	}

	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(unpack_qua<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(unpack_qua<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for pow(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(exp)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(log)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(exp2)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(log2)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(sqrt)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(inversesqrt)

static PyObject*
iround_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		double d = PyGLM_Number_FromPyObject<double>(arg);
		PyGLM_ASSERT((0.0 <= d), "x has to be greater than or equal to 0");
		return pack(glm::iround(d));
	}
	if (PyGLM_Vec_Check(1, float, arg)) {
		glm::vec<1, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(1, double, arg)) {
		glm::vec<1, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::iround(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for iround(): ", arg);
	return NULL;
}

static PyObject*
uround_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		double d = PyGLM_Number_FromPyObject<double>(arg);
		PyGLM_ASSERT((0.0 <= d), "x has to be greater than or equal to 0");
		return pack(glm::uround(d));
	}
	if (PyGLM_Vec_Check(1, float, arg)) {
		glm::vec<1, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(1, double, arg)) {
		glm::vec<1, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, float>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, double>(0), o))), "x has to be greater than or equal to 0");
		return pack(glm::uround(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for uround(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tfF(abs)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(sign)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(floor)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(trunc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(round)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(roundEven)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(ceil)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(fract)

PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(mod)
//PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(min)

static PyObject*
min_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "min", 2, 4, &arg1, &arg2, &arg3, &arg4)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			return pack(glm::min(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			return pack(glm::min(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			return pack(glm::min(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			return pack(glm::min(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			return pack(glm::min(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			return pack(glm::min(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			return pack(glm::min(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			return pack(glm::min(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::min(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
	}
	else {
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				return pack(glm::min(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
				return pack(glm::min(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
				return pack(glm::min(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
				return pack(glm::min(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
				return pack(glm::min(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
				return pack(glm::min(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
				return pack(glm::min(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
				return pack(glm::min(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
				return pack(glm::min(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));
			}
		}
		else {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
				return pack(glm::min(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3), PyGLM_Number_FromPyObject<double>(arg4)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3) && PyGLM_Vec_Check(1, float, arg4)) {
				return pack(glm::min(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3), unpack_vec<1, float>(arg4)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3) && PyGLM_Vec_Check(1, double, arg4)) {
				return pack(glm::min(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3), unpack_vec<1, double>(arg4)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3) && PyGLM_Vec_Check(2, float, arg4)) {
				return pack(glm::min(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3), unpack_vec<2, float>(arg4)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3) && PyGLM_Vec_Check(2, double, arg4)) {
				return pack(glm::min(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3), unpack_vec<2, double>(arg4)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3) && PyGLM_Vec_Check(3, float, arg4)) {
				return pack(glm::min(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3), unpack_vec<3, float>(arg4)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3) && PyGLM_Vec_Check(3, double, arg4)) {
				return pack(glm::min(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3), unpack_vec<3, double>(arg4)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {
				return pack(glm::min(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3), unpack_vec<4, float>(arg4)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {
				return pack(glm::min(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3), unpack_vec<4, double>(arg4)));
			}
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for min()");
	return NULL;
}

static PyObject*
max_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "max", 2, 4, &arg1, &arg2, &arg3, &arg4)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			return pack(glm::max(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			return pack(glm::max(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			return pack(glm::max(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			return pack(glm::max(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			return pack(glm::max(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			return pack(glm::max(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			return pack(glm::max(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			return pack(glm::max(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::max(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
	}
	else {
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				return pack(glm::max(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
				return pack(glm::max(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
				return pack(glm::max(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
				return pack(glm::max(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
				return pack(glm::max(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
				return pack(glm::max(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
				return pack(glm::max(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
				return pack(glm::max(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
				return pack(glm::max(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));
			}
		}
		else {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
				return pack(glm::max(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3), PyGLM_Number_FromPyObject<double>(arg4)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3) && PyGLM_Vec_Check(1, float, arg4)) {
				return pack(glm::max(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3), unpack_vec<1, float>(arg4)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3) && PyGLM_Vec_Check(1, double, arg4)) {
				return pack(glm::max(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3), unpack_vec<1, double>(arg4)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3) && PyGLM_Vec_Check(2, float, arg4)) {
				return pack(glm::max(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3), unpack_vec<2, float>(arg4)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3) && PyGLM_Vec_Check(2, double, arg4)) {
				return pack(glm::max(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3), unpack_vec<2, double>(arg4)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3) && PyGLM_Vec_Check(3, float, arg4)) {
				return pack(glm::max(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3), unpack_vec<3, float>(arg4)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3) && PyGLM_Vec_Check(3, double, arg4)) {
				return pack(glm::max(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3), unpack_vec<3, double>(arg4)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {
				return pack(glm::max(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3), unpack_vec<4, float>(arg4)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {
				return pack(glm::max(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3), unpack_vec<4, double>(arg4)));
			}
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for max()");
	return NULL;
}

static PyObject*
fmin_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "fmin", 2, 4, &arg1, &arg2, &arg3, &arg4)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			return pack(glm::fmin(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			return pack(glm::fmin(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			return pack(glm::fmin(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			return pack(glm::fmin(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			return pack(glm::fmin(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			return pack(glm::fmin(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			return pack(glm::fmin(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			return pack(glm::fmin(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmin(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
	}
	else {
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				return pack(glm::fmin(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
				return pack(glm::fmin(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
				return pack(glm::fmin(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
				return pack(glm::fmin(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
				return pack(glm::fmin(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
				return pack(glm::fmin(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
				return pack(glm::fmin(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
				return pack(glm::fmin(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
				return pack(glm::fmin(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));
			}
		}
		else {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
				return pack(glm::fmin(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3), PyGLM_Number_FromPyObject<double>(arg4)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3) && PyGLM_Vec_Check(1, float, arg4)) {
				return pack(glm::fmin(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3), unpack_vec<1, float>(arg4)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3) && PyGLM_Vec_Check(1, double, arg4)) {
				return pack(glm::fmin(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3), unpack_vec<1, double>(arg4)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3) && PyGLM_Vec_Check(2, float, arg4)) {
				return pack(glm::fmin(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3), unpack_vec<2, float>(arg4)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3) && PyGLM_Vec_Check(2, double, arg4)) {
				return pack(glm::fmin(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3), unpack_vec<2, double>(arg4)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3) && PyGLM_Vec_Check(3, float, arg4)) {
				return pack(glm::fmin(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3), unpack_vec<3, float>(arg4)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3) && PyGLM_Vec_Check(3, double, arg4)) {
				return pack(glm::fmin(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3), unpack_vec<3, double>(arg4)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {
				return pack(glm::fmin(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3), unpack_vec<4, float>(arg4)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {
				return pack(glm::fmin(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3), unpack_vec<4, double>(arg4)));
			}
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for fmin()");
	return NULL;
}

static PyObject*
fmax_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "fmax", 2, 4, &arg1, &arg2, &arg3, &arg4)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			return pack(glm::fmax(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			return pack(glm::fmax(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			return pack(glm::fmax(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			return pack(glm::fmax(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			return pack(glm::fmax(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			return pack(glm::fmax(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			return pack(glm::fmax(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			return pack(glm::fmax(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::fmax(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
	}
	else {
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				return pack(glm::fmax(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
				return pack(glm::fmax(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
				return pack(glm::fmax(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
				return pack(glm::fmax(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
				return pack(glm::fmax(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
				return pack(glm::fmax(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
				return pack(glm::fmax(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
				return pack(glm::fmax(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
				return pack(glm::fmax(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));
			}
		}
		else {
			if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
				return pack(glm::fmax(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3), PyGLM_Number_FromPyObject<double>(arg4)));
			}
			if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3) && PyGLM_Vec_Check(1, float, arg4)) {
				return pack(glm::fmax(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3), unpack_vec<1, float>(arg4)));
			}
			if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3) && PyGLM_Vec_Check(1, double, arg4)) {
				return pack(glm::fmax(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3), unpack_vec<1, double>(arg4)));
			}
			if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3) && PyGLM_Vec_Check(2, float, arg4)) {
				return pack(glm::fmax(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3), unpack_vec<2, float>(arg4)));
			}
			if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3) && PyGLM_Vec_Check(2, double, arg4)) {
				return pack(glm::fmax(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3), unpack_vec<2, double>(arg4)));
			}
			if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3) && PyGLM_Vec_Check(3, float, arg4)) {
				return pack(glm::fmax(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3), unpack_vec<3, float>(arg4)));
			}
			if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3) && PyGLM_Vec_Check(3, double, arg4)) {
				return pack(glm::fmax(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3), unpack_vec<3, double>(arg4)));
			}
			if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {
				return pack(glm::fmax(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3), unpack_vec<4, float>(arg4)));
			}
			if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {
				return pack(glm::fmax(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3), unpack_vec<4, double>(arg4)));
			}
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for fmax()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NNN_VVV_VNN__tfF(clamp)

static PyObject*
mix_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "mix", arg1, arg2, arg3);
	
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyBool_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::mix(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<bool>(arg3)));
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::mix(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2) && PyGLM_Number_Check(arg3)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack_qua(glm::mix(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2) && PyGLM_Number_Check(arg3)) {
		glm::dquat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack_qua(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	}

	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
		glm::vec<1, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
		glm::vec<1, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
		glm::vec<1, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {
		glm::vec<1, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {
		glm::vec<1, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {
		glm::vec<1, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {
		glm::vec<1, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {
		glm::vec<1, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {
		glm::vec<1, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {
		glm::vec<1, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {
		glm::vec<1, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, bool, arg3)) {
			glm::bvec1 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	
	if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		glm::mat<2, 2, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		glm::mat<2, 2, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		glm::mat<2, 2, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		glm::mat<2, 2, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
	//	glm::mat<2, 3, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
	//	glm::mat<2, 3, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
	//	glm::mat<2, 3, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
	//	glm::mat<2, 3, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
	//	glm::mat<2, 4, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
	//	glm::mat<2, 4, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
	//	glm::mat<2, 4, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
	//	glm::mat<2, 4, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
	//	glm::mat<3, 2, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
	//	glm::mat<3, 2, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
	//	glm::mat<3, 2, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
	//	glm::mat<3, 2, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		glm::mat<3, 3, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		glm::mat<3, 3, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		glm::mat<3, 3, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		glm::mat<3, 3, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
	//	glm::mat<3, 4, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
	//	glm::mat<3, 4, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
	//	glm::mat<3, 4, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
	//	glm::mat<3, 4, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
	//	glm::mat<4, 2, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
	//	glm::mat<4, 2, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
	//	glm::mat<4, 2, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
	//	glm::mat<4, 2, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
	//	glm::mat<4, 3, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
	//	glm::mat<4, 3, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
	//	glm::mat<4, 3, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
	//	glm::mat<4, 3, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		glm::mat<4, 4, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		glm::mat<4, 4, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		glm::mat<4, 4, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		glm::mat<4, 4, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}

	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mix()"); 
	return NULL;
}

static PyObject*
step_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "step", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
		return PyGLM_PyObject_FromNumber(glm::step(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	if (PyGLM_Vec_Check(1, float, arg2)) {
		glm::vec<1, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, float, arg1)) {
			glm::vec<1, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, double, arg2)) {
		glm::vec<1, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, double, arg1)) {
			glm::vec<1, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, int, arg2)) {
		glm::vec<1, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, int, arg1)) {
			glm::vec<1, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg2)) {
		glm::vec<1, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::uint, arg1)) {
			glm::vec<1, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i64, arg2)) {
		glm::vec<1, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::i64, arg1)) {
			glm::vec<1, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u64, arg2)) {
		glm::vec<1, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::u64, arg1)) {
			glm::vec<1, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i16, arg2)) {
		glm::vec<1, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::i16, arg1)) {
			glm::vec<1, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u16, arg2)) {
		glm::vec<1, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::u16, arg1)) {
			glm::vec<1, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::i8, arg2)) {
		glm::vec<1, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::i8, arg1)) {
			glm::vec<1, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, glm::u8, arg2)) {
		glm::vec<1, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, glm::u8, arg1)) {
			glm::vec<1, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(1, bool, arg2)) {
		glm::vec<1, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(1, bool, arg1)) {
			glm::vec<1, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			glm::vec<2, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			glm::vec<2, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1)) {
			glm::vec<2, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1)) {
			glm::vec<2, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1)) {
			glm::vec<2, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1)) {
			glm::vec<2, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1)) {
			glm::vec<2, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1)) {
			glm::vec<2, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1)) {
			glm::vec<2, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1)) {
			glm::vec<2, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1)) {
			glm::vec<2, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			glm::vec<3, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			glm::vec<3, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1)) {
			glm::vec<3, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1)) {
			glm::vec<3, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1)) {
			glm::vec<3, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1)) {
			glm::vec<3, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1)) {
			glm::vec<3, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1)) {
			glm::vec<3, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1)) {
			glm::vec<3, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1)) {
			glm::vec<3, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1)) {
			glm::vec<3, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			glm::vec<4, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			glm::vec<4, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1)) {
			glm::vec<4, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1)) {
			glm::vec<4, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1)) {
			glm::vec<4, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1)) {
			glm::vec<4, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1)) {
			glm::vec<4, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1)) {
			glm::vec<4, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1)) {
			glm::vec<4, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1)) {
			glm::vec<4, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1)) {
			glm::vec<4, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for step(): ", arg1, arg2);
	return NULL;
}

static PyObject*
smoothstep_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "smoothstep", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
		return PyGLM_PyObject_FromNumber(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	if (PyGLM_Vec_Check(1, float, arg3)) {
		glm::vec<1, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(1, double, arg3)) {
		glm::vec<1, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for smoothstep()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(isnan)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(isinf)

static PyObject*
fma_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "fma", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2), PyGLM_Number_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::fma(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for fma()");
	return NULL;
}

static PyObject*
frexp_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "frexp", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyLong_Check(arg2)) {
		if (PyGLM_SHOW_WARNINGS & PyGLM_FREXP_WARNING) PyErr_WarnEx(PyExc_UserWarning, "This function will return this pair: (m, e), which differs from glm behaviour. You can silence this warning by calling glm.silence(1)", 1);
		int e = (int)PyLong_AS_LONG(arg2);
		double m = glm::frexp(PyGLM_Number_FromPyObject<double>(arg1), e);
		return Py_BuildValue("(d, i)", m, e);
	}
	if (PyGLM_Vec_Check(1, float, arg1) && PyObject_TypeCheck(arg2, &hivec1Type)) {
		glm::vec<1, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<1, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyObject_TypeCheck(arg2, &hivec1Type)) {
		glm::vec<1, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<1, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for frexp(): ", arg1, arg2);
	return NULL;
}

static PyObject*
ldexp_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "ldexp", arg1, arg2);
	if (PyGLM_Vec_Check(1, float, arg1) && PyObject_TypeCheck(arg2, &hivec1Type)) {
		glm::vec<1, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<1, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyObject_TypeCheck(arg2, &hivec1Type)) {
		glm::vec<1, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<1, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for ldexp(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(length)

PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(distance)
PyGLM_MAKE_GLM_FUNC_NN_VV_QQ__tfF(dot)

static PyObject*
cross_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "cross", arg1, arg2);

	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for cross(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V_Q__tfF(normalize)

PyGLM_MAKE_GLM_FUNC_NNN_VVV__tfF(faceforward)

PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(reflect)

PyGLM_MAKE_GLM_FUNC_NNN_VVN__tfF(refract)

static PyObject*
outerProduct_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "outerProduct", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec2 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec2 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec2 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec3 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec3 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec3 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec4 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec4 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec4 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec2 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec2 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec2 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec3 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec3 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec3 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec4 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec4 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec4 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for outerProduct(): ", arg1, arg2);
	return NULL;
}

static PyObject*
affineInverse_(PyObject*, PyObject* arg) {
	if (PyGLM_Mat_Check(3, 3, float, arg)) {
		return pack(glm::affineInverse(unpack_mat<3, 3, float>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg)) {
		return pack(glm::affineInverse(unpack_mat<3, 3, double>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg)) {
		return pack(glm::affineInverse(unpack_mat<4, 4, float>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg)) {
		return pack(glm::affineInverse(unpack_mat<4, 4, double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for affineInverse(): ", arg);
	return NULL;
}

static PyObject*
inverseTranspose_(PyObject*, PyObject* arg) {
	if (PyGLM_Mat_Check(2, 2, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<2, 2, float>(arg)));
	}
	if (PyGLM_Mat_Check(2, 2, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<2, 2, double>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<3, 3, float>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<3, 3, double>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<4, 4, float>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<4, 4, double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for inverseTranspose(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_MM__tfF(matrixCompMult)
PyGLM_MAKE_GLM_FUNC_M__tfF(transpose)
PyGLM_MAKE_GLM_FUNC_S__tfF(determinant)
PyGLM_MAKE_GLM_FUNC_S_Q__tfF(inverse)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(radians)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(degrees)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sin)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cos)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(tan)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asin)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acos)
static PyObject* 
atan_(PyObject*, PyObject* args) {
	PyObject* arg1 = NULL, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "atan", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for atan()");
		return NULL;
	}

	if (arg2 != NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::atan(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::dvec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for atan(): ", arg1, arg2);
		return NULL;
	}

	if (PyGLM_Number_Check(arg1)) {
		return pack(glm::atan(PyGLM_Number_FromPyObject<double>(arg1)));
	}
	if (PyGLM_Vec_Check(1, float, arg1)) {
		glm::vec1 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(1, double, arg1)) {
		glm::dvec1 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for atan(): ", arg1);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sinh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cosh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(tanh)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asinh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acosh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(atanh)

static PyObject*
convertLinearToSRGB_(PyObject*, PyObject* args) {
	PyObject* arg1;
	PyObject* arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "convertLinearToSRGB", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertLinearToSRGB()");
		return NULL;
	}
	if (PyGLM_Vec_Check(1, float, arg1)) {
		glm::vec1 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(1, double, arg1)) {
		glm::dvec1 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertLinearToSRGB()");
	return NULL;
}

static PyObject*
convertSRGBToLinear_(PyObject*, PyObject* args) {
	PyObject* arg1;
	PyObject* arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "convertSRGBToLinear", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertSRGBToLinear()");
		return NULL;
	}
	if (PyGLM_Vec_Check(1, float, arg1)) {
		glm::vec1 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(1, double, arg1)) {
		glm::dvec1 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertSRGBToLinear()");
	return NULL;
}

//static PyObject* epsilon_(PyObject*, PyObject* narg) { return PyFloat_FromDouble(glm::epsilon<double>()); }

PyGLM_MAKE_GLM_FUNC__rF(epsilon)
PyGLM_MAKE_GLM_FUNC__rF(zero)
PyGLM_MAKE_GLM_FUNC__rF(one)
PyGLM_MAKE_GLM_FUNC__rF(pi)
PyGLM_MAKE_GLM_FUNC__rF(two_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_pi)
PyGLM_MAKE_GLM_FUNC__rF(half_pi)
PyGLM_MAKE_GLM_FUNC__rF(three_over_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(quarter_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(two_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(four_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(two_over_root_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_root_two)
PyGLM_MAKE_GLM_FUNC__rF(root_half_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_ln_four)
PyGLM_MAKE_GLM_FUNC__rF(e)
PyGLM_MAKE_GLM_FUNC__rF(euler)
PyGLM_MAKE_GLM_FUNC__rF(root_two)
PyGLM_MAKE_GLM_FUNC__rF(root_three)
PyGLM_MAKE_GLM_FUNC__rF(root_five)
PyGLM_MAKE_GLM_FUNC__rF(ln_two)
PyGLM_MAKE_GLM_FUNC__rF(ln_ten)
PyGLM_MAKE_GLM_FUNC__rF(ln_ln_two)
PyGLM_MAKE_GLM_FUNC__rF(third)
PyGLM_MAKE_GLM_FUNC__rF(two_thirds)
PyGLM_MAKE_GLM_FUNC__rF(golden_ratio)

static PyObject* 
epsilonEqual_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "epsilonEqual", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2)) {
			if (glm::epsilonEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3))) {
				Py_RETURN_TRUE;
			}
			else {
				Py_RETURN_FALSE;
			}
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::dvec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::quat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::dquat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
	}
	else {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for epsilonEqual()");
	return NULL;
}

static PyObject*
epsilonNotEqual_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "epsilonNotEqual", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2)) {
			if (glm::epsilonNotEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3))) {
				Py_RETURN_TRUE;
			}
			else {
				Py_RETURN_FALSE;
			}
		}
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::dvec1 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::quat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::dquat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
	}
	else {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
			glm::vec1 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
			glm::dvec1 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for epsilonNotEqual()");
	return NULL;
}

static PyObject*
identity_(PyObject*, PyObject* arg) {
	if (!PyType_Check(arg)) {
		PyGLM_TYPEERROR_O("identity() requires a PyGLM matrix type as it's argument, not ", arg);
		return NULL;
	}
	if (arg == (PyObject*)&hfmat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, double> >());
	}
	if (arg == (PyObject*)&himat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, int> >());
	}
	if (arg == (PyObject*)&humat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, double> >());
	}
	if (arg == (PyObject*)&himat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, int> >());
	}
	if (arg == (PyObject*)&humat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, double> >());
	}
	if (arg == (PyObject*)&himat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, int> >());
	}
	if (arg == (PyObject*)&humat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, double> >());
	}
	if (arg == (PyObject*)&himat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, int> >());
	}
	if (arg == (PyObject*)&humat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, double> >());
	}
	if (arg == (PyObject*)&himat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, int> >());
	}
	if (arg == (PyObject*)&humat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, double> >());
	}
	if (arg == (PyObject*)&himat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, int> >());
	}
	if (arg == (PyObject*)&humat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, double> >());
	}
	if (arg == (PyObject*)&himat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, int> >());
	}
	if (arg == (PyObject*)&humat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, double> >());
	}
	if (arg == (PyObject*)&himat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, int> >());
	}
	if (arg == (PyObject*)&humat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, double> >());
	}
	if (arg == (PyObject*)&himat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, int> >());
	}
	if (arg == (PyObject*)&humat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, glm::uint> >());
	}
	PyErr_Format(PyExc_TypeError, "identity() requires a PyGLM matrix type as it's argument, not '%s'", ((PyTypeObject*)arg)->tp_name);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_M4V3__tfF(translate)

static PyObject*
rotate_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "rotate", arg1, arg2, arg3);
	if (PyGLM_Mat_Check(4, 4, float, arg1)) {
		glm::mat4x4 m;
		glm::vec3 axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack(glm::rotate(m, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1)) {
		glm::dmat4x4 m;
		glm::dvec3 axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack(glm::rotate(m, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	if (PyGLM_Qua_Check(float, arg1)) {
		glm::quat q;
		glm::vec3 axis;
		if (!unpack_qua(arg1, q) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack_qua(glm::rotate(q, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Qua_Check(double, arg1)) {
		glm::dquat q;
		glm::dvec3 axis;
		if (!unpack_qua(arg1, q) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack_qua(glm::rotate(q, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
	return NULL;
}

static PyObject*
rotate_slow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "rotate_slow", arg1, arg2, arg3);
	if (PyGLM_Mat_Check(4, 4, float, arg1)) {
		glm::mat<4, 4, float> m;
		glm::vec<3, float> axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
			return NULL;
		}
		return pack(glm::rotate_slow(m, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1)) {
		glm::mat<4, 4, double> m;
		glm::vec<3, double> axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
			return NULL;
		}
		return pack(glm::rotate_slow(m, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_M4V3__tfF(scale)
PyGLM_MAKE_GLM_FUNC_M4V3__tfF(scale_slow)

static PyObject*
ortho_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5 = NULL, *arg6 = NULL;
	if (!PyArg_UnpackTuple(args, "ortho", 4, 6, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for ortho()");
		return NULL;
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
		if (arg5 != NULL && arg6 != NULL && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) return pack(glm::ortho(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5), PyGLM_Number_FromPyObject<float>(arg6)));
		if (arg5 == NULL && arg6 == NULL) return pack(glm::ortho(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for ortho()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoNO)

PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustum)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumNO)

PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspective)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveNO)

static PyObject*
perspectiveFov_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFov", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)&& PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFov() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFov(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFov()");
	return NULL;
}
static PyObject*
perspectiveFovLH_ZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH_ZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH_ZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH_ZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH_ZO()");
	return NULL;
}
static PyObject*
perspectiveFovLH_NO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH_NO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH_NO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH_NO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH_NO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_ZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH_ZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH_ZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH_ZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH_ZO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_NO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH_NO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH_NO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH_NO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH_NO()");
	return NULL;
}
static PyObject*
perspectiveFovLH_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH()");
	return NULL;
}
static PyObject*
perspectiveFovZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovZO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH()");
	return NULL;
}
static PyObject*
perspectiveFovNO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovNO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovNO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovNO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovNO()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspective)
PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspectiveLH)
PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspectiveRH)

static PyObject*
tweakedInfinitePerspective_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "tweakedInfinitePerspective", 3, 4, &arg1, &arg2, &arg3, &arg4)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for tweakedInfinitePerspective()");
		return NULL;
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
		if (arg4 != NULL && PyGLM_Number_Check(arg4)) {
			return pack(glm::tweakedInfinitePerspective(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));
		}
		return pack(glm::tweakedInfinitePerspective(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for tweakedInfinitePerspective()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(project)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(projectZO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(projectNO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProject)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProjectZO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProjectNO)

static PyObject*
pickMatrix_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "pickMatrix", arg1, arg2, arg3);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec2 o, o2;
		glm::vec4 o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		if (!(o.x > 0.0f && o.y > 0.0f)) {
			PyErr_SetString(PyExc_ValueError, "delta has to be greater than 0 for pickMatrix()");
			return NULL;
		}
		return pack(glm::pickMatrix(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::dvec2 o, o2;
		glm::dvec4 o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		if (!(o.x > 0.0 && o.y > 0.0)) {
			PyErr_SetString(PyExc_ValueError, "delta has to be greater than 0 for pickMatrix()");
			return NULL;
		}
		return pack(glm::pickMatrix(o, o2, o3));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for pickMatrix()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAt)
PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAtLH)
PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAtRH)

PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAt)
PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAtLH)
PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAtRH)

static PyObject*
lerp_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "lerp", arg1, arg2, arg3);
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2) && PyGLM_Number_Check(arg3)) {
		float a = PyGLM_Number_FromPyObject<float>(arg3);
		PyGLM_ASSERT((a >= 0.0f && a <= 1.0f), "Lerp is only defined in [0, 1]")
		return pack(glm::lerp(unpack_qua<float>(arg1), unpack_qua<float>(arg2), a));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2) && PyGLM_Number_Check(arg3)) {
		double a = PyGLM_Number_FromPyObject<double>(arg3);
		PyGLM_ASSERT((a >= 0.0 && a <= 1.0), "Lerp is only defined in [0, 1]")
		return pack(glm::lerp(unpack_qua<double>(arg1), unpack_qua<double>(arg2), a));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for lerp()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_QQN__tfF(slerp)

PyGLM_MAKE_GLM_FUNC_Q(conjugate)

PyGLM_MAKE_GLM_FUNC_Q(eulerAngles)

PyGLM_MAKE_GLM_FUNC_Q(roll)
PyGLM_MAKE_GLM_FUNC_Q(pitch)
PyGLM_MAKE_GLM_FUNC_Q(yaw)

PyGLM_MAKE_GLM_FUNC_Q(mat3_cast)

PyGLM_MAKE_GLM_FUNC_Q(mat4_cast)

PyGLM_MAKE_GLM_FUNC_M3_M4__tfF(quat_cast)

PyGLM_MAKE_GLM_FUNC_Q(angle)
PyGLM_MAKE_GLM_FUNC_Q(axis)

static PyObject*
angleAxis_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "angleAxis", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		return pack(glm::angleAxis(PyGLM_Number_FromPyObject<float>(arg1), unpack_vec<3, float>(arg2)));
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		return pack(glm::angleAxis(PyGLM_Number_FromPyObject<double>(arg1), unpack_vec<3, double>(arg2)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for angleAxis()");
	return NULL;
}

static PyObject*
row_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "row", 2, 3, &arg1, &arg2, &arg3) || !PyGLM_Number_Check(arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for row()");
		return NULL;
	}
	glm::length_t index = PyGLM_Number_FromPyObject<glm::length_t>(arg2);
	if (index < 0) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	if (arg3 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec<2, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec<3, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec<4, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::vec<2, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::vec<3, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::vec<4, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, int, arg3)) {
			glm::vec<2, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, int, arg3)) {
			glm::vec<3, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, int, arg3)) {
			glm::vec<4, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg3)) {
			glm::vec<2, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg3)) {
			glm::vec<3, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg3)) {
			glm::vec<4, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg3)) {
			glm::vec<2, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg3)) {
			glm::vec<3, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg3)) {
			glm::vec<4, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg3)) {
			glm::vec<2, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg3)) {
			glm::vec<3, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg3)) {
			glm::vec<4, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg3)) {
			glm::vec<2, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg3)) {
			glm::vec<3, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg3)) {
			glm::vec<4, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg3)) {
			glm::vec<2, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg3)) {
			glm::vec<3, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg3)) {
			glm::vec<4, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg3)) {
			glm::vec<2, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg3)) {
			glm::vec<3, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg3)) {
			glm::vec<4, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg3)) {
			glm::vec<2, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg3)) {
			glm::vec<3, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg3)) {
			glm::vec<4, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::vec<2, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::vec<3, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::vec<4, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}

	}
	else {
		if (PyGLM_Mat_Check(2, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for row()");
	return NULL;
}

static PyObject*
column_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "column", 2, 3, &arg1, &arg2, &arg3) || !PyGLM_Number_Check(arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for column()");
		return NULL;
	}
	glm::length_t index = PyGLM_Number_FromPyObject<glm::length_t>(arg2);
	if (index < 0) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	if (arg3 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec<2, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec<3, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec<4, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::vec<2, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::vec<3, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::vec<4, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, int, arg3)) {
			glm::vec<2, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, int, arg3)) {
			glm::vec<3, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, int, arg3)) {
			glm::vec<4, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg3)) {
			glm::vec<2, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg3)) {
			glm::vec<3, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg3)) {
			glm::vec<4, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
	}
	else {
		if (PyGLM_Mat_Check(2, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for column()");
	return NULL;
}

static PyObject*
perlin_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "perlin", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perlin()");
		return NULL;
	}
	if (arg2 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
	}
	else {
		if (PyGLM_Vec_Check(2, float, arg1)) {
			glm::vec<2, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			glm::vec<3, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			glm::vec<4, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			glm::vec<2, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			glm::vec<3, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			glm::vec<4, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perlin()");
	return NULL;
}

static PyObject* simplex_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) { 
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	} 
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for simplex(): ", arg); 
	return NULL; 
}

PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(linearRand)
PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(gaussRand)

static PyObject*
circularRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "circularRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::circularRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for circularRand(): ", arg);
	return NULL;
}

static PyObject*
sphericalRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "sphericalRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::sphericalRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for sphericalRand(): ", arg);
	return NULL;
}

static PyObject*
diskRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "diskRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::diskRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for diskRand(): ", arg);
	return NULL;
}

static PyObject*
ballRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "ballRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::ballRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for ballRand(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tiqsu(isPowerOfTwo);
PyGLM_MAKE_GLM_FUNC_N_V__tiqsu(ceilPowerOfTwo);
PyGLM_MAKE_GLM_FUNC_N_V__tiqsu(floorPowerOfTwo);
PyGLM_MAKE_GLM_FUNC_N_V__tiqsu(roundPowerOfTwo);
//PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tiqsu(isMultiple);
PyGLM_MAKE_GLM_FUNC_NN_VV__tiqsu(ceilMultiple);
PyGLM_MAKE_GLM_FUNC_NN_VV__tiqsu(floorMultiple);
PyGLM_MAKE_GLM_FUNC_NN_VV__tiqsu(roundMultiple);

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sec)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(csc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cot)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asec)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acsc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acot)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sech)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(csch)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(coth)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asech)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acsch)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acoth)

static PyObject*
sizeof_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, float, arg) || arg == (PyObject*)&hfvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, float>));
	}
	if (PyGLM_Vec_Check(1, double, arg) || arg == (PyObject*)&hdvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, double>));
	}
	if (PyGLM_Vec_Check(1, int, arg) || arg == (PyObject*)&hivec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, int>));
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg) || arg == (PyObject*)&huvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::uint>));
	}
	if (PyGLM_Vec_Check(1, glm::i64, arg) || arg == (PyObject*)&hi64vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i64>));
	}
	if (PyGLM_Vec_Check(1, glm::u64, arg) || arg == (PyObject*)&hu64vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u64>));
	}
	if (PyGLM_Vec_Check(1, glm::i16, arg) || arg == (PyObject*)&hi16vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i16>));
	}
	if (PyGLM_Vec_Check(1, glm::u16, arg) || arg == (PyObject*)&hu16vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u16>));
	}
	if (PyGLM_Vec_Check(1, glm::i8, arg) || arg == (PyObject*)&hi8vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i8>));
	}
	if (PyGLM_Vec_Check(1, glm::u8, arg) || arg == (PyObject*)&hu8vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u8>));
	}
	if (PyGLM_Vec_Check(1, bool, arg) || arg == (PyObject*)&hbvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, bool>));
	}
	if (PyGLM_Vec_Check(2, float, arg) || arg == (PyObject*)&hfvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, float>));
	}
	if (PyGLM_Vec_Check(2, double, arg) || arg == (PyObject*)&hdvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, double>));
	}
	if (PyGLM_Vec_Check(2, int, arg) || arg == (PyObject*)&hivec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, int>));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg) || arg == (PyObject*)&huvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::uint>));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg) || arg == (PyObject*)&hi64vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i64>));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg) || arg == (PyObject*)&hu64vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u64>));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg) || arg == (PyObject*)&hi16vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i16>));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg) || arg == (PyObject*)&hu16vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u16>));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg) || arg == (PyObject*)&hi8vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i8>));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg) || arg == (PyObject*)&hu8vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u8>));
	}
	if (PyGLM_Vec_Check(2, bool, arg) || arg == (PyObject*)&hbvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, bool>));
	}
	if (PyGLM_Vec_Check(3, float, arg) || arg == (PyObject*)&hfvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, float>));
	}
	if (PyGLM_Vec_Check(3, double, arg) || arg == (PyObject*)&hdvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, double>));
	}
	if (PyGLM_Vec_Check(3, int, arg) || arg == (PyObject*)&hivec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, int>));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg) || arg == (PyObject*)&huvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::uint>));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg) || arg == (PyObject*)&hi64vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i64>));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg) || arg == (PyObject*)&hu64vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u64>));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg) || arg == (PyObject*)&hi16vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i16>));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg) || arg == (PyObject*)&hu16vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u16>));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg) || arg == (PyObject*)&hi8vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i8>));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg) || arg == (PyObject*)&hu8vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u8>));
	}
	if (PyGLM_Vec_Check(3, bool, arg) || arg == (PyObject*)&hbvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, bool>));
	}
	if (PyGLM_Vec_Check(4, float, arg) || arg == (PyObject*)&hfvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, float>));
	}
	if (PyGLM_Vec_Check(4, double, arg) || arg == (PyObject*)&hdvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, double>));
	}
	if (PyGLM_Vec_Check(4, int, arg) || arg == (PyObject*)&hivec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, int>));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg) || arg == (PyObject*)&huvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::uint>));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg) || arg == (PyObject*)&hi64vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i64>));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg) || arg == (PyObject*)&hu64vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u64>));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg) || arg == (PyObject*)&hi16vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i16>));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg) || arg == (PyObject*)&hu16vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u16>));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg) || arg == (PyObject*)&hi8vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i8>));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg) || arg == (PyObject*)&hu8vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u8>));
	}
	if (PyGLM_Vec_Check(4, bool, arg) || arg == (PyObject*)&hbvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, bool>));
	}
	if (PyGLM_Qua_Check(float, arg) || arg == (PyObject*)&hfquaType) {
		return PyLong_FromLong(sizeof(glm::qua<float>));
	}
	if (PyGLM_Qua_Check(double, arg) || arg == (PyObject*)&hdquaType) {
		return PyLong_FromLong(sizeof(glm::qua<double>));
	}
	if (PyGLM_Mat_Check(2, 2, float, arg) || arg == (PyObject*)&hfmat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, float>));
	}
	if (PyGLM_Mat_Check(2, 2, double, arg) || arg == (PyObject*)&hdmat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, double>));
	}
	if (PyGLM_Mat_Check(2, 2, int, arg) || arg == (PyObject*)&himat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, int>));
	}
	if (PyGLM_Mat_Check(2, 2, glm::uint, arg) || arg == (PyObject*)&humat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(2, 3, float, arg) || arg == (PyObject*)&hfmat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, float>));
	}
	if (PyGLM_Mat_Check(2, 3, double, arg) || arg == (PyObject*)&hdmat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, double>));
	}
	if (PyGLM_Mat_Check(2, 3, int, arg) || arg == (PyObject*)&himat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, int>));
	}
	if (PyGLM_Mat_Check(2, 3, glm::uint, arg) || arg == (PyObject*)&humat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(2, 4, float, arg) || arg == (PyObject*)&hfmat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, float>));
	}
	if (PyGLM_Mat_Check(2, 4, double, arg) || arg == (PyObject*)&hdmat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, double>));
	}
	if (PyGLM_Mat_Check(2, 4, int, arg) || arg == (PyObject*)&himat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, int>));
	}
	if (PyGLM_Mat_Check(2, 4, glm::uint, arg) || arg == (PyObject*)&humat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 2, float, arg) || arg == (PyObject*)&hfmat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, float>));
	}
	if (PyGLM_Mat_Check(3, 2, double, arg) || arg == (PyObject*)&hdmat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, double>));
	}
	if (PyGLM_Mat_Check(3, 2, int, arg) || arg == (PyObject*)&himat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, int>));
	}
	if (PyGLM_Mat_Check(3, 2, glm::uint, arg) || arg == (PyObject*)&humat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 3, float, arg) || arg == (PyObject*)&hfmat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, float>));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg) || arg == (PyObject*)&hdmat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, double>));
	}
	if (PyGLM_Mat_Check(3, 3, int, arg) || arg == (PyObject*)&himat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, int>));
	}
	if (PyGLM_Mat_Check(3, 3, glm::uint, arg) || arg == (PyObject*)&humat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 4, float, arg) || arg == (PyObject*)&hfmat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, float>));
	}
	if (PyGLM_Mat_Check(3, 4, double, arg) || arg == (PyObject*)&hdmat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, double>));
	}
	if (PyGLM_Mat_Check(3, 4, int, arg) || arg == (PyObject*)&himat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, int>));
	}
	if (PyGLM_Mat_Check(3, 4, glm::uint, arg) || arg == (PyObject*)&humat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 2, float, arg) || arg == (PyObject*)&hfmat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, float>));
	}
	if (PyGLM_Mat_Check(4, 2, double, arg) || arg == (PyObject*)&hdmat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, double>));
	}
	if (PyGLM_Mat_Check(4, 2, int, arg) || arg == (PyObject*)&himat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, int>));
	}
	if (PyGLM_Mat_Check(4, 2, glm::uint, arg) || arg == (PyObject*)&humat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 3, float, arg) || arg == (PyObject*)&hfmat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, float>));
	}
	if (PyGLM_Mat_Check(4, 3, double, arg) || arg == (PyObject*)&hdmat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, double>));
	}
	if (PyGLM_Mat_Check(4, 3, int, arg) || arg == (PyObject*)&himat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, int>));
	}
	if (PyGLM_Mat_Check(4, 3, glm::uint, arg) || arg == (PyObject*)&humat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg) || arg == (PyObject*)&hfmat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, float>));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg) || arg == (PyObject*)&hdmat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, double>));
	}
	if (PyGLM_Mat_Check(4, 4, int, arg) || arg == (PyObject*)&himat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, int>));
	}
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg) || arg == (PyObject*)&humat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, glm::uint>));
	}
	PyGLM_TYPEERROR_O("sizeof() requires the argument to be a glm type, not ", arg);
	return NULL;
}

static PyObject*
value_ptr_(PyObject*, PyObject* arg) {
	if (Py_TYPE(arg) == &hfvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfquaType) {
		return PyGLM_ToCtypesP(glm::value_ptr(((qua<float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdquaType) {
		return PyGLM_ToCtypesP(glm::value_ptr(((qua<double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, glm::uint>*)arg)->super_type));
	}
	PyGLM_TYPEERROR_O("value_ptr() requires the argument to be a glm type, not ", arg);
	return NULL;
}

static PyObject*
make_vec2_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec2((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec2((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec2((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec2((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec2((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec2((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec2((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}

static PyObject*
make_vec3_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec3((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec3((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec3((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec3((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec3((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec3((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec3((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}

static PyObject*
make_vec4_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec4((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec4((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec4((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec4((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec4((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec4((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec4((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_quat_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_quat((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_quat((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_quat() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x2_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x3_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x4_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x2_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x3_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x4_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x2_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x3_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x4_(PyObject*, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}

static PyObject*
next_float_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "next_float", 1, 2, &arg1, &arg2)) return NULL;
	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			return pack(glm::next_float(PyGLM_Number_FromPyObject<double>(arg1)));
		}
		if (PyGLM_Vec_Check(1, float, arg1)) {
			return pack(glm::next_float(unpack_vec<1, float>(arg1)));
		}
		if (PyGLM_Vec_Check(1, double, arg1)) {
			return pack(glm::next_float(unpack_vec<1, double>(arg1)));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			return pack(glm::next_float(unpack_vec<2, float>(arg1)));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			return pack(glm::next_float(unpack_vec<2, double>(arg1)));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			return pack(glm::next_float(unpack_vec<3, float>(arg1)));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			return pack(glm::next_float(unpack_vec<3, double>(arg1)));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			return pack(glm::next_float(unpack_vec<4, float>(arg1)));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			return pack(glm::next_float(unpack_vec<4, double>(arg1)));
		}
		PyGLM_TYPEERROR_O("invalid argument type for next_float(): ", arg1);
		return NULL;
	}
	if (PyLong_Check(arg2)) {
		int ULPs = PyGLM_Number_FromPyObject<int>(arg2);
		PyGLM_ASSERT((ULPs >= 0), "'ULPs' has to be greater than or equal to 0")
		if (PyGLM_Number_Check(arg1)) {
			return pack(glm::next_float(PyGLM_Number_FromPyObject<double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(1, float, arg1)) {
			return pack(glm::next_float(unpack_vec<1, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(1, double, arg1)) {
			return pack(glm::next_float(unpack_vec<1, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			return pack(glm::next_float(unpack_vec<2, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			return pack(glm::next_float(unpack_vec<2, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			return pack(glm::next_float(unpack_vec<3, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			return pack(glm::next_float(unpack_vec<3, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			return pack(glm::next_float(unpack_vec<4, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			return pack(glm::next_float(unpack_vec<4, double>(arg1), ULPs));
		}
	}
	else {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			return pack(glm::next_float(unpack_vec<1, float>(arg1), unpack_vec<1, int>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			return pack(glm::next_float(unpack_vec<1, double>(arg1), unpack_vec<1, int>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			return pack(glm::next_float(unpack_vec<2, float>(arg1), unpack_vec<2, int>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			return pack(glm::next_float(unpack_vec<2, double>(arg1), unpack_vec<2, int>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			return pack(glm::next_float(unpack_vec<3, float>(arg1), unpack_vec<3, int>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			return pack(glm::next_float(unpack_vec<3, double>(arg1), unpack_vec<3, int>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			return pack(glm::next_float(unpack_vec<4, float>(arg1), unpack_vec<4, int>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			return pack(glm::next_float(unpack_vec<4, double>(arg1), unpack_vec<4, int>(arg2)));
		}
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for next_float(): ", arg1, arg2);
	return NULL;
}

static PyObject*
prev_float_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "prev_float", 1, 2, &arg1, &arg2)) return NULL;
	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			return pack(glm::prev_float(PyGLM_Number_FromPyObject<double>(arg1)));
		}
		if (PyGLM_Vec_Check(1, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<1, float>(arg1)));
		}
		if (PyGLM_Vec_Check(1, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<1, double>(arg1)));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<2, float>(arg1)));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<2, double>(arg1)));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<3, float>(arg1)));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<3, double>(arg1)));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<4, float>(arg1)));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<4, double>(arg1)));
		}
		PyGLM_TYPEERROR_O("invalid argument type for prev_float(): ", arg1);
		return NULL;
	}
	if (PyLong_Check(arg2)) {
		int ULPs = PyGLM_Number_FromPyObject<int>(arg2);
		PyGLM_ASSERT((ULPs >= 0), "'ULPs' has to be greater than or equal to 0")
		if (PyGLM_Number_Check(arg1)) {
			return pack(glm::prev_float(PyGLM_Number_FromPyObject<double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(1, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<1, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(1, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<1, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<2, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<2, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<3, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<3, double>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			return pack(glm::prev_float(unpack_vec<4, float>(arg1), ULPs));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			return pack(glm::prev_float(unpack_vec<4, double>(arg1), ULPs));
		}
	}
	else {
		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<1, float>(arg1), unpack_vec<1, int>(arg2)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<1, double>(arg1), unpack_vec<1, int>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<2, float>(arg1), unpack_vec<2, int>(arg2)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<2, double>(arg1), unpack_vec<2, int>(arg2)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<3, float>(arg1), unpack_vec<3, int>(arg2)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<3, double>(arg1), unpack_vec<3, int>(arg2)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<4, float>(arg1), unpack_vec<4, int>(arg2)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			return pack(glm::prev_float(unpack_vec<4, double>(arg1), unpack_vec<4, int>(arg2)));
		}
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for prev_float(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(float_distance);

static PyObject*
silence(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		int warning_id = static_cast<int>(PyLong_AS_LONG(arg));
		if (warning_id < 0 || warning_id > 1) {
			PyErr_SetString(PyExc_ValueError, "the specified warning does not exist.");
			return NULL;
		}
		if (warning_id == 0) {
			PyGLM_SHOW_WARNINGS = 0;
		}
		else {
			PyGLM_SHOW_WARNINGS = PyGLM_SHOW_WARNINGS ^ warning_id;
		}
		Py_RETURN_NONE;
	}
	PyGLM_TYPEERROR_O("silence() requires an integer as it's argument, not ", arg);
	return NULL;
}

// UNSTABLE EXTENSIONS

PyGLM_MAKE_GLM_FUNC_V3__tfF(polar)
PyGLM_MAKE_GLM_FUNC_V2__tfF(euclidean)

//static PyObject*
//test(PyObject* self, PyObject* arg) {
//	return PyFloat_FromDouble(glm::clamp(0.1, 0.0, 0.2));
//}
//#define HAS_TEST
//#define TEST_FUNC_TYPE METH_NOARGS

static PyMethodDef glmmethods[] = {
	// DETAIL
	// func_packing
	{ "packDouble2x32", (PyCFunction)packDouble2x32_, METH_O, "packDouble2x32(v) -> float\nReturns a double-qualifier value obtained by packing the components of v into a 64-bit value." },
	{ "packUnorm2x16", (PyCFunction)packUnorm2x16_, METH_O, "packUnorm2x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packSnorm2x16", (PyCFunction)packSnorm2x16_, METH_O, "packSnorm2x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packSnorm4x8", (PyCFunction)packSnorm4x8_, METH_O, "packSnorm4x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packUnorm4x8", (PyCFunction)packUnorm4x8_, METH_O, "packUnorm4x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packHalf2x16", (PyCFunction)packHalf2x16_, METH_O, "packHalf2x16(v) -> int\nReturns an unsigned integer obtained by converting the components of a two - component floating - point vector\nto the 16-bit floating-point representation found in the OpenGL Specification,\nand then packing these two 16- bit integers into a 32-bit unsigned integer." },
	{ "unpackDouble2x32", (PyCFunction)unpackDouble2x32_, METH_O, "unpackDouble2x32(v) -> float\nReturns a two-component unsigned integer vector representation of v." },
	{ "unpackUnorm2x16", (PyCFunction)unpackUnorm2x16_, METH_O, "unpackUnorm2x16(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackSnorm2x16", (PyCFunction)unpackSnorm2x16_, METH_O, "unpackSnorm2x16(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackSnorm4x8", (PyCFunction)unpackSnorm4x8_, METH_O, "unpackSnorm4x8(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackUnorm4x8", (PyCFunction)unpackUnorm4x8_, METH_O, "unpackUnorm4x8(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackHalf2x16", (PyCFunction)unpackHalf2x16_, METH_O, "unpackHalf2x16(v) -> int\nReturns a two - component floating - point vector with components obtained by unpacking a 32 - bit unsigned integer into a pair of 16 - bit values,\ninterpreting those values as 16-bit floating-point numbers according to the OpenGL Specification,\nand converting them to 32-bit floating-point values." },

	// func_integer
	{ "uaddCarry", (PyCFunction)uaddCarry_, METH_VARARGS, "uaddCarry(x, y, Carry) -> vecn\nAdds 32-bit unsigned integer x and y, returning the sum\nmodulo pow(2, 32). The value carry is set to 0 if the sum was\nless than pow(2, 32), or to 1 otherwise." },
	{ "usubBorrow", (PyCFunction)usubBorrow_, METH_VARARGS, "usubBorrow(x, y, Borrow) -> vecn\nSubtracts the 32-bit unsigned integer y from x, returning\nthe difference if non-negative, or pow(2, 32) plus the difference\notherwise. The value borrow is set to 0 if x >= y, or to 1 otherwise." },
	{ "umulExtended", (PyCFunction)umulExtended_, METH_VARARGS, "umulExtended(x, y, msb, lsb) -> None\nMultiplies 32-bit integers x and y, producing a 64-bit\nresult. The 32 least-significant bits are returned in lsb.\nThe 32 most-significant bits are returned in msb." },
	{ "imulExtended", (PyCFunction)imulExtended_, METH_VARARGS, "imulExtended(x, y, msb, lsb) -> None\nMultiplies 32-bit integers x and y, producing a 64-bit\nresult. The 32 least-significant bits are returned in lsb.\nThe 32 most-significant bits are returned in msb." },
	{ "bitfieldExtract", (PyCFunction)bitfieldExtract_, METH_VARARGS, "bitfieldExtract(Value, Offset, Bits) -> vecn or int\nExtracts bits [offset, offset + bits - 1] from value,\nreturning them in the least significant bits of the result." },
	{ "bitfieldInsert", (PyCFunction)bitfieldInsert_, METH_VARARGS, "bitfieldInsert(Base, Insert, Offset, Bits) -> vecn or int\nReturns the insertion the bits least-significant bits of insert into base." },
	{ "bitfieldReverse", (PyCFunction)bitfieldReverse_, METH_O, "bitfieldReverse(v) -> vecn or float\nReturns the reversal of the bits of value." },
	{ "bitCount", (PyCFunction)bitCount_, METH_O, "bitCount(v) -> vecn or int\nReturns the number of bits set to 1 in the binary representation of value." },
	{ "findLSB", (PyCFunction)findLSB_, METH_O, "findLSB(x) -> vecn or int\nReturns the bit number of the least significant bit set to\n1 in the binary representation of value.\nIf value is zero, -1 will be returned." },
	{ "findMSB", (PyCFunction)findMSB_, METH_O, "findMSB(x) -> vecn or int\nReturns the bit number of the most significant bit in the binary representation of value." },

	// func_vector_relational
	{ "equal", (PyCFunction)equal, METH_VARARGS, "equal(x, y[, ...]) -> (x == y)\nReturns the component-wise comparison of result x == y." },
	{ "notEqual", (PyCFunction)notEqual, METH_VARARGS, "notEqual(x, y[, ...]) -> (x != y)\nReturns the component-wise comparison of result x != y." },
	{ "lessThan", (PyCFunction)lessThan_, METH_VARARGS, "lessThan(x, y) -> (x < y)\nReturns the component-wise comparison of result x < y." },
	{ "lessThanEqual", (PyCFunction)lessThanEqual_, METH_VARARGS, "lessThanEqual(x, y) -> (x <= y)\nReturns the component-wise comparison of result x <= y." },
	{ "greaterThan", (PyCFunction)greaterThan_, METH_VARARGS, "greaterThan(x, y) -> (x > y)\nReturns the component-wise comparison of result x > y." },
	{ "greaterThanEqual", (PyCFunction)greaterThanEqual_, METH_VARARGS, "greaterThanEqual(x, y) -> (x >= y)\nReturns the component-wise comparison of result x >= y." },
	{ "any", (PyCFunction)any, METH_O, "any(x) -> bool\nReturns true if any component of x is true." },
	{ "all", (PyCFunction)all, METH_O, "all(x) -> bool\nReturns true if all components of x are true." },
	{ "not_", (PyCFunction)not_, METH_O, "not(x) -> bool\nReturns the component-wise logical complement of x." },

	// func_exponential 
	{ "pow", (PyCFunction)pow_, METH_VARARGS, "pow(base, exponent) -> float, vecn or quat\nReturns 'base' raised to the power 'exponent'." },
	{ "exp", (PyCFunction)exp_, METH_O, "exp(x) -> float, vecn or quat\nReturns the natural exponentiation of x, i.e., e^x." },
	{ "log", (PyCFunction)log_, METH_O, "log(v) -> float, vecn or quat\nReturns the natural logarithm of v, i.e.,\nreturns the value y which satisfies the equation x = e^y.\nResults are undefined if v <= 0." },
	{ "exp2", (PyCFunction)exp2_, METH_O, "exp2(v) -> float or vecn\nReturns 2 raised to the v power." },
	{ "log2", (PyCFunction)log2_, METH_O, "log2(x) -> float or vecn\nReturns the base 2 log of x, i.e., returns the value y,\nwhich satisfies the equation x = 2 ^ y." },
	{ "sqrt", (PyCFunction)sqrt_, METH_O, "sqrt(v) -> float, vecn or quat\nReturns the positive square root of v." },
	{ "inversesqrt", (PyCFunction)inversesqrt_, METH_O, "inversesqrt(v) -> float or vecn\nReturns the reciprocal of the positive square root of v." },

	// func_common
	{ "abs", (PyCFunction)abs_, METH_O, "abs(x) -> float or vecn\nReturns x if x >= 0; otherwise, it returns -x." },
	{ "sign", (PyCFunction)sign_, METH_O, "sign(x) -> float or vecn\nReturns 1.0 if x > 0, 0.0 if x == 0, or -1.0 if x < 0. " },
	{ "floor", (PyCFunction)floor_, METH_O, "floor(x) -> float or vecn\nReturns a value equal to the nearest integer that is less then or equal to x." },
	{ "trunc", (PyCFunction)trunc_, METH_O, "trunc(x) -> float or vecn\nReturns a value equal to the nearest integer to x\nwhose absolute value is not larger than the absolute value of x." },
	{ "round", (PyCFunction)round_, METH_O, "round(x) -> float or vecn\nReturns a value equal to the nearest integer to x.\nThe fraction 0.5 will round in a direction chosen by the\nimplementation, presumably the direction that is fastest.\nThis includes the possibility that round(x) returns the\nsame value as roundEven(x) for all values of x." },
	{ "roundEven", (PyCFunction)roundEven_, METH_O, "roundEven(x) -> float or vecn\nReturns a value equal to the nearest integer to x.\nA fractional part of 0.5 will round toward the nearest even\ninteger. (Both 3.5 and 4.5 for x will return 4.0.)" },
	{ "ceil", (PyCFunction)ceil_, METH_O, "ceil(x) -> float or vecn\nReturns a value equal to the nearest integer\nthat is greater than or equal to x." },
	{ "fract", (PyCFunction)fract_, METH_O, "fract(x) -> float or vecn\nReturn x - floor(x)." },
	{ "mod", (PyCFunction)mod_, METH_VARARGS, "mod(x, y) -> float or vecn\nModulus. Returns x - y * floor(x / y)\nfor each component in x using the floating point value y." },
	{ "min", (PyCFunction)min_, METH_VARARGS, "min(x, y[, z, w]) -> float or vecn\nReturns y if y < x; otherwise, it returns x." },
	{ "max", (PyCFunction)max_, METH_VARARGS, "max(x, y[, z, w]) -> float or vecn\nReturns y if x < y; otherwise, it returns x." },
	{ "fmin", (PyCFunction)fmin_, METH_VARARGS, "fmin(x, y[, z, w]) -> float or vecn\nReturns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned." },
	{ "fmax", (PyCFunction)fmax_, METH_VARARGS, "fmax(x, y[, z, w]) -> float or vecn\nReturns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned." },
	{ "clamp", (PyCFunction)clamp_, METH_VARARGS, "clamp(x, minVal, maxVal) -> float or vecn\nReturns min(max(x, minVal), maxVal) for each component in x\nusing the floating-point values minVal and maxVal." },
	{ "mix", (PyCFunction)mix_, METH_VARARGS, "mix(x, y, a) -> float, vecn or quat\nReturns x * (1.0 - a) + y * a, i.e., the linear blend of\nx and y using the floating-point value a.\nThe value for a is not restricted to the range [0, 1]." },
	{ "step", (PyCFunction)step_, METH_VARARGS, "step(edge, x) -> Returns 0.0 if x < edge, otherwise it returns 1.0." },
	{ "smoothstep", (PyCFunction)smoothstep_, METH_VARARGS, "smoothstep(edge0, edge1, x) -> float or vecn\nReturns 0.0 if x <= edge0 and 1.0 if x >= edge1 and\nperforms smooth Hermite interpolation between 0 and 1\nwhen edge0 < x < edge1. This is useful in cases where\nyou would want a threshold function with a smooth\ntransition." },
	{ "isnan", (PyCFunction)isnan_, METH_O, "isnan(x) -> bool or vecn\nReturns true if x holds a NaN (not a number)\nrepresentation in the underlying implementation's set of\nfloating point representations. Returns false otherwise,\nincluding for implementations with no NaN\nrepresentations." },
	{ "isinf", (PyCFunction)isinf_, METH_O, "isinf(x) -> bool or vecn\nReturns true if x holds a positive infinity or negative\ninfinity representation in the underlying implementation's\nset of floating point representations. Returns false\notherwise, including for implementations with no infinity\nrepresentations." },
	{ "fma", (PyCFunction)fma_, METH_VARARGS, "fma(a, b, c) -> float\nComputes and returns a * b + c." },
	{ "frexp", (PyCFunction)frexp_, METH_VARARGS, "frexp(x, exp) -> float or vecn\nSplits x into a floating-point significand in the range\n[0.5, 1.0) and an integral exponent of two, such that:\nx = significand * exp(2, exponent)" },
	{ "ldexp", (PyCFunction)ldexp_, METH_VARARGS, "ldexp(x, exp) -> float or vecn\nBuilds a floating-point number from x and the\ncorresponding integral exponent of two in exp, returning:\nsignificand * exp(2, exponent)" },

	// func_geometric
	{ "length", (PyCFunction)length_, METH_O, "length(x) -> float\nReturns the length of x, i.e., sqrt(x * x)." },
	{ "distance", (PyCFunction)distance_, METH_VARARGS, "distance(p0, p1) -> float\nReturns the distance betwwen p0 and p1, i.e., length(p0 - p1)." },
	{ "dot", (PyCFunction)dot_, METH_VARARGS, "dot(x, y) -> float\nReturns the dot product of x and y, i.e., result = x * y." },
	{ "cross", (PyCFunction)cross_, METH_VARARGS, "cross(x, y) -> vec3 or quat\nReturns the cross product of x and y." },
	{ "normalize", (PyCFunction)normalize_, METH_O, "normalize(x) -> vecn or quat\nReturns a vector in the same direction as x but with length of 1." },
	{ "faceforward", (PyCFunction)faceforward_, METH_VARARGS, "faceforward(N, I, Nref) -> float or vecn\nIf dot(Nref, I) < 0.0, return N, otherwise, return -N." },
	{ "reflect", (PyCFunction)reflect_, METH_VARARGS, "reflect(I, N) -> float or vecn\nFor the incident vector I and surface orientation N,\nreturns the reflection direction : result = I - 2.0 * dot(N, I) * N." },
	{ "refract", (PyCFunction)refract_, METH_VARARGS, "refract(I, N, eta) -> float or vecn\nFor the incident vector I and surface normal N,\nand the ratio of indices of refraction eta,\nreturn the refraction vector." },

	// func_matrix
	{ "matrixCompMult", (PyCFunction)matrixCompMult_, METH_VARARGS, "matrixCompMult(x, y) -> matnxn\nMultiply matrix x by matrix y component-wise, i.e.,\nresult[i][j] is the scalar product of x[i][j] and y[i][j]." },
	{ "outerProduct", (PyCFunction)outerProduct_, METH_VARARGS, "outerProduct(c, r) -> matnxn\nTreats the first parameter c as a column vector\nand the second parameter r as a row vector\nand does a linear algebraic matrix multiply c * r." },
	{ "transpose", (PyCFunction)transpose_, METH_O, "transpose(x) -> matnxn\nReturns the transposed matrix of x" },
	{ "determinant", (PyCFunction)determinant_, METH_O, "determinant(x) -> float\nReturn the determinant of a squared matrix." },
	{ "inverse", (PyCFunction)inverse_, METH_O, "inverse(x) -> matnxn or quat\nReturn the inverse of a squared matrix or quaternion." },

	// func_trigonometric
	{ "radians", (PyCFunction)radians_, METH_O, "radians(x) -> float or vecn\nConverts degrees to radians and returns the result." },
	{ "degrees", (PyCFunction)degrees_, METH_O, "degrees(x) -> float or vecn\nConverts radians to degrees and returns the result." },
	{ "sin", (PyCFunction)sin_, METH_O, "sin(x) -> vecn\nThe standard trigonometric sine function. \nThe values returned by this function will range from [-1, 1]." },
	{ "cos", (PyCFunction)cos_, METH_O, "cos(x) -> vecn\nThe standard trigonometric cosine function.\nThe values returned by this function will range from [-1, 1]." },
	{ "tan", (PyCFunction)tan_, METH_O, "tan(x) -> vecn\nThe standard trigonometric tangent function." },
	{ "asin", (PyCFunction)asin_, METH_O, "asin(x) -> vecn\nArc sine. Returns an angle whose sine is x. \nThe range of values returned by this function is [-PI/2, PI/2].\nResults are undefined if |x| > 1." },
	{ "acos", (PyCFunction)acos_, METH_O, "acos(x) -> vecn\nArc cosine. Returns an angle whose sine is x.\nThe range of values returned by this function is [0, PI].\nResults are undefined if |x| > 1." },
	{ "atan", (PyCFunction)atan_,  METH_VARARGS, "atan(y [,x]) -> float or vecn\nArc tangent. Returns an angle whose tangent is y/x.\nThe signs of x and y are used to determine what\nquadrant the angle is in. The range of values returned\nby this function is [-PI, PI]. Results are undefined\nif x and y are both 0." },
	{ "sinh", (PyCFunction)sinh_, METH_O, "sinh(x) -> vecn\nReturns the hyperbolic sine function, (exp(x) - exp(-x)) / 2" },
	{ "cosh", (PyCFunction)cosh_, METH_O, "cosh(x) -> vecn\nReturns the hyperbolic cosine function, (exp(x) + exp(-x)) / 2" },
	{ "tanh", (PyCFunction)tanh_, METH_O, "tanh(x) -> vecn\nReturns the hyperbolic tangent function, sinh(angle) / cosh(angle)" },
	{ "asinh", (PyCFunction)asinh_, METH_O, "asinh(x) -> float or vecn\nArc hyperbolic sine; returns the inverse of sinh." },
	{ "acosh", (PyCFunction)acosh_, METH_O, "acosh(x) -> float or vecn\nArc hyperbolic cosine; returns the non-negative inverse\nof cosh. Results are undefined if x < 1." },
	{ "atanh", (PyCFunction)atanh_, METH_O, "atanh(x) -> float or vecn\nArc hyperbolic tangent; returns the inverse of tanh.\nResults are undefined if abs(x) >= 1." },

	// EXTENSIONS
	// color_space
	{ "convertLinearToSRGB", (PyCFunction)convertLinearToSRGB_, METH_VARARGS, "convertLinearToSRGB(ColorLinear[, Gamma]) -> vecn\nConvert a linear color to sRGB color using a standard / custom gamma correction." },
	{ "convertSRGBToLinear", (PyCFunction)convertSRGBToLinear_, METH_VARARGS, "convertSRGBToLinear(ColorLinear[, Gamma]) -> vecn\nConvert a sRGB color to linear color using a standard / custom gamma correction." },

	// constants
	{ "epsilon", (PyCFunction)epsilon_, METH_NOARGS, "epsilon() -> float\nReturn the epsilon constant for floating point types." },
	{ "zero", (PyCFunction)zero_, METH_NOARGS, "zero() -> float\nReturn 0." },
	{ "one", (PyCFunction)one_, METH_NOARGS, "one() -> float\nReturn 1." },
	{ "pi", (PyCFunction)pi_, METH_NOARGS, "pi() -> float\nReturn the pi constant." },
	{ "two_pi", (PyCFunction)two_pi_, METH_NOARGS, "two_pi() -> float\nReturn pi * 2." },
	{ "root_pi", (PyCFunction)root_pi_, METH_NOARGS, "root_pi() -> float\nReturn square root of pi." },
	{ "half_pi", (PyCFunction)half_pi_, METH_NOARGS, "half_pi() -> float\nReturn pi / 2." },
	{ "three_over_two_pi", (PyCFunction)three_over_two_pi_, METH_NOARGS, "three_over_two_pi() -> float\nReturn pi / 2 * 3." },
	{ "quarter_pi", (PyCFunction)quarter_pi_, METH_NOARGS, "quarter_pi() -> float\nReturn pi / 4." },
	{ "one_over_pi", (PyCFunction)one_over_pi_, METH_NOARGS, "one_over_pi() -> float\nReturn 1 / pi." },
	{ "one_over_two_pi", (PyCFunction)one_over_two_pi_, METH_NOARGS, "one_over_two_pi() -> float\nReturn 1 / (pi * 2)." },
	{ "two_over_pi", (PyCFunction)two_over_pi_, METH_NOARGS, "two_over_pi() -> float\nReturn 2 / pi." },
	{ "four_over_pi", (PyCFunction)four_over_pi_, METH_NOARGS, "four_over_pi() -> float\nReturn 4 / pi." },
	{ "two_over_root_pi", (PyCFunction)two_over_root_pi_, METH_NOARGS, "two_over_root_pi() -> float\nReturn 2 / sqrt(pi)." },
	{ "one_over_root_two", (PyCFunction)one_over_root_two_, METH_NOARGS, "one_over_root_two() -> float\nReturn 1 / sqrt(2)." },
	{ "root_half_pi", (PyCFunction)root_half_pi_, METH_NOARGS, "root_half_pi() -> float\nReturn sqrt(pi / 2)." },
	{ "root_two_pi", (PyCFunction)root_two_pi_, METH_NOARGS, "root_two_pi() -> float\nReturn sqrt(2 * pi)." },
	{ "root_ln_four", (PyCFunction)root_ln_four_, METH_NOARGS, "root_ln_four() -> float\nReturn sqrt(ln(4))." },
	{ "e", (PyCFunction)e_, METH_NOARGS, "e() -> float\nReturn e constant." },
	{ "euler", (PyCFunction)euler_, METH_NOARGS, "euler() -> float\nReturn Euler's constant." },
	{ "root_two", (PyCFunction)root_two_, METH_NOARGS, "root_two() -> float\nReturn sqrt(2)." },
	{ "root_three", (PyCFunction)root_three_, METH_NOARGS, "root_three() -> float\nReturn sqrt(3)." },
	{ "root_five", (PyCFunction)root_five_, METH_NOARGS, "root_five() -> float\nReturn sqrt(5)." },
	{ "ln_two", (PyCFunction)ln_two_, METH_NOARGS, "ln_two() -> float\nReturn ln(2)." },
	{ "ln_ten", (PyCFunction)ln_ten_, METH_NOARGS, "ln_ten() -> float\nReturn ln(10)." },
	{ "ln_ln_two", (PyCFunction)ln_ln_two_, METH_NOARGS, "ln_ln_two() -> float\nReturn ln(ln(2))." },
	{ "third", (PyCFunction)third_, METH_NOARGS, "third() -> float\nReturn 1 / 3." },
	{ "two_thirds", (PyCFunction)two_thirds_, METH_NOARGS, "two_thirds() -> float\nReturn 2 / 3." },
	{ "golden_ratio", (PyCFunction)golden_ratio_, METH_NOARGS, "golden_ratio() -> float\nReturn the golden ratio constant." },

	// epsilon
	{ "epsilonEqual", (PyCFunction)epsilonEqual_, METH_VARARGS, "epsilonEqual(x, y, epsilon) -> vecn or quat\nReturns the component-wise comparison of |x - y| < epsilon.\nTrue if this expression is satisfied." },
	{ "epsilonNotEqual", (PyCFunction)epsilonNotEqual_, METH_VARARGS, "epsilonNotEqual(x, y, epsilon) -> vecn or quat\nReturns the component-wise comparison of |x - y| >= epsilon.\nTrue if this expression is satisfied." },

	// integer
	{ "iround", (PyCFunction)iround_, METH_O, "iround(x) -> int or ivec\nReturns a value equal to the nearest integer to x." },
	{ "uround", (PyCFunction)uround_, METH_O, "uround(x) -> int or uvec\nReturns a value equal to the nearest integer to x." },

	// matrix_inverse
	{ "affineInverse", (PyCFunction)affineInverse_, METH_O, "affineInverse(m) -> matn\nFast matrix inverse for affine matrix." },
	{ "inverseTranspose", (PyCFunction)inverseTranspose_, METH_O, "inverseTranspose(m) -> matn\nCompute the inverse transpose of a matrix." },

	// matrix_transform
	{ "identity", (PyCFunction)identity_, METH_O, "identity(matrix_type) -> matrix\nBuilds an identity matrix." },
	{ "translate", (PyCFunction)translate_, METH_VARARGS, "translate(m, v) -> mat4x4\nBuilds a translation 4 * 4 matrix created from a vector of 3 components." },
	{ "rotate", (PyCFunction)rotate_, METH_VARARGS, "rotate(m, angle, axis) -> mat4x4 or quat\nBuilds a rotation 4 * 4 matrix created from an axis vector and an angle\nor rotates a quaternion from a vector of 3 components axis and an angle." },
	{ "rotate_slow", (PyCFunction)rotate_slow_, METH_VARARGS, "rotate_slow(m, angle, axis) -> mat4x4\nBuilds a rotation 4 * 4 matrix created from an axis vector and an angle." },
	{ "scale", (PyCFunction)scale_, METH_VARARGS, "scale(m, v) -> mat4x4\nBuilds a scale 4 * 4 matrix created from 3 scalars." },
	{ "scale_slow", (PyCFunction)scale_slow_, METH_VARARGS, "scale_slow(m, v) -> mat4x4\nBuilds a scale 4 * 4 matrix created from 3 scalars." },
	{ "ortho", (PyCFunction)ortho_, METH_VARARGS, "ortho(left, right, bottom, top[, zNear, zFar]) -> mat4x4\nCreates a matrix for projecting two-dimensional coordinates onto the screen." },
	{ "orthoLH_ZO", (PyCFunction)orthoLH_ZO_, METH_VARARGS, "orthoLH_ZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoLH_NO", (PyCFunction)orthoLH_NO_, METH_VARARGS, "orthoLH_NO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoRH_ZO", (PyCFunction)orthoRH_ZO_, METH_VARARGS, "orthoRH_ZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoRH_NO", (PyCFunction)orthoRH_NO_, METH_VARARGS, "orthoRH_NO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoZO", (PyCFunction)orthoZO_, METH_VARARGS, "orthoZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoNO", (PyCFunction)orthoNO_, METH_VARARGS, "orthoNO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoLH", (PyCFunction)orthoLH_, METH_VARARGS, "orthoLH(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoRH", (PyCFunction)orthoRH_, METH_VARARGS, "orthoRH(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustum", (PyCFunction)frustum_, METH_VARARGS, "frustum(left, right, bottom, top, near, far) -> mat4x4\nCreates a frustum matrix with default handedness, using right-handedness and -1 to +1 near and far clip planes definition." },
	{ "frustumLH_ZO", (PyCFunction)frustumLH_ZO_, METH_VARARGS, "frustumLH_ZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumLH_NO", (PyCFunction)frustumLH_NO_, METH_VARARGS, "frustumLH_NO(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumRH_ZO", (PyCFunction)frustumRH_ZO_, METH_VARARGS, "frustumRH_ZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumRH_NO", (PyCFunction)frustumRH_NO_, METH_VARARGS, "frustumRH_NO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumZO", (PyCFunction)frustumZO_, METH_VARARGS, "frustumZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumNO", (PyCFunction)frustumNO_, METH_VARARGS, "frustumNO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumLH", (PyCFunction)frustumLH_, METH_VARARGS, "frustumLH(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumRH", (PyCFunction)frustumRH_, METH_VARARGS, "frustumRH(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspective", (PyCFunction)perspective_, METH_VARARGS, "perspective(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum." },
	{ "perspectiveLH_ZO", (PyCFunction)perspectiveLH_ZO_, METH_VARARGS, "perspectiveLH_ZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveLH_NO", (PyCFunction)perspectiveLH_NO_, METH_VARARGS, "perspectiveLH_NO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveRH_ZO", (PyCFunction)perspectiveRH_ZO_, METH_VARARGS, "perspectiveRH_ZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveRH_NO", (PyCFunction)perspectiveRH_NO_, METH_VARARGS, "perspectiveRH_NO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveZO", (PyCFunction)perspectiveZO_, METH_VARARGS, "perspectiveZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveNO", (PyCFunction)perspectiveNO_, METH_VARARGS, "perspectiveNO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveLH", (PyCFunction)perspectiveLH_, METH_VARARGS, "perspectiveLH(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveRH", (PyCFunction)perspectiveRH_, METH_VARARGS, "perspectiveRH(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFov", (PyCFunction)perspectiveFov_, METH_VARARGS, "perspectiveFov(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates." },
	{ "perspectiveFovLH_ZO", (PyCFunction)perspectiveFovLH_ZO_, METH_VARARGS, "perspectiveFovLH_ZO(fov, width, height, near, far) -> mat4x4\n\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovLH_NO", (PyCFunction)perspectiveFovLH_NO_, METH_VARARGS, "perspectiveFovLH_NO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovRH_ZO", (PyCFunction)perspectiveFovRH_ZO_, METH_VARARGS, "perspectiveFovRH_ZO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovRH_NO", (PyCFunction)perspectiveFovRH_NO_, METH_VARARGS, "perspectiveFovRH_NO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovZO", (PyCFunction)perspectiveFovZO_, METH_VARARGS, "perspectiveFovZO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovNO", (PyCFunction)perspectiveFovNO_, METH_VARARGS, "perspectiveFovNO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovLH", (PyCFunction)perspectiveFovLH_, METH_VARARGS, "perspectiveFovLH(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovRH", (PyCFunction)perspectiveFovRH_, METH_VARARGS, "perspectiveFovRH(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "infinitePerspective", (PyCFunction)infinitePerspective_, METH_VARARGS, "infinitePerspective(fovy, aspect, near) -> mat4x4\nCreates a matrix for a right handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "infinitePerspectiveRH", (PyCFunction)infinitePerspectiveRH_, METH_VARARGS, "infinitePerspectiveRH(fovy, aspect, near) -> mat4x4\nCreates a matrix for a right handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "infinitePerspectiveLH", (PyCFunction)infinitePerspectiveLH_, METH_VARARGS, "infinitePerspectiveLH(fovy, aspect, near) -> mat4x4\nCreates a matrix for a left handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "tweakedInfinitePerspective", (PyCFunction)tweakedInfinitePerspective_, METH_VARARGS, "tweakedInfinitePerspective(fovy, aspect, near[, ep]) -> mat4x4\nCreates a matrix for a symmetric perspective-view frustum with far plane at infinite for graphics hardware that doesn't support depth clamping." },
	{ "project", (PyCFunction)project_, METH_VARARGS, "project(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "projectNO", (PyCFunction)projectNO_, METH_VARARGS, "projectNO(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "projectZO", (PyCFunction)projectZO_, METH_VARARGS, "projectZO(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "unProject", (PyCFunction)unProject_, METH_VARARGS, "unProject(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "unProjectNO", (PyCFunction)unProjectNO_, METH_VARARGS, "unProjectNO(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "unProjectZO", (PyCFunction)unProjectZO_, METH_VARARGS, "unProjectZO(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "pickMatrix", (PyCFunction)pickMatrix_, METH_VARARGS, "pickMatrix(center, delta, viewport) -> mat4x4\nDefine a picking region" },
	{ "lookAt", (PyCFunction)lookAt_, METH_VARARGS, "lookAt(eye, center, up) -> mat4x4\nBuild a right handed look at view matrix." },
	{ "lookAtRH", (PyCFunction)lookAtRH_, METH_VARARGS, "lookAtRH(eye, center, up) -> mat4x4\nBuild a right handed look at view matrix." },
	{ "lookAtLH", (PyCFunction)lookAtLH_, METH_VARARGS, "lookAtLH(eye, center, up) -> mat4x4\nBuild a left handed look at view matrix." },

	// quaternion
	{ "quatLookAt", (PyCFunction)quatLookAt_, METH_VARARGS, "quatLookAt(direction, up) -> quat\nBuild a look at quaternion based on the default handedness." },
	{ "quatLookAtLH", (PyCFunction)quatLookAtLH_, METH_VARARGS, "quatLookAtLH(direction, up) -> quat\nBuild a left-handed look at quaternion." },
	{ "quatLookAtRH", (PyCFunction)quatLookAtRH_, METH_VARARGS, "quatLookAtRH(direction, up) -> quat\nBuild a right-handed look at quaternion." },
	{ "lerp", (PyCFunction)lerp_, METH_VARARGS, "lerp(x, y, a) -> quat\nLinear interpolation of two quaternions.\nThe interpolation is oriented." },
	{ "slerp", (PyCFunction)slerp_, METH_VARARGS, "slerp(x, y, a) -> quat\nSpherical linear interpolation of two quaternions.\nThe interpolation always take the short path and the rotation is performed at constant speed." },
	{ "conjugate", (PyCFunction)conjugate_, METH_O, "conjugate(q) -> quat\nReturns the q conjugate." },
	{ "eulerAngles", (PyCFunction)eulerAngles_, METH_O, "eulerAngles(x) -> vec3\nReturns euler angles, pitch as x, yaw as y, roll as z." },
	{ "roll", (PyCFunction)roll_, METH_O, "roll(x) -> float\nReturns roll value of euler angles expressed in radians." },
	{ "pitch", (PyCFunction)pitch_, METH_O, "pitch(x) -> float\nReturns pitch value of euler angles expressed in radians." },
	{ "yaw", (PyCFunction)yaw_, METH_O, "yaw(x) -> float\nReturns yaw value of euler angles expressed in radians." },
	{ "mat3_cast", (PyCFunction)mat3_cast_, METH_O, "mat3_cast(x) -> mat3x3\nConverts a quaternion to a 3 * 3 matrix." },
	{ "mat4_cast", (PyCFunction)mat4_cast_, METH_O, "mat4_cast(x) -> mat4x4\nConverts a quaternion to a 4 * 4 matrix." },
	{ "quat_cast", (PyCFunction)quat_cast_, METH_O, "quat_cast(m) -> quat\nConverts a 3 * 3 or 4 * 4 matrix to a quaternion." },
	{ "angle", (PyCFunction)angle_, METH_O, "angle(x) -> float\nReturns the quaternion rotation angle." },
	{ "axis", (PyCFunction)axis_, METH_O, "axis(x) -> vec3\nReturns the quaternion rotation axis." },
	{ "angleAxis", (PyCFunction)angleAxis_, METH_VARARGS, "angleAxis(angle, v) -> quat\nBuild a quaternion from an angle and a normalized axis." },

	// matrix_access
	{ "row", (PyCFunction)row_, METH_VARARGS, "row(m, index[, x]) -> vecn or matnxn\nGet a specific row of a matrix or set a specific row to a matrix." },
	{ "column", (PyCFunction)column_, METH_VARARGS, "column(m, index[, x]) -> vecn or matnxn\nGet a specific column of a matrix or set a specific column to a matrix." },

	// noise
	{ "perlin", (PyCFunction)perlin_, METH_VARARGS, "perlin(p[, rep]) -> float\nClassic or periodic perlin noise." },
	{ "simplex", (PyCFunction)simplex_, METH_O, "simplex(p) -> float\nSimplex noise." },

	// packing
	{ "packInt2x8", (PyCFunction)packInt2x8_, METH_O, "packInt2x8(v) -> int\nConvert each component from an integer vector into a packed integer." },
	{ "unpackInt2x8", (PyCFunction)unpackInt2x8_, METH_O, "unpackInt2x8(v) -> i8vec2\nConvert a packed integer into an integer vector." },
	{ "packInt4x8", (PyCFunction)packInt4x8_, METH_O, "packInt4x8(v) -> int\nConvert each component from an integer vector into a packed integer." },
	{ "unpackInt4x8", (PyCFunction)unpackInt4x8_, METH_O, "unpackInt4x8(v) -> i8vec4\nConvert a packed integer into an integer vector." },
	{ "packInt2x16", (PyCFunction)packInt2x16_, METH_O, "packInt2x16(v) -> int\nConvert each component from an integer vector into a packed integer." },
	{ "unpackInt2x16", (PyCFunction)unpackInt2x16_, METH_O, "unpackInt2x16(v) -> i16vec2\nConvert a packed integer into an integer vector." },
	{ "packInt4x16", (PyCFunction)packInt4x16_, METH_O, "packInt4x16(v) -> int\nConvert each component from an integer vector into a packed integer." },
	{ "unpackInt4x16", (PyCFunction)unpackInt4x16_, METH_O, "unpackInt4x16(v) -> i16vec4\nConvert a packed integer into an integer vector." },
	{ "packInt2x32", (PyCFunction)packInt2x32_, METH_O, "packInt2x32(v) -> int\nConvert each component from an integer vector into a packed integer." },
	{ "unpackInt2x32", (PyCFunction)unpackInt2x32_, METH_O, "unpackInt2x32(v) -> i32vec2\nConvert a packed integer into an integer vector." },
	{ "packUint2x8", (PyCFunction)packUint2x8_, METH_O, "packUint2x8(v) -> int\nConvert each component from an integer vector into a packed unsigned integer." },
	{ "unpackUint2x8", (PyCFunction)unpackUint2x8_, METH_O, "unpackUint2x8(v) -> u8vec2\nConvert a packed integer into an integer vector." },
	{ "packUint4x8", (PyCFunction)packUint4x8_, METH_O, "packUint4x8(v) -> int\nConvert each component from an integer vector into a packed unsigned integer." },
	{ "unpackUint4x8", (PyCFunction)unpackUint4x8_, METH_O, "unpackUint4x8(v) -> u8vec4\nConvert a packed integer into an integer vector." },
	{ "packUint2x16", (PyCFunction)packUint2x16_, METH_O, "packUint2x16(v) -> int\nConvert each component from an integer vector into a packed unsigned integer." },
	{ "unpackUint2x16", (PyCFunction)unpackUint2x16_, METH_O, "unpackUint2x16(v) -> u16vec2\nConvert a packed integer into an integer vector." },
	{ "packUint4x16", (PyCFunction)packUint4x16_, METH_O, "packUint4x16(v) -> int\nConvert each component from an integer vector into a packed unsigned integer." },
	{ "unpackUint4x16", (PyCFunction)unpackUint4x16_, METH_O, "unpackUint4x16(v) -> u16vec4\nConvert a packed integer into an integer vector." },
	{ "packUint2x32", (PyCFunction)packUint2x32_, METH_O, "packUint2x32(v) -> int\nConvert each component from an integer vector into a packed unsigned integer." },
	{ "unpackUint2x32", (PyCFunction)unpackUint2x32_, METH_O, "unpackUint2x32(v) -> u32vec2\nConvert a packed integer into an integer vector." },
	{ "packHalf1x16", (PyCFunction)packHalf1x16_, METH_O, "packHalf1x16(v) -> int\nReturns an unsigned integer obtained by converting the components of a floating-point scalar\nto the 16-bit floating-point representation found in the OpenGL Specification,\nand then packing this 16-bit value into a 16-bit unsigned integer." },
	{ "unpackHalf1x16", (PyCFunction)unpackHalf1x16_, METH_O, "unpackHalf1x16(v) -> float\nReturns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value,\ninterpreted as a 16-bit floating-point number according to the OpenGL Specification,\nand converting it to 32-bit floating-point values." },
	{ "packHalf4x16", (PyCFunction)packHalf4x16_, METH_O, "packHalf4x16(v) -> int\nReturns an unsigned integer obtained by converting the components of a floating-point scalar\nto the 16-bit floating-point representation found in the OpenGL Specification,\nand then packing this 16-bit value into a 16-bit unsigned integer." },
	{ "unpackHalf4x16", (PyCFunction)unpackHalf4x16_, METH_O, "unpackHalf4x16(v) -> vec4\nReturns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value,\ninterpreted as a 16-bit floating-point number according to the OpenGL Specification,\nand converting it to 32-bit floating-point values." },
	{ "packUnorm1x8", (PyCFunction)packUnorm1x8_, METH_O, "packUnorm1x8(v) -> int\nFirst, converts the normalized floating-point value v into a 8-bit integer value.\nThen, the results are packed into the returned 8-bit unsigned integer." },
	{ "unpackUnorm1x8", (PyCFunction)unpackUnorm1x8_, METH_O, "unpackUnorm1x8(v) -> float\nConvert a single 8-bit integer to a normalized floating-point value." },
	{ "packUnorm2x8", (PyCFunction)packUnorm2x8_, METH_O, "packUnorm2x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8-bit integer values.\nThen, the results are packed into the returned 16-bit unsigned integer." },
	{ "unpackUnorm2x8", (PyCFunction)unpackUnorm2x8_, METH_O, "unpackUnorm2x8(v) -> vec2\nFirst, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two-component vector." },
	{ "packUnorm1x16", (PyCFunction)packUnorm1x16_, METH_O, "packUnorm1x16(v) -> int\nFirst, converts the normalized floating-point value v into a 16-bit integer value.\nThen, the results are packed into the returned 16-bit unsigned integer." },
	{ "unpackUnorm1x16", (PyCFunction)unpackUnorm1x16_, METH_O, "unpackUnorm1x16(v) -> float\nFirst, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers.\nThen, the value is converted to a normalized floating-point value to generate the returned scalar." },
	{ "packUnorm4x16", (PyCFunction)packUnorm4x16_, METH_O, "packUnorm4x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 16-bit integer values.\nThen, the results are packed into the returned 64-bit unsigned integer." },
	{ "unpackUnorm4x16", (PyCFunction)unpackUnorm4x16_, METH_O, "unpackUnorm4x16(v) -> vec4\nFirst, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers.\nThen, each component is converted to a normalized floating-point value to generate the returned four-component vector." },
	{ "packUnorm3x10_1x2", (PyCFunction)packUnorm3x10_1x2_, METH_O, "packUnorm3x10_1x2(v) -> int\nFirst, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values.\nThen, converts the forth component of the normalized floating-point value v into 2-bit signed uninteger values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "unpackUnorm3x10_1x2", (PyCFunction)unpackUnorm3x10_1x2_, METH_O, "unpackUnorm3x10_1x2(v) -> vec4\nFirst, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned four-component vector." },
	{ "packUnorm2x4", (PyCFunction)packUnorm2x4_, METH_O, "packUnorm2x4(v) -> int\nConvert each component of the normalized floating-point vector into unsigned integer values." },
	{ "unpackUnorm2x4", (PyCFunction)unpackUnorm2x4_, METH_O, "unpackUnorm2x4(v) -> vec2\nConvert a packed integer to a normalized floating-point vector." },
	{ "packUnorm4x4", (PyCFunction)packUnorm4x4_, METH_O, "packUnorm4x4(v) -> int\nConvert each component of the normalized floating-point vector into unsigned integer values." },
	{ "unpackUnorm4x4", (PyCFunction)unpackUnorm4x4_, METH_O, "unpackUnorm4x4(v) -> vec2\nConvert a packed integer to a normalized floating-point vector." },
	{ "packUnorm1x5_1x6_1x5", (PyCFunction)packUnorm1x5_1x6_1x5_, METH_O, "packUnorm1x5_1x6_1x5(v) -> int\nConvert each component of the normalized floating-point vector into unsigned integer values." },
	{ "unpackUnorm1x5_1x6_1x5", (PyCFunction)unpackUnorm1x5_1x6_1x5_, METH_O, "unpackUnorm1x5_1x6_1x5(v) -> vec3\nConvert a packed integer to a normalized floating-point vector." },
	{ "packUnorm3x5_1x1", (PyCFunction)packUnorm3x5_1x1_, METH_O, "packUnorm3x5_1x1(v) -> int\nConvert each component of the normalized floating-point vector into unsigned integer values." },
	{ "unpackUnorm3x5_1x1", (PyCFunction)unpackUnorm3x5_1x1_, METH_O, "unpackUnorm3x5_1x1(v) -> vec2\nConvert a packed integer to a normalized floating-point vector." },
	{ "packUnorm2x3_1x2", (PyCFunction)packUnorm2x3_1x2_, METH_O, "packUnorm2x3_1x2(v) -> int\nConvert each component of the normalized floating-point vector into unsigned integer values." },
	{ "unpackUnorm2x3_1x2", (PyCFunction)unpackUnorm2x3_1x2_, METH_O, "unpackUnorm2x3_1x2(v) -> vec2\nConvert a packed integer to a normalized floating-point vector." },
	{ "packSnorm1x8", (PyCFunction)packSnorm1x8_, METH_O, "packSnorm1x8(v) -> int\nFirst, converts the normalized floating-point value v into a 8-bit integer value.\nThen, the results are packed into the returned 8-bit unsigned integer." },
	{ "unpackSnorm1x8", (PyCFunction)unpackSnorm1x8_, METH_O, "unpackSnorm1x8(v) -> float\nConvert a single 8-bit integer to a normalized floating-point value." },
	{ "packSnorm2x8", (PyCFunction)packSnorm2x8_, METH_O, "packSnorm2x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8-bit integer values.\nThen, the results are packed into the returned 16-bit unsigned integer." },
	{ "unpackSnorm2x8", (PyCFunction)unpackSnorm2x8_, METH_O, "unpackSnorm2x8(v) -> vec2\nFirst, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two-component vector." },
	{ "packSnorm1x16", (PyCFunction)packSnorm1x16_, METH_O, "packSnorm1x16(v) -> int\nFirst, converts the normalized floating-point value v into a 16-bit integer value.\nThen, the results are packed into the returned 16-bit unsigned integer." },
	{ "unpackSnorm1x16", (PyCFunction)unpackSnorm1x16_, METH_O, "unpackSnorm1x16(v) -> float\nFirst, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers.\nThen, the value is converted to a normalized floating-point value to generate the returned scalar." },
	{ "packSnorm4x16", (PyCFunction)packSnorm4x16_, METH_O, "packSnorm4x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 16-bit integer values.\nThen, the results are packed into the returned 64-bit unsigned integer." },
	{ "unpackSnorm4x16", (PyCFunction)unpackSnorm4x16_, METH_O, "unpackSnorm4x16(v) -> vec4\nFirst, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers.\nThen, each component is converted to a normalized floating-point value to generate the returned four-component vector." },
	{ "packSnorm3x10_1x2", (PyCFunction)packSnorm3x10_1x2_, METH_O, "packSnorm3x10_1x2(v) -> int\nFirst, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values.\nThen, converts the forth component of the normalized floating-point value v into 2-bit signed uninteger values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "unpackSnorm3x10_1x2", (PyCFunction)unpackSnorm3x10_1x2_, METH_O, "unpackSnorm3x10_1x2(v) -> vec4\nFirst, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned four-component vector." },
	{ "packI3x10_1x2", (PyCFunction)packI3x10_1x2_, METH_O, "packI3x10_1x2(v) -> int\nReturns an unsigned integer obtained by converting the components of a four-component signed integer vector\nto the 10-10-10-2-bit signed integer representation found in the OpenGL Specification,\nand then packing these four values into a 32-bit unsigned integer.\nThe first vector component specifies the 10 least-significant bits of the result;\nthe forth component specifies the 2 most-significant bits." },
	{ "unpackI3x10_1x2", (PyCFunction)unpackI3x10_1x2_, METH_O, "unpackI3x10_1x2(v) -> ivec4\nUnpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit signed integers." },
	{ "packU3x10_1x2", (PyCFunction)packU3x10_1x2_, METH_O, "packU3x10_1x2(v) -> int\nReturns an unsigned integer obtained by converting the components of a four-component unsigned integer vector\nto the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification,\nand then packing these four values into a 32-bit unsigned integer.\nThe first vector component specifies the 10 least-significant bits of the result;\nthe forth component specifies the 2 most-significant bits." },
	{ "unpackU3x10_1x2", (PyCFunction)unpackU3x10_1x2_, METH_O, "unpackU3x10_1x2(v) -> uvec4\nUnpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers." },
	{ "packF2x11_1x10", (PyCFunction)packF2x11_1x10_, METH_O, "packF2x11_1x10(v) -> int\nFirst, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values.\nThen, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "unpackF2x11_1x10", (PyCFunction)unpackF2x11_1x10_, METH_O, "unpackF2x11_1x10(v) -> vec3\nFirst, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value.\nThen, each component is converted to a normalized floating-point value to generate the returned three-component vector." },
	{ "packF3x9_E1x5", (PyCFunction)packF3x9_E1x5_, METH_O, "packF3x9_E1x5(v) -> int\nFirst, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values.\nThen, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "unpackF3x9_E1x5", (PyCFunction)unpackF3x9_E1x5_, METH_O, "unpackF3x9_E1x5(v) -> vec3\nFirst, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value.\nThen, each component is converted to a normalized floating-point value to generate the returned three-component vector." },
	{ "packRGBM", (PyCFunction)packRGBM_, METH_O, "packRGBM(v) -> vec4\nReturns an unsigned integer vector obtained by converting the components of a floating-point vector\nto the 16-bit floating-point representation found in the OpenGL Specification.\nThe first vector component specifies the 16 least-significant bits of the result;\nthe forth component specifies the 16 most-significant bits." },
	{ "unpackRGBM", (PyCFunction)unpackRGBM_, METH_O, "unpackRGBM(v) -> vec3\nReturns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values.\nThe first component of the vector is obtained from the 16 least-significant bits of v;\nthe forth component is obtained from the 16 most-significant bits of v." },
	{ "packHalf", (PyCFunction)packHalf_, METH_O, "packHalf(v) -> u16vecn\nReturns an unsigned integer vector obtained by converting the components of a floating-point vector\nto the 16-bit floating-point representation found in the OpenGL Specification.\nThe first vector component specifies the 16 least-significant bits of the result;\nthe forth component specifies the 16 most-significant bits." },
	{ "unpackHalf", (PyCFunction)unpackHalf_, METH_O, "unpackHalf(v) -> vecn\nReturns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values.\nThe first component of the vector is obtained from the 16 least-significant bits of v;\nthe forth component is obtained from the 16 most-significant bits of v." },

	// random
	{ "linearRand", (PyCFunction)linearRand_, METH_VARARGS, "linearRand(Min, Max) -> float or vecn\nGenerate random numbers in the interval [Min, Max], according a linear distribution" },
	{ "gaussRand", (PyCFunction)gaussRand_, METH_VARARGS, "gaussRand(Mean, Deviation) -> float\nGenerate random numbers in the interval [Min, Max], according a gaussian distribution" },
	{ "circularRand", (PyCFunction)circularRand_, METH_O, "circularRand(Radius) -> vec2\nGenerate a random 2D vector which coordinates are regulary distributed on a circle of a given radius" },
	{ "sphericalRand", (PyCFunction)sphericalRand_, METH_O, "sphericalRand(Radius) -> vec3\nGenerate a random 3D vector which coordinates are regulary distributed on a sphere of a given radius" },
	{ "diskRand", (PyCFunction)diskRand_, METH_O, "diskRand(Radius) -> vec2\nGenerate a random 2D vector which coordinates are regulary distributed within the area of a disk of a given radius" },
	{ "ballRand", (PyCFunction)ballRand_, METH_O, "ballRand(Radius) -> vec3\nGenerate a random 3D vector which coordinates are regulary distributed within the area of a ball of a given radius" },

	// round
	{ "isPowerOfTwo", (PyCFunction)isPowerOfTwo_, METH_O, "isPowerOfTwo(v) -> bool or bvecn\nReturn true if the value is a power of two number." },
	{ "ceilPowerOfTwo", (PyCFunction)ceilPowerOfTwo_, METH_O, "ceilPowerOfTwo(v) -> float or vecn\nReturn the power of two number which value is just higher the input value,\nround up to a power of two." },
	{ "floorPowerOfTwo", (PyCFunction)floorPowerOfTwo_, METH_O, "floorPowerOfTwo(v) -> float or vecn\nReturn the power of two number which value is just lower the input value,\nround down to a power of two." },
	{ "roundPowerOfTwo", (PyCFunction)roundPowerOfTwo_, METH_O, "roundPowerOfTwo(v) -> float or vecn\nReturn the power of two number which value is the closet to the input value." },
	//{ "isMultiple", (PyCFunction)isMultiple_, METH_VARARGS, "isMultiple(v, Multiple) -> bool or bvecn\nReturn true if the 'Value' is a multiple of 'Multiple'." },
	{ "ceilMultiple", (PyCFunction)ceilMultiple_, METH_VARARGS, "ceilMultiple(v, Multiple) -> float or vecn\nHigher multiple number of Source." },
	{ "floorMultiple", (PyCFunction)floorMultiple_, METH_VARARGS, "floorMultiple(v, Multiple) -> float or vecn\nLower multiple number of Source." },
	{ "roundMultiple", (PyCFunction)roundMultiple_, METH_VARARGS, "roundMultiple(v, Multiple) -> float or vecn\nLower multiple number of Source." },

	// reciprocal
	{ "sec", (PyCFunction)sec_, METH_O, "sec(x) -> float or vecn\nSecant function.\nhypotenuse / adjacent or 1 / cos(x)" },
	{ "csc", (PyCFunction)csc_, METH_O, "csc(x) -> float or vecn\nCosecant function.\nhypotenuse / opposite or 1 / sin(x)" },
	{ "cot", (PyCFunction)cot_, METH_O, "cot(x) -> float or vecn\nCotangent function.\nadjacent / opposite or 1 / tan(x)" },
	{ "asec", (PyCFunction)asec_, METH_O, "asec(x) -> float or vecn\nInverse secant function." },
	{ "acsc", (PyCFunction)acsc_, METH_O, "acsc(x) -> float or vecn\nInverse cosecant function." },
	{ "acot", (PyCFunction)acot_, METH_O, "acot(x) -> float or vecn\nInverse cotangent function." },
	{ "sech", (PyCFunction)sech_, METH_O, "sech(x) -> float or vecn\nSecant hyperbolic function." },
	{ "csch", (PyCFunction)csch_, METH_O, "csch(x) -> float or vecn\nCosecant hyperbolic function." },
	{ "coth", (PyCFunction)coth_, METH_O, "coth(x) -> float or vecn\nCotangent hyperbolic function." },
	{ "asech", (PyCFunction)asech_, METH_O, "asech(x) -> float or vecn\nInverse secant hyperbolic function." },
	{ "acsch", (PyCFunction)acsch_, METH_O, "acsch(x) -> float or vecn\nInverse cosecant hyperbolic function." },
	{ "acoth", (PyCFunction)acoth_, METH_O, "acoth(x) -> float or vecn\nInverse cotangent hyperbolic function." },

	// type_ptr
	{ "value_ptr", (PyCFunction)value_ptr_, METH_O, "value_ptr(x) -> void* as int\nReturn the constant address to the data of the input parameter." },
	{ "sizeof", (PyCFunction)sizeof_, METH_O, "sizeof(x) -> int\nReturn the size of x in bytes." },
	{ "make_vec2", (PyCFunction)make_vec2_, METH_O, "make_vec2(ptr) -> vec2\nBuild a vector from a pointer." },
	{ "make_vec3", (PyCFunction)make_vec3_, METH_O, "make_vec3(ptr) -> vec3\nBuild a vector from a pointer." },
	{ "make_vec4", (PyCFunction)make_vec4_, METH_O, "make_vec4(ptr) -> vec4\nBuild a vector from a pointer." },
	{ "make_mat2", (PyCFunction)make_mat2x2_, METH_O, "make_mat2(ptr) -> mat2x2\nBuild a matrix from a pointer." },
	{ "make_mat2x2", (PyCFunction)make_mat2x2_, METH_O, "make_mat2x2(ptr) -> mat2x2\nBuild a matrix from a pointer." },
	{ "make_mat2x3", (PyCFunction)make_mat2x3_, METH_O, "make_mat2x3(ptr) -> mat2x3\nBuild a matrix from a pointer." },
	{ "make_mat2x4", (PyCFunction)make_mat2x4_, METH_O, "make_mat2x4(ptr) -> mat2x4\nBuild a matrix from a pointer." },
	{ "make_mat3x2", (PyCFunction)make_mat3x2_, METH_O, "make_mat3x2(ptr) -> mat3x2\nBuild a matrix from a pointer." },
	{ "make_mat3", (PyCFunction)make_mat3x3_, METH_O, "make_mat3(ptr) -> mat3x3\nBuild a matrix from a pointer." },
	{ "make_mat3x3", (PyCFunction)make_mat3x3_, METH_O, "make_mat3x3(ptr) -> mat3x3\nBuild a matrix from a pointer." },
	{ "make_mat3x4", (PyCFunction)make_mat3x4_, METH_O, "make_mat3x4(ptr) -> mat3x4\nBuild a matrix from a pointer." },
	{ "make_mat4x2", (PyCFunction)make_mat4x2_, METH_O, "make_mat4x2(ptr) -> mat4x2\nBuild a matrix from a pointer." },
	{ "make_mat4x3", (PyCFunction)make_mat4x3_, METH_O, "make_mat4x3(ptr) -> mat4x3\nBuild a matrix from a pointer." },
	{ "make_mat4", (PyCFunction)make_mat4x4_, METH_O, "make_mat4(ptr) -> mat4x4\nBuild a matrix from a pointer." },
	{ "make_mat4x4", (PyCFunction)make_mat4x4_, METH_O, "make_mat4x4(ptr) -> mat4x4\nBuild a matrix from a pointer." },
	{ "make_quat", (PyCFunction)make_quat_, METH_O, "make_quat(ptr) -> quat\nBuild a quaternion from a pointer." },

	// ulp
	{ "next_float", (PyCFunction)next_float_, METH_VARARGS, "next_float(x[, ULPs]) -> float or vecn\nReturn the next ULP value(s) after the input value(s)." },
	{ "prev_float", (PyCFunction)prev_float_, METH_VARARGS, "prev_float(x[, ULPs]) -> float or vecn\nReturn the previous ULP value(s) before the input value(s)." },
	{ "float_distance", (PyCFunction)float_distance_, METH_VARARGS, "float_distance(x, y) -> ivecn or i64vecn\nReturn the distance in the number of ULP between 2 single-precision floating-point scalars." },

	// UNSTABLE EXTENSIONS
	// polar_coordinates
	{ "polar", (PyCFunction)polar_, METH_O, "polar(v) -> vec3\nConvert Euclidean to Polar coordinates, x is the xz distance, y, the latitude and z the longitude." },
	{ "euclidean", (PyCFunction)euclidean_, METH_O, "euclidean(v) -> vec3\nConvert Polar to Euclidean coordinates." },

	// PyGLM functions
	{ "silence", (PyCFunction)silence, METH_O, "silence(ID) -> None\nSilence a PyGLM warning (or all using 0)." },
#ifdef HAS_TEST
	{"test", (PyCFunction)test, TEST_FUNC_TYPE, ""},
#endif
	{ NULL, NULL, 0, NULL }
};

#endif

static void glm_clear(PyObject*) {
	Py_XDECREF(ctypes_float_p);
	Py_XDECREF(ctypes_double_p);
	Py_XDECREF(ctypes_int64_p);
	Py_XDECREF(ctypes_int32_p);
	Py_XDECREF(ctypes_int16_p);
	Py_XDECREF(ctypes_int8_p);
	Py_XDECREF(ctypes_uint64_p);
	Py_XDECREF(ctypes_uint32_p);
	Py_XDECREF(ctypes_uint16_p);
	Py_XDECREF(ctypes_uint8_p);
	Py_XDECREF(ctypes_bool_p);
	Py_XDECREF(ctypes_cast);
	Py_XDECREF(ctypes_void_p);
	Py_XDECREF(PyGLM_VERSION_STRING);
	Py_XDECREF(PyGLM_LICENSE_STRING);
}

static PyModuleDef glmmodule = {
	PyModuleDef_HEAD_INIT,
	"glm",
	"Features that implement the GLSL specification as close as possible.",
	-1,
#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
	glmmethods, 
#else
	NULL,
#endif
	NULL, NULL, NULL, (freefunc)glm_clear
};

extern "C" {
	PyMODINIT_FUNC
		PyInit_glm(void)
	{
#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
		PyObject* mainmod = PyImport_AddModule("__main__");
		PyObject* maindict = PyModule_GetDict(mainmod);
		PyObject* ctypes_list = Py_BuildValue("(s, s, s, s, s, s, s, s, s, s, s, s, s, s)", "cast", "c_void_p", "POINTER", "c_float", "c_double", "c_int64", "c_int32", "c_int16", "c_int8", "c_uint64", "c_uint32", "c_uint16", "c_uint8", "c_bool");

		PyObject* ctypes_module = PyImport_ImportModuleEx("ctypes", maindict, maindict, ctypes_list);
		Py_DECREF(ctypes_list);

		ctypes_cast = PyObject_GetAttrString(ctypes_module, "cast");

		ctypes_void_p = PyObject_GetAttrString(ctypes_module, "c_void_p");

		PyObject* ctypes_POINTER = PyObject_GetAttrString(ctypes_module, "POINTER");

		PyObject* ctypes_float = PyObject_GetAttrString(ctypes_module, "c_float");
		ctypes_float_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_float, NULL);
		Py_DECREF(ctypes_float);

		PyObject* ctypes_double = PyObject_GetAttrString(ctypes_module, "c_double");
		ctypes_double_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_double, NULL);
		Py_DECREF(ctypes_double);

		PyObject* ctypes_int64 = PyObject_GetAttrString(ctypes_module, "c_int64");
		ctypes_int64_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int64, NULL);
		Py_DECREF(ctypes_int64);

		PyObject* ctypes_int32 = PyObject_GetAttrString(ctypes_module, "c_int32");
		ctypes_int32_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int32, NULL);
		Py_DECREF(ctypes_int32);

		PyObject* ctypes_int16 = PyObject_GetAttrString(ctypes_module, "c_int16");
		ctypes_int16_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int16, NULL);
		Py_DECREF(ctypes_int16);

		PyObject* ctypes_int8 = PyObject_GetAttrString(ctypes_module, "c_int8");
		ctypes_int8_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int8, NULL);
		Py_DECREF(ctypes_int8);

		PyObject* ctypes_uint64 = PyObject_GetAttrString(ctypes_module, "c_uint64");
		ctypes_uint64_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint64, NULL);
		Py_DECREF(ctypes_uint64);

		PyObject* ctypes_uint32 = PyObject_GetAttrString(ctypes_module, "c_uint32");
		ctypes_uint32_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint32, NULL);
		Py_DECREF(ctypes_uint32);

		PyObject* ctypes_uint16 = PyObject_GetAttrString(ctypes_module, "c_uint16");
		ctypes_uint16_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint16, NULL);
		Py_DECREF(ctypes_uint16);

		PyObject* ctypes_uint8 = PyObject_GetAttrString(ctypes_module, "c_uint8");
		ctypes_uint8_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint8, NULL);
		Py_DECREF(ctypes_uint8);

		PyObject* ctypes_bool = PyObject_GetAttrString(ctypes_module, "c_bool");
		ctypes_bool_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_bool, NULL);
		Py_DECREF(ctypes_bool);

		Py_DECREF(ctypes_POINTER);
		Py_DECREF(ctypes_module);
		
#endif

		PyObject* module_glm;

		if (PyType_Ready(&hfvec1Type) < 0 || PyType_Ready(&hfvec1IterType) < 0
			|| PyType_Ready(&hfvec2Type) < 0 || PyType_Ready(&hfvec2IterType) < 0
			|| PyType_Ready(&hfvec3Type) < 0 || PyType_Ready(&hfvec3IterType) < 0
			|| PyType_Ready(&hfvec4Type) < 0 || PyType_Ready(&hfvec4IterType) < 0
			|| PyType_Ready(&hdvec1Type) < 0 || PyType_Ready(&hdvec1IterType) < 0
			|| PyType_Ready(&hdvec2Type) < 0 || PyType_Ready(&hdvec2IterType) < 0
			|| PyType_Ready(&hdvec3Type) < 0 || PyType_Ready(&hdvec3IterType) < 0
			|| PyType_Ready(&hdvec4Type) < 0 || PyType_Ready(&hdvec4IterType) < 0
			|| PyType_Ready(&hi8vec1Type) < 0 || PyType_Ready(&hi8vec1IterType) < 0
			|| PyType_Ready(&hi8vec2Type) < 0 || PyType_Ready(&hi8vec2IterType) < 0
			|| PyType_Ready(&hi8vec3Type) < 0 || PyType_Ready(&hi8vec3IterType) < 0
			|| PyType_Ready(&hi8vec4Type) < 0 || PyType_Ready(&hi8vec4IterType) < 0
			|| PyType_Ready(&hi16vec1Type) < 0 || PyType_Ready(&hi16vec1IterType) < 0
			|| PyType_Ready(&hi16vec2Type) < 0 || PyType_Ready(&hi16vec2IterType) < 0
			|| PyType_Ready(&hi16vec3Type) < 0 || PyType_Ready(&hi16vec3IterType) < 0
			|| PyType_Ready(&hi16vec4Type) < 0 || PyType_Ready(&hi16vec4IterType) < 0
			|| PyType_Ready(&hivec1Type) < 0 || PyType_Ready(&hivec1IterType) < 0
			|| PyType_Ready(&hivec2Type) < 0 || PyType_Ready(&hivec2IterType) < 0
			|| PyType_Ready(&hivec3Type) < 0 || PyType_Ready(&hivec3IterType) < 0
			|| PyType_Ready(&hivec4Type) < 0 || PyType_Ready(&hivec4IterType) < 0
			|| PyType_Ready(&hi64vec1Type) < 0 || PyType_Ready(&hi64vec1IterType) < 0
			|| PyType_Ready(&hi64vec2Type) < 0 || PyType_Ready(&hi64vec2IterType) < 0
			|| PyType_Ready(&hi64vec3Type) < 0 || PyType_Ready(&hi64vec3IterType) < 0
			|| PyType_Ready(&hi64vec4Type) < 0 || PyType_Ready(&hi64vec4IterType) < 0
			|| PyType_Ready(&hu8vec1Type) < 0 || PyType_Ready(&hu8vec1IterType) < 0
			|| PyType_Ready(&hu8vec2Type) < 0 || PyType_Ready(&hu8vec2IterType) < 0
			|| PyType_Ready(&hu8vec3Type) < 0 || PyType_Ready(&hu8vec3IterType) < 0
			|| PyType_Ready(&hu8vec4Type) < 0 || PyType_Ready(&hu8vec4IterType) < 0
			|| PyType_Ready(&hu16vec1Type) < 0 || PyType_Ready(&hu16vec1IterType) < 0
			|| PyType_Ready(&hu16vec2Type) < 0 || PyType_Ready(&hu16vec2IterType) < 0
			|| PyType_Ready(&hu16vec3Type) < 0 || PyType_Ready(&hu16vec3IterType) < 0
			|| PyType_Ready(&hu16vec4Type) < 0 || PyType_Ready(&hu16vec4IterType) < 0
			|| PyType_Ready(&huvec1Type) < 0 || PyType_Ready(&huvec1IterType) < 0
			|| PyType_Ready(&huvec2Type) < 0 || PyType_Ready(&huvec2IterType) < 0
			|| PyType_Ready(&huvec3Type) < 0 || PyType_Ready(&huvec3IterType) < 0
			|| PyType_Ready(&huvec4Type) < 0 || PyType_Ready(&huvec4IterType) < 0
			|| PyType_Ready(&hu64vec1Type) < 0 || PyType_Ready(&hu64vec1IterType) < 0
			|| PyType_Ready(&hu64vec2Type) < 0 || PyType_Ready(&hu64vec2IterType) < 0
			|| PyType_Ready(&hu64vec3Type) < 0 || PyType_Ready(&hu64vec3IterType) < 0
			|| PyType_Ready(&hu64vec4Type) < 0 || PyType_Ready(&hu64vec4IterType) < 0
			|| PyType_Ready(&hbvec1Type) < 0 || PyType_Ready(&hbvec1IterType) < 0
			|| PyType_Ready(&hbvec2Type) < 0 || PyType_Ready(&hbvec2IterType) < 0
			|| PyType_Ready(&hbvec3Type) < 0 || PyType_Ready(&hbvec3IterType) < 0
			|| PyType_Ready(&hbvec4Type) < 0 || PyType_Ready(&hbvec4IterType) < 0
			|| PyType_Ready(&hfmvec2Type) < 0 || PyType_Ready(&hfmvec2IterType) < 0
			|| PyType_Ready(&hfmvec3Type) < 0 || PyType_Ready(&hfmvec3IterType) < 0
			|| PyType_Ready(&hfmvec4Type) < 0 || PyType_Ready(&hfmvec4IterType) < 0
			|| PyType_Ready(&hdmvec2Type) < 0 || PyType_Ready(&hdmvec2IterType) < 0
			|| PyType_Ready(&hdmvec3Type) < 0 || PyType_Ready(&hdmvec3IterType) < 0
			|| PyType_Ready(&hdmvec4Type) < 0 || PyType_Ready(&hdmvec4IterType) < 0
			|| PyType_Ready(&himvec2Type) < 0 || PyType_Ready(&himvec2IterType) < 0
			|| PyType_Ready(&himvec3Type) < 0 || PyType_Ready(&himvec3IterType) < 0
			|| PyType_Ready(&himvec4Type) < 0 || PyType_Ready(&himvec4IterType) < 0
			|| PyType_Ready(&humvec2Type) < 0 || PyType_Ready(&humvec2IterType) < 0
			|| PyType_Ready(&humvec3Type) < 0 || PyType_Ready(&humvec3IterType) < 0
			|| PyType_Ready(&humvec4Type) < 0 || PyType_Ready(&humvec4IterType) < 0
			|| PyType_Ready(&hfmat2x2Type) < 0 || PyType_Ready(&hfmat2x2IterType) < 0
			|| PyType_Ready(&hfmat2x3Type) < 0 || PyType_Ready(&hfmat2x3IterType) < 0
			|| PyType_Ready(&hfmat2x4Type) < 0 || PyType_Ready(&hfmat2x4IterType) < 0
			|| PyType_Ready(&hfmat3x2Type) < 0 || PyType_Ready(&hfmat3x2IterType) < 0
			|| PyType_Ready(&hfmat3x3Type) < 0 || PyType_Ready(&hfmat3x3IterType) < 0
			|| PyType_Ready(&hfmat3x4Type) < 0 || PyType_Ready(&hfmat3x4IterType) < 0
			|| PyType_Ready(&hfmat4x2Type) < 0 || PyType_Ready(&hfmat4x2IterType) < 0
			|| PyType_Ready(&hfmat4x3Type) < 0 || PyType_Ready(&hfmat4x3IterType) < 0
			|| PyType_Ready(&hfmat4x4Type) < 0 || PyType_Ready(&hfmat4x4IterType) < 0
			|| PyType_Ready(&hdmat2x2Type) < 0 || PyType_Ready(&hdmat2x2IterType) < 0
			|| PyType_Ready(&hdmat2x3Type) < 0 || PyType_Ready(&hdmat2x3IterType) < 0
			|| PyType_Ready(&hdmat2x4Type) < 0 || PyType_Ready(&hdmat2x4IterType) < 0
			|| PyType_Ready(&hdmat3x2Type) < 0 || PyType_Ready(&hdmat3x2IterType) < 0
			|| PyType_Ready(&hdmat3x3Type) < 0 || PyType_Ready(&hdmat3x3IterType) < 0
			|| PyType_Ready(&hdmat3x4Type) < 0 || PyType_Ready(&hdmat3x4IterType) < 0
			|| PyType_Ready(&hdmat4x2Type) < 0 || PyType_Ready(&hdmat4x2IterType) < 0
			|| PyType_Ready(&hdmat4x3Type) < 0 || PyType_Ready(&hdmat4x3IterType) < 0
			|| PyType_Ready(&hdmat4x4Type) < 0 || PyType_Ready(&hdmat4x4IterType) < 0
			|| PyType_Ready(&himat2x2Type) < 0 || PyType_Ready(&himat2x2IterType) < 0
			|| PyType_Ready(&himat2x3Type) < 0 || PyType_Ready(&himat2x3IterType) < 0
			|| PyType_Ready(&himat2x4Type) < 0 || PyType_Ready(&himat2x4IterType) < 0
			|| PyType_Ready(&himat3x2Type) < 0 || PyType_Ready(&himat3x2IterType) < 0
			|| PyType_Ready(&himat3x3Type) < 0 || PyType_Ready(&himat3x3IterType) < 0
			|| PyType_Ready(&himat3x4Type) < 0 || PyType_Ready(&himat3x4IterType) < 0
			|| PyType_Ready(&himat4x2Type) < 0 || PyType_Ready(&himat4x2IterType) < 0
			|| PyType_Ready(&himat4x3Type) < 0 || PyType_Ready(&himat4x3IterType) < 0
			|| PyType_Ready(&himat4x4Type) < 0 || PyType_Ready(&himat4x4IterType) < 0
			|| PyType_Ready(&humat2x2Type) < 0 || PyType_Ready(&humat2x2IterType) < 0
			|| PyType_Ready(&humat2x3Type) < 0 || PyType_Ready(&humat2x3IterType) < 0
			|| PyType_Ready(&humat2x4Type) < 0 || PyType_Ready(&humat2x4IterType) < 0
			|| PyType_Ready(&humat3x2Type) < 0 || PyType_Ready(&humat3x2IterType) < 0
			|| PyType_Ready(&humat3x3Type) < 0 || PyType_Ready(&humat3x3IterType) < 0
			|| PyType_Ready(&humat3x4Type) < 0 || PyType_Ready(&humat3x4IterType) < 0
			|| PyType_Ready(&humat4x2Type) < 0 || PyType_Ready(&humat4x2IterType) < 0
			|| PyType_Ready(&humat4x3Type) < 0 || PyType_Ready(&humat4x3IterType) < 0
			|| PyType_Ready(&humat4x4Type) < 0 || PyType_Ready(&humat4x4IterType) < 0
			|| PyType_Ready(&hfquaType) < 0 || PyType_Ready(&hfquaIterType) < 0
			|| PyType_Ready(&hdquaType) < 0 || PyType_Ready(&hdquaIterType) < 0)
			return NULL;

		module_glm = PyModule_Create(&glmmodule);
		if (module_glm == NULL)
			return NULL;


#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
		// backwards compatibility
		Py_INCREF(module_glm);
		PyModule_AddObject(module_glm, "detail", module_glm);

		Py_INCREF(module_glm);
		PyModule_AddObject(module_glm, "gtc", module_glm);
#endif

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "vec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "vec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "vec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "vec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "mat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "mat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "mat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "mat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "mat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "mat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "mat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "mat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "mat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "mat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "mat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "mat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "quat", (PyObject *)&hfquaType);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "fquat", (PyObject *)&hfquaType);

		Py_INCREF(&hdquaType);
		PyModule_AddObject(module_glm, "dquat", (PyObject *)&hdquaType);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "f32quat", (PyObject *)&hfquaType);

		Py_INCREF(&hdquaType);
		PyModule_AddObject(module_glm, "f64quat", (PyObject *)&hdquaType);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "fmat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "fmat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "fmat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "fmat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "fmat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "fmat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "fmat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "fmat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "fmat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "fmat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "fmat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "fmat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "dmat2x2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat2x3Type);
		PyModule_AddObject(module_glm, "dmat2x3", (PyObject *)&hdmat2x3Type);
		Py_INCREF(&hdmat2x4Type);
		PyModule_AddObject(module_glm, "dmat2x4", (PyObject *)&hdmat2x4Type);
		Py_INCREF(&hdmat3x2Type);
		PyModule_AddObject(module_glm, "dmat3x2", (PyObject *)&hdmat3x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "dmat3x3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat3x4Type);
		PyModule_AddObject(module_glm, "dmat3x4", (PyObject *)&hdmat3x4Type);
		Py_INCREF(&hdmat4x2Type);
		PyModule_AddObject(module_glm, "dmat4x2", (PyObject *)&hdmat4x2Type);
		Py_INCREF(&hdmat4x3Type);
		PyModule_AddObject(module_glm, "dmat4x3", (PyObject *)&hdmat4x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "dmat4x4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "dmat2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "dmat3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "dmat4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "imat2x2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat2x3Type);
		PyModule_AddObject(module_glm, "imat2x3", (PyObject *)&himat2x3Type);
		Py_INCREF(&himat2x4Type);
		PyModule_AddObject(module_glm, "imat2x4", (PyObject *)&himat2x4Type);
		Py_INCREF(&himat3x2Type);
		PyModule_AddObject(module_glm, "imat3x2", (PyObject *)&himat3x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "imat3x3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat3x4Type);
		PyModule_AddObject(module_glm, "imat3x4", (PyObject *)&himat3x4Type);
		Py_INCREF(&himat4x2Type);
		PyModule_AddObject(module_glm, "imat4x2", (PyObject *)&himat4x2Type);
		Py_INCREF(&himat4x3Type);
		PyModule_AddObject(module_glm, "imat4x3", (PyObject *)&himat4x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "imat4x4", (PyObject *)&himat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "imat2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "imat3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "imat4", (PyObject *)&himat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "umat2x2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat2x3Type);
		PyModule_AddObject(module_glm, "umat2x3", (PyObject *)&humat2x3Type);
		Py_INCREF(&humat2x4Type);
		PyModule_AddObject(module_glm, "umat2x4", (PyObject *)&humat2x4Type);
		Py_INCREF(&humat3x2Type);
		PyModule_AddObject(module_glm, "umat3x2", (PyObject *)&humat3x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "umat3x3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat3x4Type);
		PyModule_AddObject(module_glm, "umat3x4", (PyObject *)&humat3x4Type);
		Py_INCREF(&humat4x2Type);
		PyModule_AddObject(module_glm, "umat4x2", (PyObject *)&humat4x2Type);
		Py_INCREF(&humat4x3Type);
		PyModule_AddObject(module_glm, "umat4x3", (PyObject *)&humat4x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "umat4x4", (PyObject *)&humat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "umat2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "umat3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "umat4", (PyObject *)&humat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "f32mat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "f32mat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "f32mat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "f32mat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "f32mat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "f32mat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "f32mat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "f32mat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "f32mat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "f32mat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "f32mat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "f32mat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "f64mat2x2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat2x3Type);
		PyModule_AddObject(module_glm, "f64mat2x3", (PyObject *)&hdmat2x3Type);
		Py_INCREF(&hdmat2x4Type);
		PyModule_AddObject(module_glm, "f64mat2x4", (PyObject *)&hdmat2x4Type);
		Py_INCREF(&hdmat3x2Type);
		PyModule_AddObject(module_glm, "f64mat3x2", (PyObject *)&hdmat3x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "f64mat3x3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat3x4Type);
		PyModule_AddObject(module_glm, "f64mat3x4", (PyObject *)&hdmat3x4Type);
		Py_INCREF(&hdmat4x2Type);
		PyModule_AddObject(module_glm, "f64mat4x2", (PyObject *)&hdmat4x2Type);
		Py_INCREF(&hdmat4x3Type);
		PyModule_AddObject(module_glm, "f64mat4x3", (PyObject *)&hdmat4x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "f64mat4x4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "f64mat2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "f64mat3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "f64mat4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "i32mat2x2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat2x3Type);
		PyModule_AddObject(module_glm, "i32mat2x3", (PyObject *)&himat2x3Type);
		Py_INCREF(&himat2x4Type);
		PyModule_AddObject(module_glm, "i32mat2x4", (PyObject *)&himat2x4Type);
		Py_INCREF(&himat3x2Type);
		PyModule_AddObject(module_glm, "i32mat3x2", (PyObject *)&himat3x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "i32mat3x3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat3x4Type);
		PyModule_AddObject(module_glm, "i32mat3x4", (PyObject *)&himat3x4Type);
		Py_INCREF(&himat4x2Type);
		PyModule_AddObject(module_glm, "i32mat4x2", (PyObject *)&himat4x2Type);
		Py_INCREF(&himat4x3Type);
		PyModule_AddObject(module_glm, "i32mat4x3", (PyObject *)&himat4x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "i32mat4x4", (PyObject *)&himat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "i32mat2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "i32mat3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "i32mat4", (PyObject *)&himat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "u32mat2x2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat2x3Type);
		PyModule_AddObject(module_glm, "u32mat2x3", (PyObject *)&humat2x3Type);
		Py_INCREF(&humat2x4Type);
		PyModule_AddObject(module_glm, "u32mat2x4", (PyObject *)&humat2x4Type);
		Py_INCREF(&humat3x2Type);
		PyModule_AddObject(module_glm, "u32mat3x2", (PyObject *)&humat3x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "u32mat3x3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat3x4Type);
		PyModule_AddObject(module_glm, "u32mat3x4", (PyObject *)&humat3x4Type);
		Py_INCREF(&humat4x2Type);
		PyModule_AddObject(module_glm, "u32mat4x2", (PyObject *)&humat4x2Type);
		Py_INCREF(&humat4x3Type);
		PyModule_AddObject(module_glm, "u32mat4x3", (PyObject *)&humat4x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "u32mat4x4", (PyObject *)&humat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "u32mat2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "u32mat3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "u32mat4", (PyObject *)&humat4x4Type);

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "fvec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "fvec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "fvec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "fvec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hdvec1Type);
		PyModule_AddObject(module_glm, "dvec1", (PyObject *)&hdvec1Type);
		Py_INCREF(&hdvec2Type);
		PyModule_AddObject(module_glm, "dvec2", (PyObject *)&hdvec2Type);
		Py_INCREF(&hdvec3Type);
		PyModule_AddObject(module_glm, "dvec3", (PyObject *)&hdvec3Type);
		Py_INCREF(&hdvec4Type);
		PyModule_AddObject(module_glm, "dvec4", (PyObject *)&hdvec4Type);

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "f32vec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "f32vec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "f32vec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "f32vec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hdvec1Type);
		PyModule_AddObject(module_glm, "f64vec1", (PyObject *)&hdvec1Type);
		Py_INCREF(&hdvec2Type);
		PyModule_AddObject(module_glm, "f64vec2", (PyObject *)&hdvec2Type);
		Py_INCREF(&hdvec3Type);
		PyModule_AddObject(module_glm, "f64vec3", (PyObject *)&hdvec3Type);
		Py_INCREF(&hdvec4Type);
		PyModule_AddObject(module_glm, "f64vec4", (PyObject *)&hdvec4Type);

		Py_INCREF(&hi8vec1Type);
		PyModule_AddObject(module_glm, "i8vec1", (PyObject *)&hi8vec1Type);
		Py_INCREF(&hi8vec2Type);
		PyModule_AddObject(module_glm, "i8vec2", (PyObject *)&hi8vec2Type);
		Py_INCREF(&hi8vec3Type);
		PyModule_AddObject(module_glm, "i8vec3", (PyObject *)&hi8vec3Type);
		Py_INCREF(&hi8vec4Type);
		PyModule_AddObject(module_glm, "i8vec4", (PyObject *)&hi8vec4Type);

		Py_INCREF(&hi16vec1Type);
		PyModule_AddObject(module_glm, "i16vec1", (PyObject *)&hi16vec1Type);
		Py_INCREF(&hi16vec2Type);
		PyModule_AddObject(module_glm, "i16vec2", (PyObject *)&hi16vec2Type);
		Py_INCREF(&hi16vec3Type);
		PyModule_AddObject(module_glm, "i16vec3", (PyObject *)&hi16vec3Type);
		Py_INCREF(&hi16vec4Type);
		PyModule_AddObject(module_glm, "i16vec4", (PyObject *)&hi16vec4Type);

		Py_INCREF(&hivec1Type);
		PyModule_AddObject(module_glm, "i32vec1", (PyObject *)&hivec1Type);
		Py_INCREF(&hivec2Type);
		PyModule_AddObject(module_glm, "i32vec2", (PyObject *)&hivec2Type);
		Py_INCREF(&hivec3Type);
		PyModule_AddObject(module_glm, "i32vec3", (PyObject *)&hivec3Type);
		Py_INCREF(&hivec4Type);
		PyModule_AddObject(module_glm, "i32vec4", (PyObject *)&hivec4Type);

		Py_INCREF(&hivec1Type);
		PyModule_AddObject(module_glm, "ivec1", (PyObject *)&hivec1Type);
		Py_INCREF(&hivec2Type);
		PyModule_AddObject(module_glm, "ivec2", (PyObject *)&hivec2Type);
		Py_INCREF(&hivec3Type);
		PyModule_AddObject(module_glm, "ivec3", (PyObject *)&hivec3Type);
		Py_INCREF(&hivec4Type);
		PyModule_AddObject(module_glm, "ivec4", (PyObject *)&hivec4Type);

		Py_INCREF(&hi64vec1Type);
		PyModule_AddObject(module_glm, "i64vec1", (PyObject *)&hi64vec1Type);
		Py_INCREF(&hi64vec2Type);
		PyModule_AddObject(module_glm, "i64vec2", (PyObject *)&hi64vec2Type);
		Py_INCREF(&hi64vec3Type);
		PyModule_AddObject(module_glm, "i64vec3", (PyObject *)&hi64vec3Type);
		Py_INCREF(&hi64vec4Type);
		PyModule_AddObject(module_glm, "i64vec4", (PyObject *)&hi64vec4Type);

		Py_INCREF(&hu8vec1Type);
		PyModule_AddObject(module_glm, "u8vec1", (PyObject *)&hu8vec1Type);
		Py_INCREF(&hu8vec2Type);
		PyModule_AddObject(module_glm, "u8vec2", (PyObject *)&hu8vec2Type);
		Py_INCREF(&hu8vec3Type);
		PyModule_AddObject(module_glm, "u8vec3", (PyObject *)&hu8vec3Type);
		Py_INCREF(&hu8vec4Type);
		PyModule_AddObject(module_glm, "u8vec4", (PyObject *)&hu8vec4Type);

		Py_INCREF(&hu16vec1Type);
		PyModule_AddObject(module_glm, "u16vec1", (PyObject *)&hu16vec1Type);
		Py_INCREF(&hu16vec2Type);
		PyModule_AddObject(module_glm, "u16vec2", (PyObject *)&hu16vec2Type);
		Py_INCREF(&hu16vec3Type);
		PyModule_AddObject(module_glm, "u16vec3", (PyObject *)&hu16vec3Type);
		Py_INCREF(&hu16vec4Type);
		PyModule_AddObject(module_glm, "u16vec4", (PyObject *)&hu16vec4Type);

		Py_INCREF(&huvec1Type);
		PyModule_AddObject(module_glm, "u32vec1", (PyObject *)&huvec1Type);
		Py_INCREF(&huvec2Type);
		PyModule_AddObject(module_glm, "u32vec2", (PyObject *)&huvec2Type);
		Py_INCREF(&huvec3Type);
		PyModule_AddObject(module_glm, "u32vec3", (PyObject *)&huvec3Type);
		Py_INCREF(&huvec4Type);
		PyModule_AddObject(module_glm, "u32vec4", (PyObject *)&huvec4Type);

		Py_INCREF(&huvec1Type);
		PyModule_AddObject(module_glm, "uvec1", (PyObject *)&huvec1Type);
		Py_INCREF(&huvec2Type);
		PyModule_AddObject(module_glm, "uvec2", (PyObject *)&huvec2Type);
		Py_INCREF(&huvec3Type);
		PyModule_AddObject(module_glm, "uvec3", (PyObject *)&huvec3Type);
		Py_INCREF(&huvec4Type);
		PyModule_AddObject(module_glm, "uvec4", (PyObject *)&huvec4Type);
		
		Py_INCREF(&hu64vec1Type);
		PyModule_AddObject(module_glm, "u64vec1", (PyObject *)&hu64vec1Type);
		Py_INCREF(&hu64vec2Type);
		PyModule_AddObject(module_glm, "u64vec2", (PyObject *)&hu64vec2Type);
		Py_INCREF(&hu64vec3Type);
		PyModule_AddObject(module_glm, "u64vec3", (PyObject *)&hu64vec3Type);
		Py_INCREF(&hu64vec4Type);
		PyModule_AddObject(module_glm, "u64vec4", (PyObject *)&hu64vec4Type);

		Py_INCREF(&hbvec1Type);
		PyModule_AddObject(module_glm, "bvec1", (PyObject *)&hbvec1Type);
		Py_INCREF(&hbvec2Type);
		PyModule_AddObject(module_glm, "bvec2", (PyObject *)&hbvec2Type);
		Py_INCREF(&hbvec3Type);
		PyModule_AddObject(module_glm, "bvec3", (PyObject *)&hbvec3Type);
		Py_INCREF(&hbvec4Type);
		PyModule_AddObject(module_glm, "bvec4", (PyObject *)&hbvec4Type);

		PyGLM_VERSION_STRING = PyUnicode_FromString("PyGLM (" PyGLM_BUILD_STRING ") version " PyGLM_VERSION);
		Py_INCREF(PyGLM_VERSION_STRING);
		PyModule_AddObject(module_glm, "version", PyGLM_VERSION_STRING);

		PyGLM_LICENSE_STRING = PyUnicode_FromString(PyGLM_LICENSE);
		Py_INCREF(PyGLM_LICENSE_STRING);
		PyModule_AddObject(module_glm, "license", PyGLM_LICENSE_STRING);

		return module_glm;
	}
}
#if GLM_COMPILER & GLM_COMPILER_VC
#pragma warning(pop)
#elif GLM_COMPILER & GLM_COMPILER_GCC
#pragma GCC diagnostic pop
#elif GLM_COMPILER & GLM_COMPILER_CLANG
#pragma clang diagnostic pop
#endif