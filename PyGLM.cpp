#define PyGLM_NO_FUNCTIONS 1
#define PyGLM_NO_ITER_TYPECHECKING 2

#define PyGLM_DEFAULT 0
#define PyGLM_FAST PyGLM_NO_ITER_TYPECHECKING
#define PyGLM_MINIMAL PyGLM_NO_FUNCTIONS | PyGLM_NO_ITER_TYPECHECKING

#define PyGLM_BUILD PyGLM_DEFAULT

#include <Python.h>
#include "structmember.h"

#include <cstdlib>
#include <type_traits>
#include <stdint.h>

#define GLM_FORCE_CTOR_INIT

#include <glm/glm.hpp>

#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/matrix_integer.hpp>

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)

// Stable extensions
#include <glm/ext/matrix_clip_space.hpp>
#include <glm/ext/matrix_common.hpp>
#include <glm/ext/matrix_projection.hpp>
#include <glm/ext/matrix_relational.hpp>
#include <glm/ext/matrix_transform.hpp>
#include <glm/ext/quaternion_common.hpp>
#include <glm/ext/quaternion_exponential.hpp>
#include <glm/ext/quaternion_geometric.hpp>
#include <glm/ext/quaternion_relational.hpp>
#include <glm/ext/quaternion_transform.hpp>
#include <glm/ext/quaternion_trigonometric.hpp>
#include <glm/ext/scalar_common.hpp>
#include <glm/ext/scalar_constants.hpp>
#include <glm/ext/scalar_relational.hpp>
#include <glm/ext/scalar_ulp.hpp>
#include <glm/ext/vector_common.hpp>
#include <glm/ext/vector_relational.hpp>
#include <glm/ext/vector_ulp.hpp>

// Recommended extensions
#include <glm/gtc/color_space.hpp>
#include <glm/gtc/constants.hpp>
#include <glm/gtc/epsilon.hpp>
#include <glm/gtc/integer.hpp>
#include <glm/gtc/matrix_access.hpp>
#include <glm/gtc/matrix_inverse.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/noise.hpp>
#include <glm/gtc/packing.hpp>
#include <glm/gtc/random.hpp>
#include <glm/gtc/reciprocal.hpp>
#include <glm/gtc/round.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/ulp.hpp>

#endif

//TYPES

#define UNBRACKET(...) __VA_ARGS__

// type definitions
#pragma region type definitions
template<int L, typename T>
struct vec {
	PyObject_HEAD
	glm::vec<L, T> super_type;
};

template<int L, typename T>
struct vecIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	vec<L, T>* sequence;
};

template<int L, typename T>
struct mvec {
	PyObject_HEAD
		glm::vec<L, T>* super_type;
	PyObject* master;
};

template<int L, typename T>
struct mvecIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	mvec<L, T>* sequence;
};

template<int C, int R, typename T>
struct mat {
	PyObject_HEAD
		glm::mat<C, R, T> super_type;
};

template<int C, int R, typename T>
struct matIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	mat<C, R, T>* sequence;
};

template<typename T>
struct qua {
	PyObject_HEAD
		glm::qua<T> super_type;
};

template<typename T>
struct quaIter {
	PyObject_VAR_HEAD
		glm::length_t seq_index;
	qua<T>* sequence;
};
#pragma endregion

// forward declarations
#pragma region forward declarations
#pragma region vec
template<int L, typename T>
static int vec_getbuffer(vec<L, T>* self, Py_buffer* view, int flags);

void vec_releasebuffer(PyObject* self, Py_buffer* view);

template<int L>
static Py_ssize_t vec_len(PyObject* self);

template<typename T>
static PyObject* vec1_sq_item(vec<1, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec2_sq_item(vec<2, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec3_sq_item(vec<3, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* vec4_sq_item(vec<4, T> * self, Py_ssize_t index);

template<typename T>
static int vec1_sq_ass_item(vec<1, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec2_sq_ass_item(vec<2, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec3_sq_ass_item(vec<3, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int vec4_sq_ass_item(vec<4, T> * self, Py_ssize_t index, PyObject * value);

template<int L, typename T>
static int vec_contains(vec<L, T> * self, PyObject * value);

template<int L, typename T>
static PyObject * vec_add(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_sub(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_mul(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_mod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_divmod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * vec_neg(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_pos(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_abs(vec<L, T> *obj);

template<int L, typename T>
static PyObject * vec_iadd(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_isub(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_imul(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_imod(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_ipow(vec<L, T>* self, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * vec_floordiv(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_div(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * vec_ifloordiv(vec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * vec_idiv(vec<L, T>* self, PyObject *obj);

static void vec_dealloc(PyObject* self);

template<typename T>
static PyObject* vec1_str(vec<1, T>* self);
template<typename T>
static PyObject* vec2_str(vec<2, T>* self);
template<typename T>
static PyObject* vec3_str(vec<3, T>* self);
template<typename T>
static PyObject* vec4_str(vec<4, T>* self);

template<int L, typename T>
static PyObject* vec_getattr(PyObject* obj, PyObject* name);

template<int L, typename T>
static PyObject* vec_richcompare(vec<L, T>* self, PyObject* other, int comp_type);

template<int L, typename T>
static PyObject* vec_geniter(vec<L, T>* self);

template<typename T>
static int vec1_init(vec<1, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec2_init(vec<2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec3_init(vec<3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int vec4_init(vec<4, T> *self, PyObject *args, PyObject *kwds);

template<int L, typename T>
static PyObject* vec_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<int L, typename T>
static void vecIter_dealloc(vecIter<L, T> *rgstate);

template<typename T>
static PyObject* vec1Iter_next(vecIter<1, T> *rgstate);
template<typename T>
static PyObject* vec2Iter_next(vecIter<2, T> *rgstate);
template<typename T>
static PyObject* vec3Iter_next(vecIter<3, T> *rgstate);
template<typename T>
static PyObject* vec4Iter_next(vecIter<4, T> *rgstate);

template<int L, typename T>
static PyObject* vecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMemberDef hfvec1_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<1, float>), super_type.x), 0, (char*)"vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec1NumMethods = {
	(binaryfunc)vec_add<1, float>, //nb_add
	(binaryfunc)vec_sub<1, float>, //nb_subtract
	(binaryfunc)vec_mul<1, float>, //nb_multiply
	(binaryfunc)vec_mod<1, float>, //nb_remainder
	(binaryfunc)vec_divmod<1, float>, //nb_divmod
	(ternaryfunc)vec_pow<1, float>, //nb_power
	(unaryfunc)vec_neg<1, float>, //nb_negative
	(unaryfunc)vec_pos<1, float>, //nb_positive
	(unaryfunc)vec_abs<1, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<1, float>, //nb_inplace_add
	(binaryfunc)vec_isub<1, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<1, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<1, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<1, float>, //nb_floor_divide
	(binaryfunc)vec_div<1, float>,
	(binaryfunc)vec_ifloordiv<1, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::vec1",             /* tp_name */
	sizeof(vec<1, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<float>,                         /* tp_repr */
	&hfvec1NumMethods,             /* tp_as_number */
	&hfvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hfvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, float>,                 /* tp_new */
};
static PyTypeObject hfvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec1Iter",             /* tp_name */
	sizeof(vecIter<1, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, float>,                 /* tp_new */
};

static PyMemberDef hfvec2_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<2, float>), super_type.x), 0, (char*)"vec2.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<2, float>), super_type.y), 0, (char*)"vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec2NumMethods = {
	(binaryfunc)vec_add<2, float>, //nb_add
	(binaryfunc)vec_sub<2, float>, //nb_subtract
	(binaryfunc)vec_mul<2, float>, //nb_multiply
	(binaryfunc)vec_mod<2, float>, //nb_remainder
	(binaryfunc)vec_divmod<2, float>, //nb_divmod
	(ternaryfunc)vec_pow<2, float>, //nb_power
	(unaryfunc)vec_neg<2, float>, //nb_negative
	(unaryfunc)vec_pos<2, float>, //nb_positive
	(unaryfunc)vec_abs<2, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<2, float>, //nb_inplace_add
	(binaryfunc)vec_isub<2, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<2, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<2, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<2, float>, //nb_floor_divide
	(binaryfunc)vec_div<2, float>,
	(binaryfunc)vec_ifloordiv<2, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::vec2",             /* tp_name */
	sizeof(vec<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<float>,                         /* tp_repr */
	&hfvec2NumMethods,             /* tp_as_number */
	&hfvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hfvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, float>,                 /* tp_new */
};
static PyTypeObject hfvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec2Iter",             /* tp_name */
	sizeof(vecIter<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, float>,                 /* tp_new */
};

static PyMemberDef hfvec3_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.x), 0, (char*)"vec3.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.y), 0, (char*)"vec3.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(vec<3, float>), super_type.z), 0, (char*)"vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec3NumMethods = {
	(binaryfunc)vec_add<3, float>, //nb_add
	(binaryfunc)vec_sub<3, float>, //nb_subtract
	(binaryfunc)vec_mul<3, float>, //nb_multiply
	(binaryfunc)vec_mod<3, float>, //nb_remainder
	(binaryfunc)vec_divmod<3, float>, //nb_divmod
	(ternaryfunc)vec_pow<3, float>, //nb_power
	(unaryfunc)vec_neg<3, float>, //nb_negative
	(unaryfunc)vec_pos<3, float>, //nb_positive
	(unaryfunc)vec_abs<3, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<3, float>, //nb_inplace_add
	(binaryfunc)vec_isub<3, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<3, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<3, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<3, float>, //nb_floor_divide
	(binaryfunc)vec_div<3, float>,
	(binaryfunc)vec_ifloordiv<3, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::vec3",             /* tp_name */
	sizeof(vec<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<float>,                         /* tp_repr */
	&hfvec3NumMethods,             /* tp_as_number */
	&hfvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hfvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, float>,                 /* tp_new */
};
static PyTypeObject hfvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec3Iter",             /* tp_name */
	sizeof(vecIter<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, float>,                 /* tp_new */
};

static PyMemberDef hfvec4_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.x), 0, (char*)"vec4.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.y), 0, (char*)"vec4.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.z), 0, (char*)"vec4.z" },
	{ (char*)"w", T_FLOAT, offsetof(UNBRACKET(vec<4, float>), super_type.w), 0, (char*)"vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, float>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hfvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfvec4NumMethods = {
	(binaryfunc)vec_add<4, float>, //nb_add
	(binaryfunc)vec_sub<4, float>, //nb_subtract
	(binaryfunc)vec_mul<4, float>, //nb_multiply
	(binaryfunc)vec_mod<4, float>, //nb_remainder
	(binaryfunc)vec_divmod<4, float>, //nb_divmod
	(ternaryfunc)vec_pow<4, float>, //nb_power
	(unaryfunc)vec_neg<4, float>, //nb_negative
	(unaryfunc)vec_pos<4, float>, //nb_positive
	(unaryfunc)vec_abs<4, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)vec_iadd<4, float>, //nb_inplace_add
	(binaryfunc)vec_isub<4, float>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, float>, //nb_inplace_multiply
	(binaryfunc)vec_imod<4, float>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<4, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<4, float>, //nb_floor_divide
	(binaryfunc)vec_div<4, float>,
	(binaryfunc)vec_ifloordiv<4, float>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::vec4",             /* tp_name */
	sizeof(vec<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<float>,                         /* tp_repr */
	&hfvec4NumMethods,             /* tp_as_number */
	&hfvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<float>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, float>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hfvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, float>,                 /* tp_new */
};
static PyTypeObject hfvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"vec4Iter",             /* tp_name */
	sizeof(vecIter<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMemberDef hdvec1_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<1, double>), super_type.x), 0, (char*)"dvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec1NumMethods = {
	(binaryfunc)vec_add<1, double>, //nb_add
	(binaryfunc)vec_sub<1, double>, //nb_subtract
	(binaryfunc)vec_mul<1, double>, //nb_multiply
	(binaryfunc)vec_mod<1, double>, //nb_remainder
	(binaryfunc)vec_divmod<1, double>, //nb_divmod
	(ternaryfunc)vec_pow<1, double>, //nb_power
	(unaryfunc)vec_neg<1, double>, //nb_negative
	(unaryfunc)vec_pos<1, double>, //nb_positive
	(unaryfunc)vec_abs<1, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<1, double>, //nb_inplace_add
	(binaryfunc)vec_isub<1, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<1, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<1, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<1, double>, //nb_floor_divide
	(binaryfunc)vec_div<1, double>,
	(binaryfunc)vec_ifloordiv<1, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dvec1",             /* tp_name */
	sizeof(vec<1, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<double>,                         /* tp_repr */
	&hdvec1NumMethods,             /* tp_as_number */
	&hdvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hdvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, double>,                 /* tp_new */
};
static PyTypeObject hdvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec1Iter",             /* tp_name */
	sizeof(vecIter<1, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, double>,                 /* tp_new */
};

static PyMemberDef hdvec2_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<2, double>), super_type.x), 0, (char*)"dvec2.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<2, double>), super_type.y), 0, (char*)"dvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec2NumMethods = {
	(binaryfunc)vec_add<2, double>, //nb_add
	(binaryfunc)vec_sub<2, double>, //nb_subtract
	(binaryfunc)vec_mul<2, double>, //nb_multiply
	(binaryfunc)vec_mod<2, double>, //nb_remainder
	(binaryfunc)vec_divmod<2, double>, //nb_divmod
	(ternaryfunc)vec_pow<2, double>, //nb_power
	(unaryfunc)vec_neg<2, double>, //nb_negative
	(unaryfunc)vec_pos<2, double>, //nb_positive
	(unaryfunc)vec_abs<2, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<2, double>, //nb_inplace_add
	(binaryfunc)vec_isub<2, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<2, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<2, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<2, double>, //nb_floor_divide
	(binaryfunc)vec_div<2, double>,
	(binaryfunc)vec_ifloordiv<2, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dvec2",             /* tp_name */
	sizeof(vec<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<double>,                         /* tp_repr */
	&hdvec2NumMethods,             /* tp_as_number */
	&hdvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hdvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, double>,                 /* tp_new */
};
static PyTypeObject hdvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec2Iter",             /* tp_name */
	sizeof(vecIter<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, double>,                 /* tp_new */
};

static PyMemberDef hdvec3_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.x), 0, (char*)"dvec3.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.y), 0, (char*)"dvec3.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(vec<3, double>), super_type.z), 0, (char*)"dvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec3NumMethods = {
	(binaryfunc)vec_add<3, double>, //nb_add
	(binaryfunc)vec_sub<3, double>, //nb_subtract
	(binaryfunc)vec_mul<3, double>, //nb_multiply
	(binaryfunc)vec_mod<3, double>, //nb_remainder
	(binaryfunc)vec_divmod<3, double>, //nb_divmod
	(ternaryfunc)vec_pow<3, double>, //nb_power
	(unaryfunc)vec_neg<3, double>, //nb_negative
	(unaryfunc)vec_pos<3, double>, //nb_positive
	(unaryfunc)vec_abs<3, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<3, double>, //nb_inplace_add
	(binaryfunc)vec_isub<3, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<3, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<3, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<3, double>, //nb_floor_divide
	(binaryfunc)vec_div<3, double>,
	(binaryfunc)vec_ifloordiv<3, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dvec3",             /* tp_name */
	sizeof(vec<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<double>,                         /* tp_repr */
	&hdvec3NumMethods,             /* tp_as_number */
	&hdvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hdvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, double>,                 /* tp_new */
};
static PyTypeObject hdvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec3Iter",             /* tp_name */
	sizeof(vecIter<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, double>,                 /* tp_new */
};

static PyMemberDef hdvec4_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.x), 0, (char*)"dvec4.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.y), 0, (char*)"dvec4.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.z), 0, (char*)"dvec4.z" },
	{ (char*)"w", T_DOUBLE, offsetof(UNBRACKET(vec<4, double>), super_type.w), 0, (char*)"dvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, double>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hdvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdvec4NumMethods = {
	(binaryfunc)vec_add<4, double>, //nb_add
	(binaryfunc)vec_sub<4, double>, //nb_subtract
	(binaryfunc)vec_mul<4, double>, //nb_multiply
	(binaryfunc)vec_mod<4, double>, //nb_remainder
	(binaryfunc)vec_divmod<4, double>, //nb_divmod
	(ternaryfunc)vec_pow<4, double>, //nb_power
	(unaryfunc)vec_neg<4, double>, //nb_negative
	(unaryfunc)vec_pos<4, double>, //nb_positive
	(unaryfunc)vec_abs<4, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)vec_iadd<4, double>, //nb_inplace_add
	(binaryfunc)vec_isub<4, double>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, double>, //nb_inplace_multiply
	(binaryfunc)vec_imod<4, double>, //nb_inplace_remainder
	(ternaryfunc)vec_ipow<4, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)vec_floordiv<4, double>, //nb_floor_divide
	(binaryfunc)vec_div<4, double>,
	(binaryfunc)vec_ifloordiv<4, double>, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dvec4",             /* tp_name */
	sizeof(vec<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<double>,                         /* tp_repr */
	&hdvec4NumMethods,             /* tp_as_number */
	&hdvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<double>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, double>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hdvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, double>,                 /* tp_new */
};
static PyTypeObject hdvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dvec4Iter",             /* tp_name */
	sizeof(vecIter<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region int8
static PyMemberDef hi8vec1_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<1, glm::i8>), super_type.x), 0, (char*)"i8vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i8>, //nb_add
	(binaryfunc)vec_sub<1, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i8vec1",             /* tp_name */
	sizeof(vec<1, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::i8>,                         /* tp_repr */
	&hi8vec1NumMethods,             /* tp_as_number */
	&hi8vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi8vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec2_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<2, glm::i8>), super_type.x), 0, (char*)"i8vec2.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<2, glm::i8>), super_type.y), 0, (char*)"i8vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i8>, //nb_add
	(binaryfunc)vec_sub<2, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i8vec2",             /* tp_name */
	sizeof(vec<2, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::i8>,                         /* tp_repr */
	&hi8vec2NumMethods,             /* tp_as_number */
	&hi8vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi8vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec3_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.x), 0, (char*)"i8vec3.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.y), 0, (char*)"i8vec3.y" },
	{ (char*)"z", T_BYTE, offsetof(UNBRACKET(vec<3, glm::i8>), super_type.z), 0, (char*)"i8vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i8>, //nb_add
	(binaryfunc)vec_sub<3, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i8vec3",             /* tp_name */
	sizeof(vec<3, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::i8>,                         /* tp_repr */
	&hi8vec3NumMethods,             /* tp_as_number */
	&hi8vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi8vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i8>,                 /* tp_new */
};

static PyMemberDef hi8vec4_members[] = {
	{ (char*)"x", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.x), 0, (char*)"i8vec4.x" },
	{ (char*)"y", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.y), 0, (char*)"i8vec4.y" },
	{ (char*)"z", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.z), 0, (char*)"i8vec4.z" },
	{ (char*)"w", T_BYTE, offsetof(UNBRACKET(vec<4, glm::i8>), super_type.w), 0, (char*)"i8vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi8vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi8vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i8>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi8vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i8>, //nb_add
	(binaryfunc)vec_sub<4, glm::i8>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i8>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i8>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i8>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi8vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i8vec4",             /* tp_name */
	sizeof(vec<4, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::i8>,                         /* tp_repr */
	&hi8vec4NumMethods,             /* tp_as_number */
	&hi8vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i8>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi8vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i8vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 8 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi8vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i8>,                 /* tp_new */
};
static PyTypeObject hi8vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i8vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i8vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i8>,                 /* tp_new */
};
#pragma endregion
#pragma region int16
static PyMemberDef hi16vec1_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<1, glm::i16>), super_type.x), 0, (char*)"i16vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i16>, //nb_add
	(binaryfunc)vec_sub<1, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i16vec1",             /* tp_name */
	sizeof(vec<1, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::i16>,                         /* tp_repr */
	&hi16vec1NumMethods,             /* tp_as_number */
	&hi16vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi16vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec2_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<2, glm::i16>), super_type.x), 0, (char*)"i16vec2.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<2, glm::i16>), super_type.y), 0, (char*)"i16vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i16>, //nb_add
	(binaryfunc)vec_sub<2, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i16vec2",             /* tp_name */
	sizeof(vec<2, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::i16>,                         /* tp_repr */
	&hi16vec2NumMethods,             /* tp_as_number */
	&hi16vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi16vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec3_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.x), 0, (char*)"i16vec3.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.y), 0, (char*)"i16vec3.y" },
	{ (char*)"z", T_SHORT, offsetof(UNBRACKET(vec<3, glm::i16>), super_type.z), 0, (char*)"i16vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i16>, //nb_add
	(binaryfunc)vec_sub<3, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i16vec3",             /* tp_name */
	sizeof(vec<3, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::i16>,                         /* tp_repr */
	&hi16vec3NumMethods,             /* tp_as_number */
	&hi16vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi16vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i16>,                 /* tp_new */
};

static PyMemberDef hi16vec4_members[] = {
	{ (char*)"x", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.x), 0, (char*)"i16vec4.x" },
	{ (char*)"y", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.y), 0, (char*)"i16vec4.y" },
	{ (char*)"z", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.z), 0, (char*)"i16vec4.z" },
	{ (char*)"w", T_SHORT, offsetof(UNBRACKET(vec<4, glm::i16>), super_type.w), 0, (char*)"i16vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi16vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi16vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i16>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi16vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i16>, //nb_add
	(binaryfunc)vec_sub<4, glm::i16>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i16>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i16>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i16>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi16vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i16vec4",             /* tp_name */
	sizeof(vec<4, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::i16>,                         /* tp_repr */
	&hi16vec4NumMethods,             /* tp_as_number */
	&hi16vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i16>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi16vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i16vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 16 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi16vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i16>,                 /* tp_new */
};
static PyTypeObject hi16vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i16vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i16vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i16>,                 /* tp_new */
};
#pragma endregion
#pragma region int32
static PyMemberDef hivec1_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<1, glm::i32>), super_type.x), 0, (char*)"ivec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i32>, //nb_add
	(binaryfunc)vec_sub<1, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::ivec1",             /* tp_name */
	sizeof(vec<1, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::i32>,                         /* tp_repr */
	&hivec1NumMethods,             /* tp_as_number */
	&hivec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hivec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec2_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<2, glm::i32>), super_type.x), 0, (char*)"ivec2.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<2, glm::i32>), super_type.y), 0, (char*)"ivec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i32>, //nb_add
	(binaryfunc)vec_sub<2, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::ivec2",             /* tp_name */
	sizeof(vec<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::i32>,                         /* tp_repr */
	&hivec2NumMethods,             /* tp_as_number */
	&hivec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hivec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec3_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.x), 0, (char*)"ivec3.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.y), 0, (char*)"ivec3.y" },
	{ (char*)"z", T_INT, offsetof(UNBRACKET(vec<3, glm::i32>), super_type.z), 0, (char*)"ivec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i32>, //nb_add
	(binaryfunc)vec_sub<3, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::ivec3",             /* tp_name */
	sizeof(vec<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::i32>,                         /* tp_repr */
	&hivec3NumMethods,             /* tp_as_number */
	&hivec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hivec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i32>,                 /* tp_new */
};

static PyMemberDef hivec4_members[] = {
	{ (char*)"x", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.x), 0, (char*)"ivec4.x" },
	{ (char*)"y", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.y), 0, (char*)"ivec4.y" },
	{ (char*)"z", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.z), 0, (char*)"ivec4.z" },
	{ (char*)"w", T_INT, offsetof(UNBRACKET(vec<4, glm::i32>), super_type.w), 0, (char*)"ivec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hivec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hivec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hivec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i32>, //nb_add
	(binaryfunc)vec_sub<4, glm::i32>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i32>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i32>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i32>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hivec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::ivec4",             /* tp_name */
	sizeof(vec<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::i32>,                         /* tp_repr */
	&hivec4NumMethods,             /* tp_as_number */
	&hivec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i32>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hivec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"ivec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hivec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i32>,                 /* tp_new */
};
static PyTypeObject hivec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"ivec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"ivec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region int64
static PyMemberDef hi64vec1_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<1, glm::i64>), super_type.x), 0, (char*)"i64vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::i64>, //nb_add
	(binaryfunc)vec_sub<1, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<1, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<1, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<1, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i64vec1",             /* tp_name */
	sizeof(vec<1, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::i64>,                         /* tp_repr */
	&hi64vec1NumMethods,             /* tp_as_number */
	&hi64vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi64vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec2_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<2, glm::i64>), super_type.x), 0, (char*)"i64vec2.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<2, glm::i64>), super_type.y), 0, (char*)"i64vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::i64>, //nb_add
	(binaryfunc)vec_sub<2, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<2, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<2, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<2, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i64vec2",             /* tp_name */
	sizeof(vec<2, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::i64>,                         /* tp_repr */
	&hi64vec2NumMethods,             /* tp_as_number */
	&hi64vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi64vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec3_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.x), 0, (char*)"i64vec3.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.y), 0, (char*)"i64vec3.y" },
	{ (char*)"z", T_LONGLONG, offsetof(UNBRACKET(vec<3, glm::i64>), super_type.z), 0, (char*)"i64vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::i64>, //nb_add
	(binaryfunc)vec_sub<3, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<3, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<3, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<3, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i64vec3",             /* tp_name */
	sizeof(vec<3, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::i64>,                         /* tp_repr */
	&hi64vec3NumMethods,             /* tp_as_number */
	&hi64vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi64vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::i64>,                 /* tp_new */
};

static PyMemberDef hi64vec4_members[] = {
	{ (char*)"x", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.x), 0, (char*)"i64vec4.x" },
	{ (char*)"y", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.y), 0, (char*)"i64vec4.y" },
	{ (char*)"z", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.z), 0, (char*)"i64vec4.z" },
	{ (char*)"w", T_LONGLONG, offsetof(UNBRACKET(vec<4, glm::i64>), super_type.w), 0, (char*)"i64vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hi64vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::i64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hi64vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::i64>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::i64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::i64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hi64vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::i64>, //nb_add
	(binaryfunc)vec_sub<4, glm::i64>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::i64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)vec_neg<4, glm::i64>, //nb_negative
	(unaryfunc)vec_pos<4, glm::i64>, //nb_positive
	(unaryfunc)vec_abs<4, glm::i64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::i64>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::i64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::i64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::i64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::i64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hi64vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::i64vec4",             /* tp_name */
	sizeof(vec<4, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::i64>,                         /* tp_repr */
	&hi64vec4NumMethods,             /* tp_as_number */
	&hi64vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::i64>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::i64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hi64vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"i64vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 64 bit integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::i64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::i64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hi64vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::i64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::i64>,                 /* tp_new */
};
static PyTypeObject hi64vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"i64vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::i64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::i64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"i64vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::i64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::i64>,                 /* tp_new */
};
#pragma endregion
#pragma region uint8
static PyMemberDef hu8vec1_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<1, glm::u8>), super_type.x), 0, (char*)"u8vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u8>, //nb_add
	(binaryfunc)vec_sub<1, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u8vec1",             /* tp_name */
	sizeof(vec<1, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::u8>,                         /* tp_repr */
	&hu8vec1NumMethods,             /* tp_as_number */
	&hu8vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu8vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec2_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<2, glm::u8>), super_type.x), 0, (char*)"u8vec2.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<2, glm::u8>), super_type.y), 0, (char*)"u8vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u8>, //nb_add
	(binaryfunc)vec_sub<2, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u8vec2",             /* tp_name */
	sizeof(vec<2, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::u8>,                         /* tp_repr */
	&hu8vec2NumMethods,             /* tp_as_number */
	&hu8vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu8vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec3_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.x), 0, (char*)"u8vec3.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.y), 0, (char*)"u8vec3.y" },
	{ (char*)"z", T_UBYTE, offsetof(UNBRACKET(vec<3, glm::u8>), super_type.z), 0, (char*)"u8vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u8>, //nb_add
	(binaryfunc)vec_sub<3, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u8vec3",             /* tp_name */
	sizeof(vec<3, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::u8>,                         /* tp_repr */
	&hu8vec3NumMethods,             /* tp_as_number */
	&hu8vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu8vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u8>,                 /* tp_new */
};

static PyMemberDef hu8vec4_members[] = {
	{ (char*)"x", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.x), 0, (char*)"u8vec4.x" },
	{ (char*)"y", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.y), 0, (char*)"u8vec4.y" },
	{ (char*)"z", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.z), 0, (char*)"u8vec4.z" },
	{ (char*)"w", T_UBYTE, offsetof(UNBRACKET(vec<4, glm::u8>), super_type.w), 0, (char*)"u8vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu8vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u8>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu8vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u8>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u8>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u8>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu8vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u8>, //nb_add
	(binaryfunc)vec_sub<4, glm::u8>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u8>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u8>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u8>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u8>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u8>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u8>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u8>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u8>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu8vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u8vec4",             /* tp_name */
	sizeof(vec<4, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::u8>,                         /* tp_repr */
	&hu8vec4NumMethods,             /* tp_as_number */
	&hu8vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u8>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u8>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu8vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u8vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 8 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u8>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u8>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu8vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u8>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u8>,                 /* tp_new */
};
static PyTypeObject hu8vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u8vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u8>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u8>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u8vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u8>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u8>,                 /* tp_new */
};
#pragma endregion
#pragma region uint16
static PyMemberDef hu16vec1_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<1, glm::u16>), super_type.x), 0, (char*)"u16vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u16>, //nb_add
	(binaryfunc)vec_sub<1, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u16vec1",             /* tp_name */
	sizeof(vec<1, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::u16>,                         /* tp_repr */
	&hu16vec1NumMethods,             /* tp_as_number */
	&hu16vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu16vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec2_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<2, glm::u16>), super_type.x), 0, (char*)"u16vec2.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<2, glm::u16>), super_type.y), 0, (char*)"u16vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u16>, //nb_add
	(binaryfunc)vec_sub<2, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u16vec2",             /* tp_name */
	sizeof(vec<2, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::u16>,                         /* tp_repr */
	&hu16vec2NumMethods,             /* tp_as_number */
	&hu16vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu16vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec3_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.x), 0, (char*)"u16vec3.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.y), 0, (char*)"u16vec3.y" },
	{ (char*)"z", T_USHORT, offsetof(UNBRACKET(vec<3, glm::u16>), super_type.z), 0, (char*)"u16vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u16>, //nb_add
	(binaryfunc)vec_sub<3, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u16vec3",             /* tp_name */
	sizeof(vec<3, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::u16>,                         /* tp_repr */
	&hu16vec3NumMethods,             /* tp_as_number */
	&hu16vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu16vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u16>,                 /* tp_new */
};

static PyMemberDef hu16vec4_members[] = {
	{ (char*)"x", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.x), 0, (char*)"u16vec4.x" },
	{ (char*)"y", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.y), 0, (char*)"u16vec4.y" },
	{ (char*)"z", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.z), 0, (char*)"u16vec4.z" },
	{ (char*)"w", T_USHORT, offsetof(UNBRACKET(vec<4, glm::u16>), super_type.w), 0, (char*)"u16vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu16vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u16>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu16vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u16>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u16>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u16>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu16vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u16>, //nb_add
	(binaryfunc)vec_sub<4, glm::u16>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u16>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u16>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u16>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u16>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u16>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u16>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u16>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u16>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu16vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u16vec4",             /* tp_name */
	sizeof(vec<4, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::u16>,                         /* tp_repr */
	&hu16vec4NumMethods,             /* tp_as_number */
	&hu16vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u16>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u16>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu16vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u16vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 16 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u16>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u16>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu16vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u16>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u16>,                 /* tp_new */
};
static PyTypeObject hu16vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u16vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u16>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u16>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u16vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u16>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u16>,                 /* tp_new */
};
#pragma endregion
#pragma region uint32
static PyMemberDef huvec1_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<1, glm::u32>), super_type.x), 0, (char*)"uvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u32>, //nb_add
	(binaryfunc)vec_sub<1, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::uvec1",             /* tp_name */
	sizeof(vec<1, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::u32>,                         /* tp_repr */
	&huvec1NumMethods,             /* tp_as_number */
	&huvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	huvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec2_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<2, glm::u32>), super_type.x), 0, (char*)"uvec2.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<2, glm::u32>), super_type.y), 0, (char*)"uvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u32>, //nb_add
	(binaryfunc)vec_sub<2, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::uvec2",             /* tp_name */
	sizeof(vec<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::u32>,                         /* tp_repr */
	&huvec2NumMethods,             /* tp_as_number */
	&huvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	huvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec3_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.x), 0, (char*)"uvec3.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.y), 0, (char*)"uvec3.y" },
	{ (char*)"z", T_UINT, offsetof(UNBRACKET(vec<3, glm::u32>), super_type.z), 0, (char*)"uvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u32>, //nb_add
	(binaryfunc)vec_sub<3, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::uvec3",             /* tp_name */
	sizeof(vec<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::u32>,                         /* tp_repr */
	&huvec3NumMethods,             /* tp_as_number */
	&huvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	huvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u32>,                 /* tp_new */
};

static PyMemberDef huvec4_members[] = {
	{ (char*)"x", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.x), 0, (char*)"uvec4.x" },
	{ (char*)"y", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.y), 0, (char*)"uvec4.y" },
	{ (char*)"z", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.z), 0, (char*)"uvec4.z" },
	{ (char*)"w", T_UINT, offsetof(UNBRACKET(vec<4, glm::u32>), super_type.w), 0, (char*)"uvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs huvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u32>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods huvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods huvec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u32>, //nb_add
	(binaryfunc)vec_sub<4, glm::u32>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u32>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u32>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject huvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::uvec4",             /* tp_name */
	sizeof(vec<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::u32>,                         /* tp_repr */
	&huvec4NumMethods,             /* tp_as_number */
	&huvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u32>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u32>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&huvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"uvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	huvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u32>,                 /* tp_new */
};
static PyTypeObject huvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"uvec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"uvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma region uint64
static PyMemberDef hu64vec1_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<1, glm::u64>), super_type.x), 0, (char*)"u64vec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec1NumMethods = {
	(binaryfunc)vec_add<1, glm::u64>, //nb_add
	(binaryfunc)vec_sub<1, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<1, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<1, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<1, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<1, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<1, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<1, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<1, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<1, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u64vec1",             /* tp_name */
	sizeof(vec<1, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<glm::u64>,                         /* tp_repr */
	&hu64vec1NumMethods,             /* tp_as_number */
	&hu64vec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu64vec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec1Iter",             /* tp_name */
	sizeof(vecIter<1, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec2_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<2, glm::u64>), super_type.x), 0, (char*)"u64vec2.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<2, glm::u64>), super_type.y), 0, (char*)"u64vec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec2NumMethods = {
	(binaryfunc)vec_add<2, glm::u64>, //nb_add
	(binaryfunc)vec_sub<2, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<2, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<2, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<2, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<2, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<2, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<2, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<2, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<2, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u64vec2",             /* tp_name */
	sizeof(vec<2, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<glm::u64>,                         /* tp_repr */
	&hu64vec2NumMethods,             /* tp_as_number */
	&hu64vec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu64vec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec2Iter",             /* tp_name */
	sizeof(vecIter<2, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec3_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.x), 0, (char*)"u64vec3.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.y), 0, (char*)"u64vec3.y" },
	{ (char*)"z", T_ULONGLONG, offsetof(UNBRACKET(vec<3, glm::u64>), super_type.z), 0, (char*)"u64vec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec3NumMethods = {
	(binaryfunc)vec_add<3, glm::u64>, //nb_add
	(binaryfunc)vec_sub<3, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<3, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<3, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<3, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<3, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<3, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<3, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<3, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<3, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u64vec3",             /* tp_name */
	sizeof(vec<3, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<glm::u64>,                         /* tp_repr */
	&hu64vec3NumMethods,             /* tp_as_number */
	&hu64vec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu64vec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec3Iter",             /* tp_name */
	sizeof(vecIter<3, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, glm::u64>,                 /* tp_new */
};

static PyMemberDef hu64vec4_members[] = {
	{ (char*)"x", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.x), 0, (char*)"u64vec4.x" },
	{ (char*)"y", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.y), 0, (char*)"u64vec4.y" },
	{ (char*)"z", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.z), 0, (char*)"u64vec4.z" },
	{ (char*)"w", T_ULONGLONG, offsetof(UNBRACKET(vec<4, glm::u64>), super_type.w), 0, (char*)"u64vec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hu64vec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, glm::u64>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hu64vec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<glm::u64>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<glm::u64>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, glm::u64>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hu64vec4NumMethods = {
	(binaryfunc)vec_add<4, glm::u64>, //nb_add
	(binaryfunc)vec_sub<4, glm::u64>, //nb_subtract
	(binaryfunc)vec_mul<4, glm::u64>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)vec_pos<4, glm::u64>, //nb_positive
	(unaryfunc)vec_abs<4, glm::u64>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)vec_iadd<4, glm::u64>, //nb_inplace_add
	(binaryfunc)vec_isub<4, glm::u64>, //nb_inplace_subtract
	(binaryfunc)vec_imul<4, glm::u64>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)vec_div<4, glm::u64>,
	0, //nb_inplace_floor_divide
	(binaryfunc)vec_idiv<4, glm::u64>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hu64vec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::u64vec4",             /* tp_name */
	sizeof(vec<4, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<glm::u64>,                         /* tp_repr */
	&hu64vec4NumMethods,             /* tp_as_number */
	&hu64vec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<glm::u64>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, glm::u64>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hu64vec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"u64vec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier 64 bit unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, glm::u64>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, glm::u64>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hu64vec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<glm::u64>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, glm::u64>,                 /* tp_new */
};
static PyTypeObject hu64vec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"u64vec4Iter",             /* tp_name */
	sizeof(vecIter<4, glm::u64>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, glm::u64>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"u64vec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<glm::u64>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, glm::u64>,                 /* tp_new */
};
#pragma endregion
#pragma region bool
static PyMemberDef hbvec1_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<1, bool>), super_type.x), 0, (char*)"bvec1.x" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec1BufferMethods = {
	(getbufferproc)vec_getbuffer<1, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec1SeqMethods = {
	(lenfunc)vec_len<1>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec1_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec1_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<1, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec1Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::bvec1",             /* tp_name */
	sizeof(vec<1, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec1_str<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec1SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec1_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<1, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec1BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec1( <vec1 compatible type(s)> )\n1 component vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<1, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<1, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hbvec1_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec1_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<1, bool>,                 /* tp_new */
};
static PyTypeObject hbvec1IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec1Iter",             /* tp_name */
	sizeof(vecIter<1, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<1, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec1 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec1Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<1, bool>,                 /* tp_new */
};

static PyMemberDef hbvec2_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<2, bool>), super_type.x), 0, (char*)"bvec2.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<2, bool>), super_type.y), 0, (char*)"bvec2.y" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec2BufferMethods = {
	(getbufferproc)vec_getbuffer<2, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec2SeqMethods = {
	(lenfunc)vec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec2_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec2_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<2, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::bvec2",             /* tp_name */
	sizeof(vec<2, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec2_str<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec2_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<2, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec2( <vec2 compatible type(s)> )\n2 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<2, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<2, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hbvec2_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec2_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<2, bool>,                 /* tp_new */
};
static PyTypeObject hbvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec2Iter",             /* tp_name */
	sizeof(vecIter<2, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<2, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec2Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<2, bool>,                 /* tp_new */
};

static PyMemberDef hbvec3_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.x), 0, (char*)"bvec3.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.y), 0, (char*)"bvec3.y" },
	{ (char*)"z", T_BOOL, offsetof(UNBRACKET(vec<3, bool>), super_type.z), 0, (char*)"bvec3.z" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec3BufferMethods = {
	(getbufferproc)vec_getbuffer<3, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec3SeqMethods = {
	(lenfunc)vec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec3_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec3_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<3, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::bvec3",             /* tp_name */
	sizeof(vec<3, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec3_str<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec3_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<3, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec3( <vec3 compatible type(s)> )\n3 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<3, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<3, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hbvec3_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec3_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<3, bool>,                 /* tp_new */
};
static PyTypeObject hbvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec3Iter",             /* tp_name */
	sizeof(vecIter<3, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<3, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec3Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<3, bool>,                 /* tp_new */
};

static PyMemberDef hbvec4_members[] = {
	{ (char*)"x", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.x), 0, (char*)"bvec4.x" },
	{ (char*)"y", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.y), 0, (char*)"bvec4.y" },
	{ (char*)"z", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.z), 0, (char*)"bvec4.z" },
	{ (char*)"w", T_BOOL, offsetof(UNBRACKET(vec<4, bool>), super_type.w), 0, (char*)"bvec4.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hbvec4BufferMethods = {
	(getbufferproc)vec_getbuffer<4, bool>,
	(releasebufferproc)vec_releasebuffer,
};
static PySequenceMethods hbvec4SeqMethods = {
	(lenfunc)vec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)vec4_sq_item<bool>, // sq_item
	0,
	(ssizeobjargproc)vec4_sq_ass_item<bool>, // sq_ass_item
	0,
	(objobjproc)vec_contains<4, bool>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyTypeObject hbvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::bvec4",             /* tp_name */
	sizeof(vec<4, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vec_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)vec4_str<bool>,                         /* tp_repr */
	0,             /* tp_as_number */
	&hbvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)vec4_str<bool>,                         /* tp_str */
	(getattrofunc)vec_getattr<4, bool>,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hbvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"bvec4( <vec4 compatible type(s)> )\n4 components vector of high qualifier boolean values.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)vec_richcompare<4, bool>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)vec_geniter<4, bool>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	hbvec4_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)vec4_init<bool>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vec_new<4, bool>,                 /* tp_new */
};
static PyTypeObject hbvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"bvec4Iter",             /* tp_name */
	sizeof(vecIter<4, bool>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)vecIter_dealloc<4, bool>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"bvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)vec4Iter_next<bool>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)vecIter_new<4, bool>,                 /* tp_new */
};
#pragma endregion

#pragma endregion
#pragma region mvec
template<int L, typename T>
static int mvec_getbuffer(mvec<L, T>* self, Py_buffer* view, int flags);

void mvec_releasebuffer(PyObject* self, Py_buffer* view);

template<int L>
static Py_ssize_t mvec_len(PyObject* self);

template<typename T>
static PyObject* mvec2_sq_item(mvec<2, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* mvec3_sq_item(mvec<3, T> * self, Py_ssize_t index);
template<typename T>
static PyObject* mvec4_sq_item(mvec<4, T> * self, Py_ssize_t index);

template<typename T>
static int mvec2_sq_ass_item(mvec<2, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int mvec3_sq_ass_item(mvec<3, T> * self, Py_ssize_t index, PyObject * value);
template<typename T>
static int mvec4_sq_ass_item(mvec<4, T> * self, Py_ssize_t index, PyObject * value);

template<int L, typename T>
static int mvec_contains(mvec<L, T> * self, PyObject * value);

template<int L, typename T>
static PyObject * mvec_add(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_sub(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_mul(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_mod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_divmod(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * mvec_neg(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_pos(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_abs(mvec<L, T> *obj);

template<int L, typename T>
static PyObject * mvec_iadd(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_isub(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_imul(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_imod(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_ipow(mvec<L, T>* self, PyObject * obj2, PyObject * obj3);

template<int L, typename T>
static PyObject * mvec_floordiv(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_div(PyObject *obj1, PyObject *obj2);

template<int L, typename T>
static PyObject * mvec_ifloordiv(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static PyObject * mvec_idiv(mvec<L, T>* self, PyObject *obj);

template<int L, typename T>
static void mvec_dealloc(PyObject* self);

template<typename T>
static PyObject* mvec2_str(mvec<2, T>* self);
template<typename T>
static PyObject* mvec3_str(mvec<3, T>* self);
template<typename T>
static PyObject* mvec4_str(mvec<4, T>* self);

template<int L, typename T>
static PyObject* mvec_getattr(PyObject* obj, PyObject* name);

template<typename T>
static int mvec2_setattr(mvec<2, T>* obj, PyObject* name, PyObject* value);
template<typename T>
static int mvec3_setattr(mvec<3, T>* obj, PyObject* name, PyObject* value);
template<typename T>
static int mvec4_setattr(mvec<4, T>* obj, PyObject* name, PyObject* value);

template<int L, typename T>
static PyObject* mvec_richcompare(mvec<L, T>* self, PyObject* other, int comp_type);

template<int L, typename T>
static PyObject* mvec_geniter(mvec<L, T>* self);

template<int L, typename T>
static void mvecIter_dealloc(mvecIter<L, T> *rgstate);

template<typename T>
static PyObject* mvec2Iter_next(mvecIter<2, T> *rgstate);
template<typename T>
static PyObject* mvec3Iter_next(mvecIter<3, T> *rgstate);
template<typename T>
static PyObject* mvec4Iter_next(mvecIter<4, T> *rgstate);

template<int L, typename T>
static PyObject* mvecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyBufferProcs hfmvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec2NumMethods = {
	(binaryfunc)mvec_add<2, float>, //nb_add
	(binaryfunc)mvec_sub<2, float>, //nb_subtract
	(binaryfunc)mvec_mul<2, float>, //nb_multiply
	(binaryfunc)mvec_mod<2, float>, //nb_remainder
	(binaryfunc)mvec_divmod<2, float>, //nb_divmod
	(ternaryfunc)mvec_pow<2, float>, //nb_power
	(unaryfunc)mvec_neg<2, float>, //nb_negative
	(unaryfunc)mvec_pos<2, float>, //nb_positive
	(unaryfunc)mvec_abs<2, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<2, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<2, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<2, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<2, float>, //nb_floor_divide
	(binaryfunc)mvec_div<2, float>,
	(binaryfunc)mvec_ifloordiv<2, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mvec2",             /* tp_name */
	sizeof(mvec<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<float>,                         /* tp_repr */
	&hfmvec2NumMethods,             /* tp_as_number */
	&hfmvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, float>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<float>,                         /* tp_setattro */
	&hfmvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, float>,                 /* tp_new */
};

static PyBufferProcs hfmvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec3NumMethods = {
	(binaryfunc)mvec_add<3, float>, //nb_add
	(binaryfunc)mvec_sub<3, float>, //nb_subtract
	(binaryfunc)mvec_mul<3, float>, //nb_multiply
	(binaryfunc)mvec_mod<3, float>, //nb_remainder
	(binaryfunc)mvec_divmod<3, float>, //nb_divmod
	(ternaryfunc)mvec_pow<3, float>, //nb_power
	(unaryfunc)mvec_neg<3, float>, //nb_negative
	(unaryfunc)mvec_pos<3, float>, //nb_positive
	(unaryfunc)mvec_abs<3, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<3, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<3, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<3, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<3, float>, //nb_floor_divide
	(binaryfunc)mvec_div<3, float>,
	(binaryfunc)mvec_ifloordiv<3, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mvec3",             /* tp_name */
	sizeof(mvec<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<float>,                         /* tp_repr */
	&hfmvec3NumMethods,             /* tp_as_number */
	&hfmvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, float>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<float>,                         /* tp_setattro */
	&hfmvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, float>,                 /* tp_new */
};

static PyBufferProcs hfmvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, float>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hfmvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfmvec4NumMethods = {
	(binaryfunc)mvec_add<4, float>, //nb_add
	(binaryfunc)mvec_sub<4, float>, //nb_subtract
	(binaryfunc)mvec_mul<4, float>, //nb_multiply
	(binaryfunc)mvec_mod<4, float>, //nb_remainder
	(binaryfunc)mvec_divmod<4, float>, //nb_divmod
	(ternaryfunc)mvec_pow<4, float>, //nb_power
	(unaryfunc)mvec_neg<4, float>, //nb_negative
	(unaryfunc)mvec_pos<4, float>, //nb_positive
	(unaryfunc)mvec_abs<4, float>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mvec_iadd<4, float>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, float>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, float>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<4, float>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<4, float>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<4, float>, //nb_floor_divide
	(binaryfunc)mvec_div<4, float>,
	(binaryfunc)mvec_ifloordiv<4, float>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mvec4",             /* tp_name */
	sizeof(mvec<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<float>,                         /* tp_repr */
	&hfmvec4NumMethods,             /* tp_as_number */
	&hfmvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<float>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, float>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<float>,                         /* tp_setattro */
	&hfmvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier float numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hfmvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyBufferProcs hdmvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec2NumMethods = {
	(binaryfunc)mvec_add<2, double>, //nb_add
	(binaryfunc)mvec_sub<2, double>, //nb_subtract
	(binaryfunc)mvec_mul<2, double>, //nb_multiply
	(binaryfunc)mvec_mod<2, double>, //nb_remainder
	(binaryfunc)mvec_divmod<2, double>, //nb_divmod
	(ternaryfunc)mvec_pow<2, double>, //nb_power
	(unaryfunc)mvec_neg<2, double>, //nb_negative
	(unaryfunc)mvec_pos<2, double>, //nb_positive
	(unaryfunc)mvec_abs<2, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<2, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<2, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<2, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<2, double>, //nb_floor_divide
	(binaryfunc)mvec_div<2, double>,
	(binaryfunc)mvec_ifloordiv<2, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmvec2",             /* tp_name */
	sizeof(mvec<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<double>,                         /* tp_repr */
	&hdmvec2NumMethods,             /* tp_as_number */
	&hdmvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, double>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<double>,                         /* tp_setattro */
	&hdmvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, double>,                 /* tp_new */
};

static PyBufferProcs hdmvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec3NumMethods = {
	(binaryfunc)mvec_add<3, double>, //nb_add
	(binaryfunc)mvec_sub<3, double>, //nb_subtract
	(binaryfunc)mvec_mul<3, double>, //nb_multiply
	(binaryfunc)mvec_mod<3, double>, //nb_remainder
	(binaryfunc)mvec_divmod<3, double>, //nb_divmod
	(ternaryfunc)mvec_pow<3, double>, //nb_power
	(unaryfunc)mvec_neg<3, double>, //nb_negative
	(unaryfunc)mvec_pos<3, double>, //nb_positive
	(unaryfunc)mvec_abs<3, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<3, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<3, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<3, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<3, double>, //nb_floor_divide
	(binaryfunc)mvec_div<3, double>,
	(binaryfunc)mvec_ifloordiv<3, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmvec3",             /* tp_name */
	sizeof(mvec<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<double>,                         /* tp_repr */
	&hdmvec3NumMethods,             /* tp_as_number */
	&hdmvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, double>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<double>,                         /* tp_setattro */
	&hdmvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, double>,                 /* tp_new */
};

static PyBufferProcs hdmvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, double>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods hdmvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdmvec4NumMethods = {
	(binaryfunc)mvec_add<4, double>, //nb_add
	(binaryfunc)mvec_sub<4, double>, //nb_subtract
	(binaryfunc)mvec_mul<4, double>, //nb_multiply
	(binaryfunc)mvec_mod<4, double>, //nb_remainder
	(binaryfunc)mvec_divmod<4, double>, //nb_divmod
	(ternaryfunc)mvec_pow<4, double>, //nb_power
	(unaryfunc)mvec_neg<4, double>, //nb_negative
	(unaryfunc)mvec_pos<4, double>, //nb_positive
	(unaryfunc)mvec_abs<4, double>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mvec_iadd<4, double>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, double>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, double>, //nb_inplace_multiply
	(binaryfunc)mvec_imod<4, double>, //nb_inplace_remainder
	(ternaryfunc)mvec_ipow<4, double>, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	(binaryfunc)mvec_floordiv<4, double>, //nb_floor_divide
	(binaryfunc)mvec_div<4, double>,
	(binaryfunc)mvec_ifloordiv<4, double>, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmvec4",             /* tp_name */
	sizeof(mvec<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<double>,                         /* tp_repr */
	&hdmvec4NumMethods,             /* tp_as_number */
	&hdmvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<double>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, double>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<double>,                         /* tp_setattro */
	&hdmvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject hdmvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region int32
static PyBufferProcs himvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec2NumMethods = {
	(binaryfunc)mvec_add<2, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<2, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<2, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<2, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<2, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<2, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imvec2",             /* tp_name */
	sizeof(mvec<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<glm::i32>,                         /* tp_repr */
	&himvec2NumMethods,             /* tp_as_number */
	&himvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<glm::i32>,                         /* tp_setattro */
	&himvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, glm::i32>,                 /* tp_new */
};

static PyBufferProcs himvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec3NumMethods = {
	(binaryfunc)mvec_add<3, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<3, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<3, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<3, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<3, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<3, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imvec3",             /* tp_name */
	sizeof(mvec<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<glm::i32>,                         /* tp_repr */
	&himvec3NumMethods,             /* tp_as_number */
	&himvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<glm::i32>,                         /* tp_setattro */
	&himvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, glm::i32>,                 /* tp_new */
};

static PyBufferProcs himvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, glm::i32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods himvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<glm::i32>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<glm::i32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods himvec4NumMethods = {
	(binaryfunc)mvec_add<4, glm::i32>, //nb_add
	(binaryfunc)mvec_sub<4, glm::i32>, //nb_subtract
	(binaryfunc)mvec_mul<4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mvec_neg<4, glm::i32>, //nb_negative
	(unaryfunc)mvec_pos<4, glm::i32>, //nb_positive
	(unaryfunc)mvec_abs<4, glm::i32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<4, glm::i32>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imvec4",             /* tp_name */
	sizeof(mvec<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<glm::i32>,                         /* tp_repr */
	&himvec4NumMethods,             /* tp_as_number */
	&himvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<glm::i32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, glm::i32>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<glm::i32>,                         /* tp_setattro */
	&himvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject himvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region uint32
static PyBufferProcs humvec2BufferMethods = {
	(getbufferproc)mvec_getbuffer<2, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec2SeqMethods = {
	(lenfunc)mvec_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec2_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec2_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec2NumMethods = {
	(binaryfunc)mvec_add<2, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<2, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<2, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<2, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<2, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umvec2",             /* tp_name */
	sizeof(mvec<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec2_str<glm::u32>,                         /* tp_repr */
	&humvec2NumMethods,             /* tp_as_number */
	&humvec2SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec2_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<2, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec2_setattr<glm::u32>,                         /* tp_setattro */
	&humvec2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec2( <mvec2 compatible type(s)> )\n2 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec2Iter",             /* tp_name */
	sizeof(mvecIter<2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec2Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<2, glm::u32>,                 /* tp_new */
};

static PyBufferProcs humvec3BufferMethods = {
	(getbufferproc)mvec_getbuffer<3, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec3SeqMethods = {
	(lenfunc)mvec_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec3_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec3_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec3NumMethods = {
	(binaryfunc)mvec_add<3, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<3, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<3, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<3, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<3, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umvec3",             /* tp_name */
	sizeof(mvec<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec3_str<glm::u32>,                         /* tp_repr */
	&humvec3NumMethods,             /* tp_as_number */
	&humvec3SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec3_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<3, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec3_setattr<glm::u32>,                         /* tp_setattro */
	&humvec3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec3( <mvec3 compatible type(s)> )\n3 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec3Iter",             /* tp_name */
	sizeof(mvecIter<3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec3Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<3, glm::u32>,                 /* tp_new */
};

static PyBufferProcs humvec4BufferMethods = {
	(getbufferproc)mvec_getbuffer<4, glm::u32>,
	(releasebufferproc)mvec_releasebuffer,
};
static PySequenceMethods humvec4SeqMethods = {
	(lenfunc)mvec_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)mvec4_sq_item<glm::u32>, // sq_item
	0,
	(ssizeobjargproc)mvec4_sq_ass_item<glm::u32>, // sq_ass_item
	0,
	(objobjproc)mvec_contains<4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods humvec4NumMethods = {
	(binaryfunc)mvec_add<4, glm::u32>, //nb_add
	(binaryfunc)mvec_sub<4, glm::u32>, //nb_subtract
	(binaryfunc)mvec_mul<4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mvec_pos<4, glm::u32>, //nb_positive
	(unaryfunc)mvec_abs<4, glm::u32>, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_int
	(binaryfunc)mvec_iadd<4, glm::u32>, //nb_inplace_add
	(binaryfunc)mvec_isub<4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mvec_imul<4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mvec_div<4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mvec_idiv<4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humvec4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umvec4",             /* tp_name */
	sizeof(mvec<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvec_dealloc<4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mvec4_str<glm::u32>,                         /* tp_repr */
	&humvec4NumMethods,             /* tp_as_number */
	&humvec4SeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mvec4_str<glm::u32>,                         /* tp_str */
	(getattrofunc)mvec_getattr<4, glm::u32>,                         /* tp_getattro */
	(setattrofunc)mvec4_setattr<glm::u32>,                         /* tp_setattro */
	&humvec4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umvec4( <mvec4 compatible type(s)> )\n4 components mvector of high qualifier unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mvec_richcompare<4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mvec_geniter<4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	0,                 /* tp_new */
};
static PyTypeObject humvec4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umvec4Iter",             /* tp_name */
	sizeof(mvecIter<4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mvecIter_dealloc<4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umvec4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)mvec4Iter_next<glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mvecIter_new<4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma region mat
template<int C>
static PyObject* mat_length(PyObject * self, PyObject* arg);

template<int C, int R, typename T>
static int mat_getbuffer(mat<C, R, T>* self, Py_buffer* view, int flags);

void mat_releasebuffer(PyObject* self, Py_buffer* view);

template<int C>
static Py_ssize_t mat_len(PyObject* self);

template<typename T>
static PyObject* mat2x2_mp_item(mat<2, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat2x3_mp_item(mat<2, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat2x4_mp_item(mat<2, 4, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x2_mp_item(mat<3, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x3_mp_item(mat<3, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat3x4_mp_item(mat<3, 4, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x2_mp_item(mat<4, 2, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x3_mp_item(mat<4, 3, T> * self, PyObject* key);
template<typename T>
static PyObject* mat4x4_mp_item(mat<4, 4, T> * self, PyObject* key);

template<typename T>
static int mat2x2_mp_ass_item(mat<2, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat2x3_mp_ass_item(mat<2, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat2x4_mp_ass_item(mat<2, 4, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x2_mp_ass_item(mat<3, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x3_mp_ass_item(mat<3, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat3x4_mp_ass_item(mat<3, 4, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x2_mp_ass_item(mat<4, 2, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x3_mp_ass_item(mat<4, 3, T> * self, PyObject* key, PyObject * value);
template<typename T>
static int mat4x4_mp_ass_item(mat<4, 4, T> * self, PyObject* key, PyObject * value);

template<int C, int R, typename T>
static int mat_contains(mat<C, R, T> * self, PyObject * value);

template<int C, int R, typename T>
static PyObject * matsq_add(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_add(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_sub(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_sub(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_mul(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * mat_neg(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * mat_pos(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * mat_abs(mat<C, R, T> *obj);

template<int C, int R, typename T>
static PyObject * matsq_iadd(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_iadd(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * matsq_isub(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_isub(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_imul(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_div(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_div(PyObject *obj1, PyObject *obj2);

template<int C, int R, typename T>
static PyObject * matsq_idiv(mat<C, R, T>* self, PyObject *obj);

template<int C, int R, typename T>
static PyObject * mat_idiv(mat<C, R, T>* self, PyObject *obj);

static void mat_dealloc(PyObject* self);

template<typename T>
static PyObject* mat2x2_str(mat<2, 2, T>* self);
template<typename T>
static PyObject* mat2x3_str(mat<2, 3, T>* self);
template<typename T>
static PyObject* mat2x4_str(mat<2, 4, T>* self);
template<typename T>
static PyObject* mat3x2_str(mat<3, 2, T>* self);
template<typename T>
static PyObject* mat3x3_str(mat<3, 3, T>* self);
template<typename T>
static PyObject* mat3x4_str(mat<3, 4, T>* self);
template<typename T>
static PyObject* mat4x2_str(mat<4, 2, T>* self);
template<typename T>
static PyObject* mat4x3_str(mat<4, 3, T>* self);
template<typename T>
static PyObject* mat4x4_str(mat<4, 4, T>* self);

template<int C, int R, typename T>
static PyObject* mat_richcompare(mat<C, R, T>* self, PyObject* other, int comp_type);

template<int C, int R, typename T>
static PyObject* mat_geniter(mat<C, R, T>* self);

template<typename T>
static int mat2x2_init(mat<2, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat2x3_init(mat<2, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat2x4_init(mat<2, 4, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x2_init(mat<3, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x3_init(mat<3, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat3x4_init(mat<3, 4, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x2_init(mat<4, 2, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x3_init(mat<4, 3, T> *self, PyObject *args, PyObject *kwds);
template<typename T>
static int mat4x4_init(mat<4, 4, T> *self, PyObject *args, PyObject *kwds);

template<int C, int R, typename T>
static PyObject* mat_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<int C, int R, typename T>
static void matIter_dealloc(matIter<C, R, T> *rgstate);

template<int C, int R, typename T>
static PyObject* matIter_next(matIter<C, R, T> *rgstate);

template<int C, int R, typename T>
static PyObject* matIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMethodDef hfmat2x2_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x2"},
	{ NULL }
};
static PyBufferProcs hfmat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x2NumMethods = {
	(binaryfunc)matsq_add<2, 2, float>, //nb_add
	(binaryfunc)matsq_sub<2, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, float>, //nb_negative
	(unaryfunc)mat_pos<2, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<2, 2, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<2, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<2, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<2, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat2x2",             /* tp_name */
	sizeof(mat<2, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_str<float>,                         /* tp_repr */
	&hfmat2x2NumMethods,             /* tp_as_number */
	&hfmat2x2SeqMethods,                         /* tp_as_sequence */
	&hfmat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x2( <mat2x2 compatible type(s)> )\n2 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat2x3_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x3"},
	{ NULL }
};
static PyBufferProcs hfmat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, float>, //nb_add
	(binaryfunc)mat_sub<2, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, float>, //nb_negative
	(unaryfunc)mat_pos<2, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<2, 3, float>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat2x3",             /* tp_name */
	sizeof(mat<2, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_str<float>,                         /* tp_repr */
	&hfmat2x3NumMethods,             /* tp_as_number */
	&hfmat2x3SeqMethods,                         /* tp_as_sequence */
	&hfmat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x3( <mat2x3 compatible type(s)> )\n2 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat2x4_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::mat2x4"},
	{ NULL }
};
static PyBufferProcs hfmat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, float>, //nb_add
	(binaryfunc)mat_sub<2, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, float>, //nb_negative
	(unaryfunc)mat_pos<2, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<2, 4, float>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat2x4",             /* tp_name */
	sizeof(mat<2, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_str<float>,                         /* tp_repr */
	&hfmat2x4NumMethods,             /* tp_as_number */
	&hfmat2x4SeqMethods,                         /* tp_as_sequence */
	&hfmat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat2x4( <mat2x4 compatible type(s)> )\n2 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x2_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x2"},
	{ NULL }
};
static PyBufferProcs hfmat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, float>, //nb_add
	(binaryfunc)mat_sub<3, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, float>, //nb_negative
	(unaryfunc)mat_pos<3, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<3, 2, float>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat3x2",             /* tp_name */
	sizeof(mat<3, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_str<float>,                         /* tp_repr */
	&hfmat3x2NumMethods,             /* tp_as_number */
	&hfmat3x2SeqMethods,                         /* tp_as_sequence */
	&hfmat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x2( <mat3x2 compatible type(s)> )\n3 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x3_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x3"},
	{ NULL }
};
static PyBufferProcs hfmat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x3NumMethods = {
	(binaryfunc)matsq_add<3, 3, float>, //nb_add
	(binaryfunc)matsq_sub<3, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, float>, //nb_negative
	(unaryfunc)mat_pos<3, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<3, 3, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<3, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<3, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<3, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat3x3",             /* tp_name */
	sizeof(mat<3, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_str<float>,                         /* tp_repr */
	&hfmat3x3NumMethods,             /* tp_as_number */
	&hfmat3x3SeqMethods,                         /* tp_as_sequence */
	&hfmat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x3( <mat3x3 compatible type(s)> )\n3 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat3x4_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::mat3x4"},
	{ NULL }
};
static PyBufferProcs hfmat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, float>, //nb_add
	(binaryfunc)mat_sub<3, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, float>, //nb_negative
	(unaryfunc)mat_pos<3, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<3, 4, float>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat3x4",             /* tp_name */
	sizeof(mat<3, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_str<float>,                         /* tp_repr */
	&hfmat3x4NumMethods,             /* tp_as_number */
	&hfmat3x4SeqMethods,                         /* tp_as_sequence */
	&hfmat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat3x4( <mat3x4 compatible type(s)> )\n3 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x2_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x2"},
	{ NULL }
};
static PyBufferProcs hfmat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, float>, //nb_add
	(binaryfunc)mat_sub<4, 2, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, float>, //nb_negative
	(unaryfunc)mat_pos<4, 2, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<4, 2, float>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat4x2",             /* tp_name */
	sizeof(mat<4, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_str<float>,                         /* tp_repr */
	&hfmat4x2NumMethods,             /* tp_as_number */
	&hfmat4x2SeqMethods,                         /* tp_as_sequence */
	&hfmat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x2( <mat4x2 compatible type(s)> )\n4 columns of 2 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x3_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x3"},
	{ NULL }
};
static PyBufferProcs hfmat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, float>, //nb_add
	(binaryfunc)mat_sub<4, 3, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, float>, //nb_negative
	(unaryfunc)mat_pos<4, 3, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)mat_iadd<4, 3, float>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat4x3",             /* tp_name */
	sizeof(mat<4, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_str<float>,                         /* tp_repr */
	&hfmat4x3NumMethods,             /* tp_as_number */
	&hfmat4x3SeqMethods,                         /* tp_as_sequence */
	&hfmat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x3( <mat4x3 compatible type(s)> )\n4 columns of 3 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, float>,                 /* tp_new */
};

static PyMethodDef hfmat4x4_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::mat4x4"},
	{ NULL }
};
static PyBufferProcs hfmat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, float>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hfmat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hfmat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<float>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<float>, // mp_ass_subscript
};
static PyNumberMethods hfmat4x4NumMethods = {
	(binaryfunc)matsq_add<4, 4, float>, //nb_add
	(binaryfunc)matsq_sub<4, 4, float>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, float>, //nb_negative
	(unaryfunc)mat_pos<4, 4, float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)matsq_iadd<4, 4, float>, //nb_inplace_add
	(binaryfunc)matsq_isub<4, 4, float>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<4, 4, float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<4, 4, float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfmat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::mat4x4",             /* tp_name */
	sizeof(mat<4, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_str<float>,                         /* tp_repr */
	&hfmat4x4NumMethods,             /* tp_as_number */
	&hfmat4x4SeqMethods,                         /* tp_as_sequence */
	&hfmat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfmat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"mat4x4( <mat4x4 compatible type(s)> )\n4 columns of 4 components matrix of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfmat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, float>,                 /* tp_new */
};
static PyTypeObject hfmat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"mat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"mat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMethodDef hdmat2x2_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x2"},
	{ NULL }
};
static PyBufferProcs hdmat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x2NumMethods = {
	(binaryfunc)matsq_add<2, 2, double>, //nb_add
	(binaryfunc)matsq_sub<2, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, double>, //nb_negative
	(unaryfunc)mat_pos<2, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<2, 2, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<2, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<2, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<2, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat2x2",             /* tp_name */
	sizeof(mat<2, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_str<double>,                         /* tp_repr */
	&hdmat2x2NumMethods,             /* tp_as_number */
	&hdmat2x2SeqMethods,                         /* tp_as_sequence */
	&hdmat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x2( <dmat2x2 compatible type(s)> )\n2 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat2x3_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x3"},
	{ NULL }
};
static PyBufferProcs hdmat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, double>, //nb_add
	(binaryfunc)mat_sub<2, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, double>, //nb_negative
	(unaryfunc)mat_pos<2, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<2, 3, double>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat2x3",             /* tp_name */
	sizeof(mat<2, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_str<double>,                         /* tp_repr */
	&hdmat2x3NumMethods,             /* tp_as_number */
	&hdmat2x3SeqMethods,                         /* tp_as_sequence */
	&hdmat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x3( <dmat2x3 compatible type(s)> )\n2 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat2x4_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::dmat2x4"},
	{ NULL }
};
static PyBufferProcs hdmat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, double>, //nb_add
	(binaryfunc)mat_sub<2, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, double>, //nb_negative
	(unaryfunc)mat_pos<2, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<2, 4, double>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat2x4",             /* tp_name */
	sizeof(mat<2, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_str<double>,                         /* tp_repr */
	&hdmat2x4NumMethods,             /* tp_as_number */
	&hdmat2x4SeqMethods,                         /* tp_as_sequence */
	&hdmat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat2x4( <dmat2x4 compatible type(s)> )\n2 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x2_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x2"},
	{ NULL }
};
static PyBufferProcs hdmat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, double>, //nb_add
	(binaryfunc)mat_sub<3, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, double>, //nb_negative
	(unaryfunc)mat_pos<3, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<3, 2, double>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat3x2",             /* tp_name */
	sizeof(mat<3, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_str<double>,                         /* tp_repr */
	&hdmat3x2NumMethods,             /* tp_as_number */
	&hdmat3x2SeqMethods,                         /* tp_as_sequence */
	&hdmat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x2( <dmat3x2 compatible type(s)> )\n3 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x3_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x3"},
	{ NULL }
};
static PyBufferProcs hdmat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x3NumMethods = {
	(binaryfunc)matsq_add<3, 3, double>, //nb_add
	(binaryfunc)matsq_sub<3, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, double>, //nb_negative
	(unaryfunc)mat_pos<3, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<3, 3, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<3, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<3, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<3, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat3x3",             /* tp_name */
	sizeof(mat<3, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_str<double>,                         /* tp_repr */
	&hdmat3x3NumMethods,             /* tp_as_number */
	&hdmat3x3SeqMethods,                         /* tp_as_sequence */
	&hdmat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x3( <dmat3x3 compatible type(s)> )\n3 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat3x4_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::dmat3x4"},
	{ NULL }
};
static PyBufferProcs hdmat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, double>, //nb_add
	(binaryfunc)mat_sub<3, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, double>, //nb_negative
	(unaryfunc)mat_pos<3, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<3, 4, double>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat3x4",             /* tp_name */
	sizeof(mat<3, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_str<double>,                         /* tp_repr */
	&hdmat3x4NumMethods,             /* tp_as_number */
	&hdmat3x4SeqMethods,                         /* tp_as_sequence */
	&hdmat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat3x4( <dmat3x4 compatible type(s)> )\n3 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x2_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x2"},
	{ NULL }
};
static PyBufferProcs hdmat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, double>, //nb_add
	(binaryfunc)mat_sub<4, 2, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, double>, //nb_negative
	(unaryfunc)mat_pos<4, 2, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<4, 2, double>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat4x2",             /* tp_name */
	sizeof(mat<4, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_str<double>,                         /* tp_repr */
	&hdmat4x2NumMethods,             /* tp_as_number */
	&hdmat4x2SeqMethods,                         /* tp_as_sequence */
	&hdmat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x2( <dmat4x2 compatible type(s)> )\n4 columns of 2 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x3_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x3"},
	{ NULL }
};
static PyBufferProcs hdmat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, double>, //nb_add
	(binaryfunc)mat_sub<4, 3, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, double>, //nb_negative
	(unaryfunc)mat_pos<4, 3, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)mat_iadd<4, 3, double>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat4x3",             /* tp_name */
	sizeof(mat<4, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_str<double>,                         /* tp_repr */
	&hdmat4x3NumMethods,             /* tp_as_number */
	&hdmat4x3SeqMethods,                         /* tp_as_sequence */
	&hdmat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x3( <dmat4x3 compatible type(s)> )\n4 columns of 3 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, double>,                 /* tp_new */
};

static PyMethodDef hdmat4x4_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::dmat4x4"},
	{ NULL }
};
static PyBufferProcs hdmat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, double>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods hdmat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods hdmat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<double>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<double>, // mp_ass_subscript
};
static PyNumberMethods hdmat4x4NumMethods = {
	(binaryfunc)matsq_add<4, 4, double>, //nb_add
	(binaryfunc)matsq_sub<4, 4, double>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, double>, //nb_negative
	(unaryfunc)mat_pos<4, 4, double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)matsq_iadd<4, 4, double>, //nb_inplace_add
	(binaryfunc)matsq_isub<4, 4, double>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)matsq_div<4, 4, double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)matsq_idiv<4, 4, double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdmat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::dmat4x4",             /* tp_name */
	sizeof(mat<4, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_str<double>,                         /* tp_repr */
	&hdmat4x4NumMethods,             /* tp_as_number */
	&hdmat4x4SeqMethods,                         /* tp_as_sequence */
	&hdmat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdmat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dmat4x4( <dmat4x4 compatible type(s)> )\n4 columns of 4 components matrix of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdmat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, double>,                 /* tp_new */
};
static PyTypeObject hdmat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dmat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dmat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, double>,                 /* tp_new */
};
#pragma endregion
#pragma region i32
static PyMethodDef himat2x2_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x2"},
	{ NULL }
};
static PyBufferProcs himat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x2NumMethods = {
	(binaryfunc)mat_add<2, 2, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<2, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat2x2",             /* tp_name */
	sizeof(mat<2, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_str<glm::i32>,                         /* tp_repr */
	&himat2x2NumMethods,             /* tp_as_number */
	&himat2x2SeqMethods,                         /* tp_as_sequence */
	&himat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x2( <imat2x2 compatible type(s)> )\n2 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat2x3_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x3"},
	{ NULL }
};
static PyBufferProcs himat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, glm::i32>, //nb_add
	(binaryfunc)mat_sub<2, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat2x3",             /* tp_name */
	sizeof(mat<2, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_str<glm::i32>,                         /* tp_repr */
	&himat2x3NumMethods,             /* tp_as_number */
	&himat2x3SeqMethods,                         /* tp_as_sequence */
	&himat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x3( <imat2x3 compatible type(s)> )\n2 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat2x4_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::imat2x4"},
	{ NULL }
};
static PyBufferProcs himat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, glm::i32>, //nb_add
	(binaryfunc)mat_sub<2, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<2, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<2, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<2, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat2x4",             /* tp_name */
	sizeof(mat<2, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_str<glm::i32>,                         /* tp_repr */
	&himat2x4NumMethods,             /* tp_as_number */
	&himat2x4SeqMethods,                         /* tp_as_sequence */
	&himat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat2x4( <imat2x4 compatible type(s)> )\n2 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x2_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x2"},
	{ NULL }
};
static PyBufferProcs himat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, glm::i32>, //nb_add
	(binaryfunc)mat_sub<3, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat3x2",             /* tp_name */
	sizeof(mat<3, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_str<glm::i32>,                         /* tp_repr */
	&himat3x2NumMethods,             /* tp_as_number */
	&himat3x2SeqMethods,                         /* tp_as_sequence */
	&himat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x2( <imat3x2 compatible type(s)> )\n3 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x3_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x3"},
	{ NULL }
};
static PyBufferProcs himat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x3NumMethods = {
	(binaryfunc)mat_add<3, 3, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<3, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat3x3",             /* tp_name */
	sizeof(mat<3, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_str<glm::i32>,                         /* tp_repr */
	&himat3x3NumMethods,             /* tp_as_number */
	&himat3x3SeqMethods,                         /* tp_as_sequence */
	&himat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x3( <imat3x3 compatible type(s)> )\n3 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat3x4_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::imat3x4"},
	{ NULL }
};
static PyBufferProcs himat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, glm::i32>, //nb_add
	(binaryfunc)mat_sub<3, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<3, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<3, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<3, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat3x4",             /* tp_name */
	sizeof(mat<3, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_str<glm::i32>,                         /* tp_repr */
	&himat3x4NumMethods,             /* tp_as_number */
	&himat3x4SeqMethods,                         /* tp_as_sequence */
	&himat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat3x4( <imat3x4 compatible type(s)> )\n3 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x2_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x2"},
	{ NULL }
};
static PyBufferProcs himat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, glm::i32>, //nb_add
	(binaryfunc)mat_sub<4, 2, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 2, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 2, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 2, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat4x2",             /* tp_name */
	sizeof(mat<4, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_str<glm::i32>,                         /* tp_repr */
	&himat4x2NumMethods,             /* tp_as_number */
	&himat4x2SeqMethods,                         /* tp_as_sequence */
	&himat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x2( <imat4x2 compatible type(s)> )\n4 columns of 2 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x3_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x3"},
	{ NULL }
};
static PyBufferProcs himat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, glm::i32>, //nb_add
	(binaryfunc)mat_sub<4, 3, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 3, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 3, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 3, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat4x3",             /* tp_name */
	sizeof(mat<4, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_str<glm::i32>,                         /* tp_repr */
	&himat4x3NumMethods,             /* tp_as_number */
	&himat4x3SeqMethods,                         /* tp_as_sequence */
	&himat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x3( <imat4x3 compatible type(s)> )\n4 columns of 3 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, glm::i32>,                 /* tp_new */
};

static PyMethodDef himat4x4_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::imat4x4"},
	{ NULL }
};
static PyBufferProcs himat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, glm::i32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods himat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, glm::i32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods himat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<glm::i32>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<glm::i32>, // mp_ass_subscript
};
static PyNumberMethods himat4x4NumMethods = {
	(binaryfunc)mat_add<4, 4, glm::i32>, //nb_add
	(binaryfunc)matsq_sub<4, 4, glm::i32>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, glm::i32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)mat_neg<4, 4, glm::i32>, //nb_negative
	(unaryfunc)mat_pos<4, 4, glm::i32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::i32
	(binaryfunc)mat_iadd<4, 4, glm::i32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 4, glm::i32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, glm::i32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 4, glm::i32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 4, glm::i32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject himat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::imat4x4",             /* tp_name */
	sizeof(mat<4, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_str<glm::i32>,                         /* tp_repr */
	&himat4x4NumMethods,             /* tp_as_number */
	&himat4x4SeqMethods,                         /* tp_as_sequence */
	&himat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<glm::i32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&himat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"imat4x4( <imat4x4 compatible type(s)> )\n4 columns of 4 components matrix of integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, glm::i32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, glm::i32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	himat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<glm::i32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, glm::i32>,                 /* tp_new */
};
static PyTypeObject himat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"imat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, glm::i32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, glm::i32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"imat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, glm::i32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, glm::i32>,                 /* tp_new */
};
#pragma endregion
#pragma region u32
static PyMethodDef humat2x2_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x2"},
	{ NULL }
};
static PyBufferProcs humat2x2BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x2SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x2MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x2NumMethods = {
	(binaryfunc)mat_add<2, 2, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<2, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat2x2",             /* tp_name */
	sizeof(mat<2, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x2_str<glm::u32>,                         /* tp_repr */
	&humat2x2NumMethods,             /* tp_as_number */
	&humat2x2SeqMethods,                         /* tp_as_sequence */
	&humat2x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x2( <umat2x2 compatible type(s)> )\n2 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x2Iter",             /* tp_name */
	sizeof(matIter<2, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat2x3_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x3"},
	{ NULL }
};
static PyBufferProcs humat2x3BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x3SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x3MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x3NumMethods = {
	(binaryfunc)mat_add<2, 3, glm::u32>, //nb_add
	(binaryfunc)mat_sub<2, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat2x3",             /* tp_name */
	sizeof(mat<2, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x3_str<glm::u32>,                         /* tp_repr */
	&humat2x3NumMethods,             /* tp_as_number */
	&humat2x3SeqMethods,                         /* tp_as_sequence */
	&humat2x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x3( <umat2x3 compatible type(s)> )\n2 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x3Iter",             /* tp_name */
	sizeof(matIter<2, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat2x4_methods[] = {
	{"length", (PyCFunction)mat_length<2>, METH_NOARGS, "returns the length of glm::umat2x4"},
	{ NULL }
};
static PyBufferProcs humat2x4BufferMethods = {
	(getbufferproc)mat_getbuffer<2, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat2x4SeqMethods = {
	(lenfunc)mat_len<2>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<2, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat2x4MapMethods = {
	(lenfunc)mat_len<2>, // mp_length
	(binaryfunc)mat2x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat2x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat2x4NumMethods = {
	(binaryfunc)mat_add<2, 4, glm::u32>, //nb_add
	(binaryfunc)mat_sub<2, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<2, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<2, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<2, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<2, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<2, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<2, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<2, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat2x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat2x4",             /* tp_name */
	sizeof(mat<2, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat2x4_str<glm::u32>,                         /* tp_repr */
	&humat2x4NumMethods,             /* tp_as_number */
	&humat2x4SeqMethods,                         /* tp_as_sequence */
	&humat2x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat2x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat2x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat2x4( <umat2x4 compatible type(s)> )\n2 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<2, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<2, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat2x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat2x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<2, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat2x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat2x4Iter",             /* tp_name */
	sizeof(matIter<2, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<2, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat2x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<2, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<2, 4, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x2_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x2"},
	{ NULL }
};
static PyBufferProcs humat3x2BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x2SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x2MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x2NumMethods = {
	(binaryfunc)mat_add<3, 2, glm::u32>, //nb_add
	(binaryfunc)mat_sub<3, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat3x2",             /* tp_name */
	sizeof(mat<3, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x2_str<glm::u32>,                         /* tp_repr */
	&humat3x2NumMethods,             /* tp_as_number */
	&humat3x2SeqMethods,                         /* tp_as_sequence */
	&humat3x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x2( <umat3x2 compatible type(s)> )\n3 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x2Iter",             /* tp_name */
	sizeof(matIter<3, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x3_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x3"},
	{ NULL }
};
static PyBufferProcs humat3x3BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x3SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x3MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x3NumMethods = {
	(binaryfunc)mat_add<3, 3, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<3, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat3x3",             /* tp_name */
	sizeof(mat<3, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x3_str<glm::u32>,                         /* tp_repr */
	&humat3x3NumMethods,             /* tp_as_number */
	&humat3x3SeqMethods,                         /* tp_as_sequence */
	&humat3x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x3( <umat3x3 compatible type(s)> )\n3 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x3Iter",             /* tp_name */
	sizeof(matIter<3, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat3x4_methods[] = {
	{"length", (PyCFunction)mat_length<3>, METH_NOARGS, "returns the length of glm::umat3x4"},
	{ NULL }
};
static PyBufferProcs humat3x4BufferMethods = {
	(getbufferproc)mat_getbuffer<3, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat3x4SeqMethods = {
	(lenfunc)mat_len<3>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<3, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat3x4MapMethods = {
	(lenfunc)mat_len<3>, // mp_length
	(binaryfunc)mat3x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat3x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat3x4NumMethods = {
	(binaryfunc)mat_add<3, 4, glm::u32>, //nb_add
	(binaryfunc)mat_sub<3, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<3, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<3, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<3, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<3, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<3, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<3, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<3, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat3x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat3x4",             /* tp_name */
	sizeof(mat<3, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat3x4_str<glm::u32>,                         /* tp_repr */
	&humat3x4NumMethods,             /* tp_as_number */
	&humat3x4SeqMethods,                         /* tp_as_sequence */
	&humat3x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat3x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat3x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat3x4( <umat3x4 compatible type(s)> )\n3 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<3, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<3, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat3x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat3x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<3, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat3x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat3x4Iter",             /* tp_name */
	sizeof(matIter<3, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<3, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat3x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<3, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<3, 4, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x2_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x2"},
	{ NULL }
};
static PyBufferProcs humat4x2BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 2, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x2SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 2, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x2MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x2_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x2_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x2NumMethods = {
	(binaryfunc)mat_add<4, 2, glm::u32>, //nb_add
	(binaryfunc)mat_sub<4, 2, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 2, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 2, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 2, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 2, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 2, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 2, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 2, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x2Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat4x2",             /* tp_name */
	sizeof(mat<4, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x2_str<glm::u32>,                         /* tp_repr */
	&humat4x2NumMethods,             /* tp_as_number */
	&humat4x2SeqMethods,                         /* tp_as_sequence */
	&humat4x2MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x2_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x2BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x2( <umat4x2 compatible type(s)> )\n4 columns of 2 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 2, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 2, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x2_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x2_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 2, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x2IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x2Iter",             /* tp_name */
	sizeof(matIter<4, 2, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 2, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x2 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 2, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 2, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x3_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x3"},
	{ NULL }
};
static PyBufferProcs humat4x3BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 3, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x3SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 3, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x3MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x3_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x3_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x3NumMethods = {
	(binaryfunc)mat_add<4, 3, glm::u32>, //nb_add
	(binaryfunc)mat_sub<4, 3, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 3, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 3, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 3, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 3, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 3, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 3, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 3, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x3Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat4x3",             /* tp_name */
	sizeof(mat<4, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x3_str<glm::u32>,                         /* tp_repr */
	&humat4x3NumMethods,             /* tp_as_number */
	&humat4x3SeqMethods,                         /* tp_as_sequence */
	&humat4x3MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x3_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x3BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x3( <umat4x3 compatible type(s)> )\n4 columns of 3 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 3, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 3, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x3_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x3_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 3, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x3IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x3Iter",             /* tp_name */
	sizeof(matIter<4, 3, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 3, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x3 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 3, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 3, glm::u32>,                 /* tp_new */
};

static PyMethodDef humat4x4_methods[] = {
	{"length", (PyCFunction)mat_length<4>, METH_NOARGS, "returns the length of glm::umat4x4"},
	{ NULL }
};
static PyBufferProcs humat4x4BufferMethods = {
	(getbufferproc)mat_getbuffer<4, 4, glm::u32>,
	(releasebufferproc)mat_releasebuffer,
};
static PySequenceMethods humat4x4SeqMethods = {
	(lenfunc)mat_len<4>, // sq_length
	0, // sq_concat
	0, // sq_repeat
	0, // sq_item
	0,
	0, // sq_ass_item
	0,
	(objobjproc)mat_contains<4, 4, glm::u32>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyMappingMethods humat4x4MapMethods = {
	(lenfunc)mat_len<4>, // mp_length
	(binaryfunc)mat4x4_mp_item<glm::u32>, // mp_subscript
	(objobjargproc)mat4x4_mp_ass_item<glm::u32>, // mp_ass_subscript
};
static PyNumberMethods humat4x4NumMethods = {
	(binaryfunc)mat_add<4, 4, glm::u32>, //nb_add
	(binaryfunc)matsq_sub<4, 4, glm::u32>, //nb_subtract
	(binaryfunc)mat_mul<4, 4, glm::u32>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	0, //nb_negative
	(unaryfunc)mat_pos<4, 4, glm::u32>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_glm::u32
	(binaryfunc)mat_iadd<4, 4, glm::u32>, //nb_inplace_add
	(binaryfunc)mat_isub<4, 4, glm::u32>, //nb_inplace_subtract
	(binaryfunc)mat_imul<4, 4, glm::u32>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)mat_div<4, 4, glm::u32>,
	0, //nb_inplace_floor_divide
	(binaryfunc)mat_idiv<4, 4, glm::u32>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject humat4x4Type = {
	PyObject_HEAD_INIT(NULL)
	"glm::umat4x4",             /* tp_name */
	sizeof(mat<4, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)mat_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)mat4x4_str<glm::u32>,                         /* tp_repr */
	&humat4x4NumMethods,             /* tp_as_number */
	&humat4x4SeqMethods,                         /* tp_as_sequence */
	&humat4x4MapMethods,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)mat4x4_str<glm::u32>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&humat4x4BufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"umat4x4( <umat4x4 compatible type(s)> )\n4 columns of 4 components matrix of unsigned integer numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)mat_richcompare<4, 4, glm::u32>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)mat_geniter<4, 4, glm::u32>,                         /* tp_iter */
	0,                         /* tp_iternext */
	humat4x4_methods,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)mat4x4_init<glm::u32>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)mat_new<4, 4, glm::u32>,                 /* tp_new */
};
static PyTypeObject humat4x4IterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"umat4x4Iter",             /* tp_name */
	sizeof(matIter<4, 4, glm::u32>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)matIter_dealloc<4, 4, glm::u32>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"umat4x4 iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)matIter_next<4, 4, glm::u32>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)matIter_new<4, 4, glm::u32>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma region qua
static PyObject* qua_length(PyObject * self, PyObject* arg);

template<typename T>
static int qua_getbuffer(qua<T>* self, Py_buffer* view, int flags);

void qua_releasebuffer(PyObject* self, Py_buffer* view);

static Py_ssize_t qua_len(PyObject* self);

template<typename T>
static PyObject* qua_sq_item(qua<T> * self, Py_ssize_t index);

template<typename T>
static int qua_sq_ass_item(qua<T> * self, Py_ssize_t index, PyObject * value);

template<typename T>
static int qua_contains(qua<T> * self, PyObject * value);

template<typename T>
static PyObject * qua_add(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_sub(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_mul(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_neg(qua<T> *obj);

template<typename T>
static PyObject * qua_pos(qua<T> *obj);

template<typename T>
static PyObject * qua_iadd(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_isub(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_imul(qua<T>* self, PyObject *obj);

template<typename T>
static PyObject * qua_div(PyObject *obj1, PyObject *obj2);

template<typename T>
static PyObject * qua_idiv(qua<T>* self, PyObject *obj);

static void qua_dealloc(PyObject* self);

template<typename T>
static PyObject* qua_str(qua<T>* self);

template<typename T>
static PyObject* qua_richcompare(qua<T>* self, PyObject* other, int comp_type);

template<typename T>
static PyObject* qua_geniter(qua<T>* self);

template<typename T>
static int qua_init(qua<T> *self, PyObject *args, PyObject *kwds);

template<typename T>
static PyObject* qua_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

template<typename T>
static void quaIter_dealloc(quaIter<T> *rgstate);

template<typename T>
static PyObject* quaIter_next(quaIter<T> *rgstate);

template<typename T>
static PyObject* quaIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs);

#pragma region float
static PyMethodDef hfqua_methods[] = {
	{"length", (PyCFunction)qua_length, METH_NOARGS, "returns the length of glm::quat"},
	{ NULL }
};

static PyMemberDef hfqua_members[] = {
	{ (char*)"x", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.x), 0, (char*)"quat.x" },
	{ (char*)"y", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.y), 0, (char*)"quat.y" },
	{ (char*)"z", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.z), 0, (char*)"quat.z" },
	{ (char*)"w", T_FLOAT, offsetof(UNBRACKET(qua<float>), super_type.w), 0, (char*)"quat.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hfquaBufferMethods = {
	(getbufferproc)qua_getbuffer<float>,
	(releasebufferproc)qua_releasebuffer,
};
static PySequenceMethods hfquaSeqMethods = {
	(lenfunc)qua_len, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)qua_sq_item<float>, // sq_item
	0,
	(ssizeobjargproc)qua_sq_ass_item<float>, // sq_ass_item
	0,
	(objobjproc)qua_contains<float>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hfquaNumMethods = {
	(binaryfunc)qua_add<float>, //nb_add
	(binaryfunc)qua_sub<float>, //nb_subtract
	(binaryfunc)qua_mul<float>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)qua_neg<float>, //nb_negative
	(unaryfunc)qua_pos<float>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_float
	(binaryfunc)qua_iadd<float>, //nb_inplace_add
	(binaryfunc)qua_isub<float>, //nb_inplace_subtract
	(binaryfunc)qua_imul<float>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)qua_div<float>,
	0, //nb_inplace_floor_divide
	(binaryfunc)qua_idiv<float>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hfquaType = {
	PyObject_HEAD_INIT(NULL)
	"glm::quat",             /* tp_name */
	sizeof(qua<float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)qua_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)qua_str<float>,                         /* tp_repr */
	&hfquaNumMethods,             /* tp_as_number */
	&hfquaSeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)qua_str<float>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hfquaBufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"quat( <quat compatible type(s)> )\n4 components quaternion of floating-point numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)qua_richcompare<float>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)qua_geniter<float>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hfqua_methods,             /* tp_methods */
	hfqua_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)qua_init<float>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)qua_new<float>,                 /* tp_new */
};
static PyTypeObject hfquaIterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"quaIter",             /* tp_name */
	sizeof(quaIter<float>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)quaIter_dealloc<float>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"quat iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)quaIter_next<float>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)quaIter_new<float>,                 /* tp_new */
};
#pragma endregion
#pragma region double
static PyMethodDef hdqua_methods[] = {
	{"length", (PyCFunction)qua_length, METH_NOARGS, "returns the length of glm::dquat"},
	{ NULL }
};

static PyMemberDef hdqua_members[] = {
	{ (char*)"x", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.x), 0, (char*)"dquat.x" },
	{ (char*)"y", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.y), 0, (char*)"dquat.y" },
	{ (char*)"z", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.z), 0, (char*)"dquat.z" },
	{ (char*)"w", T_DOUBLE, offsetof(UNBRACKET(qua<double>), super_type.w), 0, (char*)"dquat.w" },
	{ NULL }  /* Sentinel */
};
static PyBufferProcs hdquaBufferMethods = {
	(getbufferproc)qua_getbuffer<double>,
	(releasebufferproc)qua_releasebuffer,
};
static PySequenceMethods hdquaSeqMethods = {
	(lenfunc)qua_len, // sq_length
	0, // sq_concat
	0, // sq_repeat
	(ssizeargfunc)qua_sq_item<double>, // sq_item
	0,
	(ssizeobjargproc)qua_sq_ass_item<double>, // sq_ass_item
	0,
	(objobjproc)qua_contains<double>, // sq_contains
	0, // sq_inplace_concat
	0, // sq_inplace_repeat
};
static PyNumberMethods hdquaNumMethods = {
	(binaryfunc)qua_add<double>, //nb_add
	(binaryfunc)qua_sub<double>, //nb_subtract
	(binaryfunc)qua_mul<double>, //nb_multiply
	0, //nb_remainder
	0, //nb_divmod
	0, //nb_power
	(unaryfunc)qua_neg<double>, //nb_negative
	(unaryfunc)qua_pos<double>, //nb_positive
	0, //nb_absolute
	0, //nb_bool
	0, //nb_invert
	0, //nb_lshift
	0, //nb_rshift
	0, //nb_and
	0, //nb_xor
	0, //nb_or
	0, //nb_int
	0, //nb_reserved
	0, //nb_double
	(binaryfunc)qua_iadd<double>, //nb_inplace_add
	(binaryfunc)qua_isub<double>, //nb_inplace_subtract
	(binaryfunc)qua_imul<double>, //nb_inplace_multiply
	0, //nb_inplace_remainder
	0, //nb_inplace_power
	0, //nb_inplace_lshift
	0, //nb_inplace_rshift
	0, //nb_inplace_and
	0, //nb_inplace_xor
	0, //nb_inplace_or
	0, //nb_floor_divide
	(binaryfunc)qua_div<double>,
	0, //nb_inplace_floor_divide
	(binaryfunc)qua_idiv<double>, //nb_inplace_true_divide
	0, //nb_index
};
static PyTypeObject hdquaType = {
	PyObject_HEAD_INIT(NULL)
	"glm::dquat",             /* tp_name */
	sizeof(qua<double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)qua_dealloc, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	(reprfunc)qua_str<double>,                         /* tp_repr */
	&hdquaNumMethods,             /* tp_as_number */
	&hdquaSeqMethods,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	(reprfunc)qua_str<double>,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	&hdquaBufferMethods,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT |
	Py_TPFLAGS_BASETYPE,   /* tp_flags */
	"dquat( <dquat compatible type(s)> )\n4 components quaternion of double numbers.",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	(richcmpfunc)qua_richcompare<double>,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	(getiterfunc)qua_geniter<double>,                         /* tp_iter */
	0,                         /* tp_iternext */
	hdqua_methods,             /* tp_methods */
	hdqua_members,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	(initproc)qua_init<double>,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)qua_new<double>,                 /* tp_new */
};
static PyTypeObject hdquaIterType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	"dquatIter",             /* tp_name */
	sizeof(quaIter<double>),             /* tp_basicsize */
	0,                         /* tp_itemsize */
	(destructor)quaIter_dealloc<double>, /* tp_dealloc */
	0,                         /* tp_print */
	0,                         /* tp_getattr */
	0,                         /* tp_setattr */
	0,                         /* tp_reserved */
	0,                         /* tp_repr */
	0,             /* tp_as_number */
	0,                         /* tp_as_sequence */
	0,                         /* tp_as_mapping */
	0,                         /* tp_hash  */
	0,                         /* tp_call */
	0,                         /* tp_str */
	0,                         /* tp_getattro */
	0,                         /* tp_setattro */
	0,                         /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,   /* tp_flags */
	"dquat iterator",           /* tp_doc */
	0,                         /* tp_traverse */
	0,                         /* tp_clear */
	0,                         /* tp_richcompare */
	0,                         /* tp_weaklistoffset */
	0,                         /* tp_iter */
	(iternextfunc)quaIter_next<double>,                         /* tp_iternext */
	0,             /* tp_methods */
	0,             /* tp_members */
	0,           			/* tp_getset */
	0,                         /* tp_base */
	0,                         /* tp_dict */
	0,                         /* tp_descr_get */
	0,                         /* tp_descr_set */
	0,                         /* tp_dictoffset */
	0,      /* tp_init */
	0,                         /* tp_alloc */
	(newfunc)quaIter_new<double>,                 /* tp_new */
};
#pragma endregion
#pragma endregion
#pragma endregion

// INTERNAL FUNCTIONS
#pragma region internal functions

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
PyObject* ctypes_void_p = NULL;
PyObject* ctypes_cast = NULL;
PyObject* ctypes_float_p = NULL;
PyObject* ctypes_double_p = NULL;
PyObject* ctypes_int64_p = NULL;
PyObject* ctypes_int32_p = NULL;
PyObject* ctypes_int16_p = NULL;
PyObject* ctypes_int8_p = NULL;
PyObject* ctypes_uint64_p = NULL;
PyObject* ctypes_uint32_p = NULL;
PyObject* ctypes_uint16_p = NULL;
PyObject* ctypes_uint8_p = NULL;
PyObject* ctypes_bool_p = NULL;

#define PyGLM_FREXP_WARNING 1

int PyGLM_SHOW_WARNINGS = PyGLM_FREXP_WARNING;

#if defined(_M_IX86) || defined(__i386__)
PyObject* PyGLM_CtypesVoidP_FromVoidP(void* p) {
	PyObject* argList = Py_BuildValue("(K)", (unsigned long)p);
	PyObject* out = PyObject_CallObject(ctypes_void_p, argList);
	Py_DECREF(argList);
	return out;
}
unsigned long PyGLM_UnsignedLongLong_FromCtypesP(PyObject* ptr) {
	PyObject* ptr_as_c_void_p = PyObject_CallFunctionObjArgs(ctypes_cast, ptr, ctypes_void_p, NULL);
	PyObject* ptr_value = PyObject_GetAttrString(ptr_as_c_void_p, "value");
	unsigned long out = PyLong_AsUnsignedLong(ptr_value);
	Py_DECREF(ptr_value);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#else
PyObject* PyGLM_CtypesVoidP_FromVoidP(void* p) {
	PyObject* argList = Py_BuildValue("(K)", (unsigned long long)p);
	PyObject* out = PyObject_CallObject(ctypes_void_p, argList);
	Py_DECREF(argList);
	return out;
}
unsigned long long PyGLM_UnsignedLongLong_FromCtypesP(PyObject* ptr) {
	PyObject* ptr_as_c_void_p = PyObject_CallFunctionObjArgs(ctypes_cast, ptr, ctypes_void_p, NULL);
	PyObject* ptr_value = PyObject_GetAttrString(ptr_as_c_void_p, "value");
	unsigned long long out = PyLong_AsUnsignedLongLong(ptr_value);
	Py_DECREF(ptr_value);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#endif

PyObject* PyGLM_ToCtypesP(float* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_float_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(double* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_double_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int64* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int64_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int32* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int32_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int16* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int16_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::int8* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_int8_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint64* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint64_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint32* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint32_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint16* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint16_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(glm::uint8* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_uint8_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
PyObject* PyGLM_ToCtypesP(bool* ptr) {
	PyObject* ptr_as_c_void_p = PyGLM_CtypesVoidP_FromVoidP((void*)ptr);
	PyObject* out = PyObject_CallFunctionObjArgs(ctypes_cast, ptr_as_c_void_p, ctypes_bool_p, NULL);
	Py_DECREF(ptr_as_c_void_p);
	return out;
}
#endif

template<int L, typename T>
static PyTypeObject* PyGLM_VEC_TYPE() {
	if (std::is_same<vec<L, T>, vec<1, float> >::value) {
		return (PyTypeObject*)&hfvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, float> >::value) {
		return (PyTypeObject*)&hfvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, float> >::value) {
		return (PyTypeObject*)&hfvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, float> >::value) {
		return (PyTypeObject*)&hfvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, double> >::value) {
		return (PyTypeObject*)&hdvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, double> >::value) {
		return (PyTypeObject*)&hdvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, double> >::value) {
		return (PyTypeObject*)&hdvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, double> >::value) {
		return (PyTypeObject*)&hdvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i32> >::value) {
		return (PyTypeObject*)&hivec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i32> >::value) {
		return (PyTypeObject*)&hivec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i32> >::value) {
		return (PyTypeObject*)&hivec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i32> >::value) {
		return (PyTypeObject*)&hivec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u32> >::value) {
		return (PyTypeObject*)&huvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u32> >::value) {
		return (PyTypeObject*)&huvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u32> >::value) {
		return (PyTypeObject*)&huvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u32> >::value) {
		return (PyTypeObject*)&huvec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec4Type;
	}
	if (std::is_same<vec<L, T>, vec<1, bool> >::value) {
		return (PyTypeObject*)&hbvec1Type;
	}
	if (std::is_same<vec<L, T>, vec<2, bool> >::value) {
		return (PyTypeObject*)&hbvec2Type;
	}
	if (std::is_same<vec<L, T>, vec<3, bool> >::value) {
		return (PyTypeObject*)&hbvec3Type;
	}
	if (std::is_same<vec<L, T>, vec<4, bool> >::value) {
		return (PyTypeObject*)&hbvec4Type;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_VECITER_TYPE() {
	if (std::is_same<vecIter<L, T>, vecIter<1, float> >::value) {
		return (PyTypeObject*)&hfvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, float> >::value) {
		return (PyTypeObject*)&hfvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, float> >::value) {
		return (PyTypeObject*)&hfvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, float> >::value) {
		return (PyTypeObject*)&hfvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, double> >::value) {
		return (PyTypeObject*)&hdvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, double> >::value) {
		return (PyTypeObject*)&hdvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, double> >::value) {
		return (PyTypeObject*)&hdvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, double> >::value) {
		return (PyTypeObject*)&hdvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i8> >::value) {
		return (PyTypeObject*)&hi8vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i16> >::value) {
		return (PyTypeObject*)&hi16vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i32> >::value) {
		return (PyTypeObject*)&hivec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i32> >::value) {
		return (PyTypeObject*)&hivec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i32> >::value) {
		return (PyTypeObject*)&hivec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i32> >::value) {
		return (PyTypeObject*)&hivec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::i64> >::value) {
		return (PyTypeObject*)&hi64vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u8> >::value) {
		return (PyTypeObject*)&hu8vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u16> >::value) {
		return (PyTypeObject*)&hu16vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u32> >::value) {
		return (PyTypeObject*)&huvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u32> >::value) {
		return (PyTypeObject*)&huvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u32> >::value) {
		return (PyTypeObject*)&huvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u32> >::value) {
		return (PyTypeObject*)&huvec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, glm::u64> >::value) {
		return (PyTypeObject*)&hu64vec4IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<1, bool> >::value) {
		return (PyTypeObject*)&hbvec1IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<2, bool> >::value) {
		return (PyTypeObject*)&hbvec2IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<3, bool> >::value) {
		return (PyTypeObject*)&hbvec3IterType;
	}
	if (std::is_same<vecIter<L, T>, vecIter<4, bool> >::value) {
		return (PyTypeObject*)&hbvec4IterType;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_MVEC_TYPE() {
	if (std::is_same<mvec<L, T>, mvec<2, float> >::value) {
		return (PyTypeObject*)&hfmvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, float> >::value) {
		return (PyTypeObject*)&hfmvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, float> >::value) {
		return (PyTypeObject*)&hfmvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, double> >::value) {
		return (PyTypeObject*)&hdmvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, double> >::value) {
		return (PyTypeObject*)&hdmvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, double> >::value) {
		return (PyTypeObject*)&hdmvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, glm::i32> >::value) {
		return (PyTypeObject*)&himvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, glm::i32> >::value) {
		return (PyTypeObject*)&himvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, glm::i32> >::value) {
		return (PyTypeObject*)&himvec4Type;
	}
	if (std::is_same<mvec<L, T>, mvec<2, glm::u32> >::value) {
		return (PyTypeObject*)&humvec2Type;
	}
	if (std::is_same<mvec<L, T>, mvec<3, glm::u32> >::value) {
		return (PyTypeObject*)&humvec3Type;
	}
	if (std::is_same<mvec<L, T>, mvec<4, glm::u32> >::value) {
		return (PyTypeObject*)&humvec4Type;
	}
	return (PyTypeObject*)0;
}

template<int L, typename T>
static PyTypeObject* PyGLM_MVECITER_TYPE() {
	if (std::is_same<mvecIter<L, T>, mvecIter<2, float> >::value) {
		return (PyTypeObject*)&hfmvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, float> >::value) {
		return (PyTypeObject*)&hfmvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, float> >::value) {
		return (PyTypeObject*)&hfmvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, double> >::value) {
		return (PyTypeObject*)&hdmvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, double> >::value) {
		return (PyTypeObject*)&hdmvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, double> >::value) {
		return (PyTypeObject*)&hdmvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, glm::i32> >::value) {
		return (PyTypeObject*)&himvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, glm::i32> >::value) {
		return (PyTypeObject*)&himvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, glm::i32> >::value) {
		return (PyTypeObject*)&himvec4IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<2, glm::u32> >::value) {
		return (PyTypeObject*)&humvec2IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<3, glm::u32> >::value) {
		return (PyTypeObject*)&humvec3IterType;
	}
	if (std::is_same<mvecIter<L, T>, mvecIter<4, glm::u32> >::value) {
		return (PyTypeObject*)&humvec4IterType;
	}
	return (PyTypeObject*)0;
}

template<int C, int R, typename T>
static PyTypeObject* PyGLM_MAT_TYPE() {
	if (std::is_same<mat<C, R, T>, mat<2, 2, float> >::value) {
		return (PyTypeObject*)&hfmat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, float> >::value) {
		return (PyTypeObject*)&hfmat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, float> >::value) {
		return (PyTypeObject*)&hfmat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, float> >::value) {
		return (PyTypeObject*)&hfmat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, float> >::value) {
		return (PyTypeObject*)&hfmat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, float> >::value) {
		return (PyTypeObject*)&hfmat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, float> >::value) {
		return (PyTypeObject*)&hfmat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, float> >::value) {
		return (PyTypeObject*)&hfmat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, float> >::value) {
		return (PyTypeObject*)&hfmat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, double> >::value) {
		return (PyTypeObject*)&hdmat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, double> >::value) {
		return (PyTypeObject*)&hdmat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, double> >::value) {
		return (PyTypeObject*)&hdmat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, double> >::value) {
		return (PyTypeObject*)&hdmat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, double> >::value) {
		return (PyTypeObject*)&hdmat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, double> >::value) {
		return (PyTypeObject*)&hdmat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, double> >::value) {
		return (PyTypeObject*)&hdmat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, double> >::value) {
		return (PyTypeObject*)&hdmat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, double> >::value) {
		return (PyTypeObject*)&hdmat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<2, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<3, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x4Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x2Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x3Type;
	}
	if (std::is_same<mat<C, R, T>, mat<4, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x4Type;
	}
	return (PyTypeObject*)0;
}

template<int C, int R, typename T>
static PyTypeObject* PyGLM_MATITER_TYPE() {
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, float> >::value) {
		return (PyTypeObject*)&hfmat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, float> >::value) {
		return (PyTypeObject*)&hfmat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, float> >::value) {
		return (PyTypeObject*)&hfmat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, float> >::value) {
		return (PyTypeObject*)&hfmat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, float> >::value) {
		return (PyTypeObject*)&hfmat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, float> >::value) {
		return (PyTypeObject*)&hfmat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, float> >::value) {
		return (PyTypeObject*)&hfmat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, float> >::value) {
		return (PyTypeObject*)&hfmat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, float> >::value) {
		return (PyTypeObject*)&hfmat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, double> >::value) {
		return (PyTypeObject*)&hdmat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, double> >::value) {
		return (PyTypeObject*)&hdmat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, double> >::value) {
		return (PyTypeObject*)&hdmat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, double> >::value) {
		return (PyTypeObject*)&hdmat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, double> >::value) {
		return (PyTypeObject*)&hdmat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, double> >::value) {
		return (PyTypeObject*)&hdmat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, double> >::value) {
		return (PyTypeObject*)&hdmat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, double> >::value) {
		return (PyTypeObject*)&hdmat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, double> >::value) {
		return (PyTypeObject*)&hdmat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, glm::i32> >::value) {
		return (PyTypeObject*)&himat4x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<2, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat2x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<3, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat3x4IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 2, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x2IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 3, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x3IterType;
	}
	if (std::is_same<matIter<C, R, T>, matIter<4, 4, glm::u32> >::value) {
		return (PyTypeObject*)&humat4x4IterType;
	}
	return (PyTypeObject*)0;
}

template<typename T>
static PyTypeObject* PyGLM_QUA_TYPE() {
	if (std::is_same<qua<T>, qua<float> >::value) {
		return (PyTypeObject*)&hfquaType;
	}
	if (std::is_same<qua<T>, qua<double> >::value) {
		return (PyTypeObject*)&hdquaType;
	}
	return (PyTypeObject*)0;
}

template<typename T>
static PyTypeObject* PyGLM_QUAITER_TYPE() {
	if (std::is_same<quaIter<T>, quaIter<float> >::value) {
		return (PyTypeObject*)&hfquaIterType;
	}
	if (std::is_same<quaIter<T>, quaIter<double> >::value) {
		return (PyTypeObject*)&hdquaIterType;
	}
	return (PyTypeObject*)0;
}


#define Py_IS_NOTIMPLEMENTED(op) (op == NULL || (PyObject*)op == Py_NotImplemented) // find out if op is NULL or NotImplemented

#define PyGLM_ASSERT(cond, msg) if (!cond) PyErr_SetString(PyExc_AssertionError, msg); return NULL

#define PyObject_IterCheck(op) ((op)->ob_type->tp_iter != 0)

#define PyGLM_TYPE_AS_CSTRING(op) op->ob_type->tp_name

#define PyGLM_TypeCheck(op, tp) (Py_TYPE(op) == tp) 

#define PyGLM_String_AsString(name) PyBytes_AsString(PyUnicode_AsASCIIString(name));

// error functions
#define PyGLM_TYPEERROR_O(str, obj) PyErr_Format(PyExc_TypeError, "%s'%s'", str, PyGLM_TYPE_AS_CSTRING(obj));
#define PyGLM_TYPEERROR_2O(str, obj1, obj2) PyErr_Format(PyExc_TypeError, "%s'%s' and '%s'", str, PyGLM_TYPE_AS_CSTRING(obj1), PyGLM_TYPE_AS_CSTRING(obj2));

#define PyGLM_Arg_Unpack_1O(args, name, arg1) if(!PyArg_UnpackTuple(args, name, 1, 1, &arg1)) return NULL
#define PyGLM_Arg_Unpack_2O(args, name, arg1, arg2) if(!PyArg_UnpackTuple(args, name, 2, 2, &arg1, &arg2)) return NULL
#define PyGLM_Arg_Unpack_3O(args, name, arg1, arg2, arg3) if(!PyArg_UnpackTuple(args, name, 3, 3, &arg1, &arg2, &arg3)) return NULL
#define PyGLM_Arg_Unpack_4O(args, name, arg1, arg2, arg3, arg4) if(!PyArg_UnpackTuple(args, name, 4, 4, &arg1, &arg2, &arg3, &arg4)) return NULL
#define PyGLM_Arg_Unpack_5O(args, name, arg1, arg2, arg3, arg4, arg5) if(!PyArg_UnpackTuple(args, name, 5, 5, &arg1, &arg2, &arg3, &arg4, &arg5)) return NULL
#define PyGLM_Arg_Unpack_6O(args, name, arg1, arg2, arg3, arg4, arg5, arg6) if(!PyArg_UnpackTuple(args, name, 6, 6, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) return NULL


bool PyGLM_Number_Check(PyObject* arg) {
	if (PyFloat_Check(arg) || PyLong_Check(arg) || PyBool_Check(arg)) {
		return true;
	}
	if (arg->ob_type->tp_as_number != NULL && arg->ob_type->tp_as_number->nb_float != NULL) {
		PyObject* temp = PyNumber_Float(arg);
		if (temp != NULL) {
			Py_DECREF(temp);
			return true;
		}
		PyErr_Clear();
	}
	return false;
}

double PyGLM_Number_AsDouble(PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return PyFloat_AS_DOUBLE(arg);
	}
	if (PyLong_Check(arg)) {
		return PyLong_AsDouble(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1.0 : 0.0;
	}
	PyObject* arg_as_float = PyNumber_Float(arg);
	double out = PyFloat_AS_DOUBLE(arg_as_float);
	Py_DECREF(arg_as_float);
	return out;
}

long PyGLM_Number_AsLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AS_LONG(arg);
	}
	if (PyFloat_Check(arg)) {
		return (long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1 : 0;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	long out = PyLong_AS_LONG(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

long long PyGLM_Number_AsLongLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AsLongLong(arg);
	}
	if (PyFloat_Check(arg)) {
		return (long long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1LL : 0LL;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	long long out = PyLong_AsLongLong(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

unsigned long long PyGLM_Number_AsUnsignedLongLong(PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_AsUnsignedLongLong(arg);
	}
	if (PyFloat_Check(arg)) {
		return (unsigned long long)PyFloat_AS_DOUBLE(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1ull : 0ull;
	}
	PyObject* arg_as_long = PyNumber_Long(arg);
	unsigned long long out = PyLong_AsUnsignedLongLong(arg_as_long);
	Py_DECREF(arg_as_long);
	return out;
}

bool PyGLM_Number_AsBool(PyObject* arg) {
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? true : false;
	}
	if (PyLong_Check(arg)) {
		return (bool)PyLong_AS_LONG(arg);
	}
	if (PyFloat_Check(arg)) {
		return (bool)PyFloat_AS_DOUBLE(arg);
	}
	PyObject* arg_as_bool = PyNumber_Long(arg);
	bool out = (bool)PyLong_AS_LONG(arg_as_bool);
	Py_DECREF(arg_as_bool);
	return out;
}

float PyGLM_Number_AsFloat(PyObject* arg) {
	if (PyFloat_Check(arg)) {
		return (float)PyFloat_AS_DOUBLE(arg);
	}
	if (PyLong_Check(arg)) {
		return (float)PyLong_AS_LONG(arg);
	}
	if (PyBool_Check(arg)) {
		return (arg == Py_True) ? 1.f : 0.f;
	}
	PyObject* arg_as_float = PyNumber_Float(arg);
	float out = (float)PyFloat_AS_DOUBLE(arg_as_float);
	Py_DECREF(arg_as_float);
	return out;
}

template<typename T>
static T PyGLM_Number_FromPyObject(PyObject* value) {
	if (std::numeric_limits<T>::is_iec559) {
		if (std::is_same<T, double>::value) {
			return (T)PyGLM_Number_AsDouble(value);
		}
		return static_cast<T>(PyGLM_Number_AsFloat(value));
	}
	else if (std::numeric_limits<T>::is_integer) {
		if (std::is_same<T, long long>::value) {
			return (T)PyGLM_Number_AsLongLong(value);
		}
		if (std::is_same<T, unsigned long long>::value) {
			return (T)PyGLM_Number_AsUnsignedLongLong(value);
		}
		return static_cast<T>(PyGLM_Number_AsLong(value));
	}
	else if (std::is_same<T, bool>::value) {
		return (T)PyGLM_Number_AsBool(value);
	}
	return (T)0;
}

template<typename T>
static PyObject* PyGLM_PyObject_FromNumber(T value) {
	if (std::numeric_limits<T>::is_iec559) {
		return PyFloat_FromDouble(static_cast<double>(value));
	}
	else if (std::numeric_limits<T>::is_integer) {
		if (std::is_same<T, long long>::value) {
			return PyLong_FromLongLong((long long)value);
		}
		if (std::is_same<T, unsigned long long>::value) {
			return PyLong_FromUnsignedLongLong((unsigned long long)value);
		}
		return PyLong_FromLong((long)value);
	}
	return NULL;
}

// type checkers
#pragma region type checkers
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
bool PyGLM_Vec2i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 2 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 2) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);

	Py_DECREF(iterator);

	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1)) {
		Py_XDECREF(value0);
		Py_XDECREF(value1);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);

	return true;
}

bool PyGLM_Vec3i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 3 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 2))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 3) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);
	PyObject* value2 = PyIter_Next(iterator);


	Py_DECREF(iterator);


	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2)) {

		Py_XDECREF(value0);
		Py_XDECREF(value1);
		Py_XDECREF(value2);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);
	Py_DECREF(value2);

	return true;
}

bool PyGLM_Vec4i_Check(PyObject* o) {
	if (!PyObject_IterCheck(o)) {
		return false;
	}
	if (PyTuple_Check(o)) {
		if (Py_SIZE(o) == 4 && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 0)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 1)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 2)) && PyGLM_Number_Check(PyTuple_GET_ITEM(o, 3))) {
			return true;
		}
		return false;
	}
	if (PyObject_Length(o) != 4) {
		return false;
	}

	PyObject* iterator = PyObject_GetIter(o);

	PyObject* value0 = PyIter_Next(iterator);
	PyObject* value1 = PyIter_Next(iterator);
	PyObject* value2 = PyIter_Next(iterator);
	PyObject* value3 = PyIter_Next(iterator);


	Py_DECREF(iterator);


	if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2) || value3 == NULL || !PyGLM_Number_Check(value3)) {

		Py_XDECREF(value0);
		Py_XDECREF(value1);
		Py_XDECREF(value2);
		Py_XDECREF(value3);

		return false;
	}
	Py_DECREF(value0);
	Py_DECREF(value1);
	Py_DECREF(value2);
	Py_DECREF(value3);

	return true;
}

#define PyGLM_Veci_Check(L, o) ((L == 2) ? PyGLM_Vec2i_Check(o) : (L == 3) ? PyGLM_Vec3i_Check(o) : PyGLM_Vec4i_Check(o))

#define PyGLM_Vec_Check(L, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_VEC_TYPE<L, T>())) || Py_TYPE(o) == PyGLM_MVEC_TYPE<L, T>() || (!(PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<L, 2, T>())) || PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<L, 3, T>())) || PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<L, 4, T>()))) && PyGLM_Veci_Check(L, o)))

#else
#define PyGLM_Vec_Check(L, T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_VEC_TYPE<L, T>())) || Py_TYPE(o) == PyGLM_MVEC_TYPE<L, T>())
#endif

#define PyGLM_Qua_Check(T, o) (PyObject_TypeCheck(o, UNBRACKET (PyGLM_QUA_TYPE<T>())))

#define PyGLM_Mat_Check(C, R, T, o) PyObject_TypeCheck(o, UNBRACKET (PyGLM_MAT_TYPE<C, R, T>()))

#pragma endregion

// unpackers
#pragma region unpackers
template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<1, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<1, T>()))) {
		out = ((vec<1, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 1) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0)) {

				Py_XDECREF(value0);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);

			out = glm::vec<1, T>(value0_as_T);


			Py_DECREF(value0);

			return true;
		}
	}
#endif
	return false;
}

template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<2, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET (PyGLM_VEC_TYPE<2, T>()))) {
		out = ((vec<2, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<2, T>()) {
		out = *((mvec<2, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 2) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);

			out = glm::vec<2, T>(value0_as_T, value1_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);

			return true;
		}
	}
#endif
	return false;
}
template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<3, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<3, T>()))) {
		out = ((vec<3, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<3, T>()) {
		out = *((mvec<3, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 3) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);
			PyObject* value2 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);
				Py_XDECREF(value2);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);
			T value2_as_T = PyGLM_Number_FromPyObject<T>(value2);

			out = glm::vec<3, T>(value0_as_T, value1_as_T, value2_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);
			Py_DECREF(value2);

			return true;
		}
	}
#endif
	return false;
}

template<typename T>
static bool unpack_vec(PyObject* value, glm::vec<4, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_VEC_TYPE<4, T>()))) {
		out = ((vec<4, T>*)value)->super_type;
		return true;
	}
	if (Py_TYPE(value) == PyGLM_MVEC_TYPE<4, T>()) {
		out = *((mvec<4, T>*)value)->super_type;
		return true;
	}
#if !(PyGLM_BUILD & PyGLM_NO_ITER_TYPECHECKING)
	if (PyObject_IterCheck(value) && PyObject_Length(value) == 4) {
		PyObject* value_iter = PyObject_GetIter(value);
		if (value_iter != NULL) {
			PyObject* value0 = PyIter_Next(value_iter);
			PyObject* value1 = PyIter_Next(value_iter);
			PyObject* value2 = PyIter_Next(value_iter);
			PyObject* value3 = PyIter_Next(value_iter);


			Py_DECREF(value_iter);


			if (value0 == NULL || !PyGLM_Number_Check(value0) || value1 == NULL || !PyGLM_Number_Check(value1) || value2 == NULL || !PyGLM_Number_Check(value2) || value3 == NULL || !PyGLM_Number_Check(value3)) {

				Py_XDECREF(value0);
				Py_XDECREF(value1);
				Py_XDECREF(value2);
				Py_XDECREF(value3);

				return false;
			}

			T value0_as_T = PyGLM_Number_FromPyObject<T>(value0);
			T value1_as_T = PyGLM_Number_FromPyObject<T>(value1);
			T value2_as_T = PyGLM_Number_FromPyObject<T>(value2);
			T value3_as_T = PyGLM_Number_FromPyObject<T>(value3);

			out = glm::vec<4, T>(value0_as_T, value1_as_T, value2_as_T, value3_as_T);


			Py_DECREF(value0);
			Py_DECREF(value1);
			Py_DECREF(value2);
			Py_DECREF(value3);

			return true;
		}
	}
#endif
	return false;
}

template<int L, typename T>
static glm::vec<L, T> unpack_vec(PyObject* value) {
	glm::vec<L, T> out;
	unpack_vec(value, out);
	return out;
}

template<int C, int R, typename T>
static bool unpack_mat(PyObject* value, glm::mat<C, R, T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET (PyGLM_MAT_TYPE<C, R, T>()))) {
		out = ((mat<C, R, T>*)value)->super_type;
		return true;
	}
	return false;
}

template<int C, int R, typename T>
static glm::mat<C, R, T> unpack_mat(PyObject* value) {
	glm::mat<C, R, T> out;
	unpack_mat(value, out);
	return out;
}

template<typename T>
static bool unpack_qua(PyObject* value, glm::qua<T>& out) {
	if (PyObject_TypeCheck(value, UNBRACKET(PyGLM_QUA_TYPE<T>()))) {
		out = ((qua<T>*)value)->super_type;
		return true;
	}
	return false;
}

template<typename T>
static glm::qua<T> unpack_qua(PyObject* value) {
	glm::qua<T> out;
	unpack_qua(value, out);
	return out;
}
#pragma endregion

// packers
#pragma region packers

template<int L, typename T>
static PyObject*
pack_vec(glm::vec<L, T> value) {
	PyTypeObject* vecType = PyGLM_VEC_TYPE<L, T>();
	vec<L, T>* out = (vec<L, T>*)vecType->tp_alloc(vecType, 0);

	if (out != NULL) {
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<int L, typename T>
static PyObject*
pack_mvec(glm::vec<L, T>* value, PyObject* master) {
	PyTypeObject* mvecType = PyGLM_MVEC_TYPE<L, T>();
	mvec<L, T>* out = (mvec<L, T>*)mvecType->tp_alloc(mvecType, 0);

	if (out != NULL) {
		out->super_type = value;
		out->master = master;
		Py_INCREF(master);
	}

	return (PyObject*)out;
}

template<int C, int R, typename T>
static PyObject*
pack_mat(glm::mat<C, R, T> value) {
	PyTypeObject* matType = PyGLM_MAT_TYPE<C, R, T>();
	mat<C, R, T>* out = (mat<C, R, T>*)matType->tp_alloc(matType, 0);

	if (out != NULL) {
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<typename T>
static PyObject*
pack_qua(glm::qua<T> value) {
	PyTypeObject* quaType = PyGLM_QUA_TYPE<T>();
	qua<T>* out = (qua<T>*)quaType->tp_alloc(quaType, 0);

	if (out != NULL) {
		out->super_type = value;
	}

	return (PyObject*)out;
}

template<typename T>
static PyObject*
pack(T value) {
	return PyGLM_PyObject_FromNumber(value);
}

template<int L, typename T>
static PyObject*
pack(glm::vec<L, T> value) {
	return pack_vec(value);
}

template<int C, int R, typename T>
static PyObject*
pack(glm::mat<C, R, T> value) {
	return pack_mat(value);
}

template<typename T>
static PyObject*
pack(glm::qua<T> value) {
	return pack_qua(value);
}
#pragma endregion

#pragma endregion

// TYPE DEFINITIONS

// type vec
#pragma region type vec
static void
vec_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<int L, typename T>
static PyObject *
vec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	vec<L, T> *self = (vec<L, T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->super_type = glm::vec<L, T>();
	}

	return (PyObject *)self;
}


template<typename T>
static int
vec1_init(vec<1, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", NULL };

	PyObject * arg = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|O", const_cast<char**>(kwlist),
		&arg)) {
		if (arg == NULL) {
			return 0;
		}
		if (PyGLM_Number_Check(arg)) {
			self->super_type = glm::vec<1, T>(PyGLM_Number_FromPyObject<T>(arg));
			return 0;
		}
		if (PyGLM_Vec_Check(1, T, arg)) {
			self->super_type = unpack_vec<1, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check(2, T, arg)) {
			self->super_type = unpack_vec<2, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check(3, T, arg)) {
			self->super_type = unpack_vec<3, T>(arg);
			return 0;
		}
		if (PyGLM_Vec_Check(4, T, arg)) {
			self->super_type = unpack_vec<4, T>(arg);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
		return -1;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
	return -1;
}

template<typename T>
static int
vec2_init(vec<2, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO", const_cast<char**>(kwlist),
		&arg1, &arg2)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<2, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			if (PyGLM_Vec_Check(2, T, arg1)) {
				self->super_type = unpack_vec<2, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check(3, T, arg1)) {
				self->super_type = unpack_vec<3, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check(4, T, arg1)) {
				self->super_type = unpack_vec<4, T>(arg1);
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			self->super_type = glm::vec<2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec()");
	return -1;
}

template<typename T>
static int
vec3_init(vec<3, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<3, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			if (PyGLM_Vec_Check(3, T, arg1)) {
				self->super_type = unpack_vec<3, T>(arg1);
				return 0;
			}
			if (PyGLM_Vec_Check(4, T, arg1)) {
				self->super_type = unpack_vec<4, T>(arg1);
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
					return -1;
				}
				self->super_type = glm::vec3(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			if (PyGLM_Number_Check(arg2)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
					return -1;
				}
				self->super_type = glm::vec3(o, PyGLM_Number_FromPyObject<T>(arg2));
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
			self->super_type = glm::vec3(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec3()");
	return -1;
}

template<typename T>
static int
vec4_init(vec<4, T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", "w", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;
	PyObject * arg4 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3, &arg4)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1));
				return 0;
			}

			glm::vec<4, T> o;

			if (unpack_vec(arg1, o)) {
				self->super_type = o;
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			if (PyGLM_Number_Check(arg2)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(o, PyGLM_Number_FromPyObject<T>(arg2));
				return 0;
			}
			glm::vec<2, T> o;
			if (!unpack_vec(arg1, o)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			glm::vec<2, T> o2;
			if (!unpack_vec(arg2, o2)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			self->super_type = glm::vec<4, T>(o, o2);
			return 0;
		}
		if (arg4 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				if (PyGLM_Number_Check(arg2)) {
					glm::vec<2, T> o;
					if (!unpack_vec(arg3, o)) {
						PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
						return -1;
					}
					self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), o);
					return 0;
				}
				if (PyGLM_Number_Check(arg3)) {
					glm::vec<2, T> o;
					if (!unpack_vec(arg2, o)) {
						PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
						return -1;
					}
					self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), o, PyGLM_Number_FromPyObject<T>(arg3));
					return 0;
				}
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
				return -1;
			}
			if (PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
				glm::vec<2, T> o;
				if (!unpack_vec(arg1, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
					return -1;
				}
				self->super_type = glm::vec<4, T>(o, PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3));
				return 0;
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
			self->super_type = glm::vec<4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for vec4()");
	return -1;
}

// unaryfunc
template<int L, typename T>
static PyObject *
vec_neg(vec<L, T> *obj)
{
	return pack_vec<L, T>(-obj->super_type);
}

template<int L, typename T>
static PyObject *
vec_pos(vec<L, T> *obj)
{
	return pack_vec<L, T>(obj->super_type);
}

template<int L, typename T>
static PyObject *
vec_abs(vec<L, T> *obj)
{
	return pack_vec<L, T>(glm::abs(obj->super_type));
}

// binaryfunc
template<int L, typename T>
static PyObject *
vec_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) + (((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o + o2);
}

template<int L, typename T>
static PyObject *
vec_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) - ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o - o2);
}

template<int L, typename T>
static PyObject *
vec_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) * ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(o * o2);
}

template<int L, typename T>
static PyObject *
vec_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) / ((vec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return  pack_vec<L, T>(o / o2);
}

template<int L, typename T>
static PyObject *
vec_mod(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(glm::mod(glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1)), ((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for %: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(glm::mod(o, glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj2))));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(glm::mod(o, o2));
}

template<int L, typename T>
static PyObject *
vec_floordiv(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(floor(PyGLM_Number_FromPyObject<T>(obj1) / ((vec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for //: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(floor(o / PyGLM_Number_FromPyObject<T>(obj2)));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_vec<L, T>(floor(o / o2));
}

template<int L, typename T>
static PyObject *
vec_divmod(PyObject * obj1, PyObject * obj2) {
	PyObject *arg1, *arg2;
	arg1 = vec_floordiv<L, T>(obj1, obj2);
	arg2 = vec_mod<L, T>(obj1, obj2);
	if (arg1 == NULL || arg2 == NULL) {
		return NULL;
	}
	PyObject* out = PyTuple_Pack(2, arg1, arg2);
	Py_DECREF(arg1);
	Py_DECREF(arg2);
	return out;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
vec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3) {
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		T f = PyGLM_Number_FromPyObject<T>(obj1);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), ((vec<L, T>*)obj2)->super_type), o3));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		T f = PyGLM_Number_FromPyObject<T>(obj2);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(o, glm::vec<L, T>(f)));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), o3));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}



	// obj1 and obj2 can be interpreted as a vec
	if (obj3 == Py_None) {
		return pack_vec<L, T>(glm::pow(o, o2));
	}

	if (PyGLM_Number_Check(obj3)) {
		T f2 = PyGLM_Number_FromPyObject<T>(obj3);
		return pack_vec<L, T>(glm::mod(glm::pow(o, o2), glm::vec<L, T>(f2)));
	}

	glm::vec<L, T> o3;

	if (!unpack_vec(obj3, o3)) {
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
		return NULL;
	}

	return pack_vec<L, T>(glm::mod(glm::pow(o, o2), o3));
}

// inplace
// binaryfunc
template<int L, typename T>
static PyObject *
vec_iadd(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_add<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_isub(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_sub<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_imul(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_mul<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_idiv(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_div<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_imod(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_mod<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
vec_ifloordiv(vec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)vec_floordiv<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
vec_ipow(vec<L, T> *self, PyObject *obj1, PyObject *) // obj2 is unused. It points to an invalid address!
{
	vec<L, T> * temp = (vec<L, T>*)vec_pow<L, T>((PyObject*)self, obj1, Py_None);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
vec1_str(vec<1, T>* self)
{
	char * out = (char*)malloc((21) * sizeof(char));
	snprintf(out, 21, "vec1( %12.6g )", (double)self->super_type.x);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec2_str(vec<2, T>* self)
{
	char * out = (char*)malloc((35) * sizeof(char));
	snprintf(out, 35, "vec2( %12.6g, %12.6g )", (double)self->super_type.x, (double)self->super_type.y);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec3_str(vec<3, T>* self)
{
	char * out = (char*)malloc((49) * sizeof(char));
	snprintf(out, 49, "vec3( %12.6g, %12.6g, %12.6g )", (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
vec4_str(vec<4, T>* self)
{
	char * out = (char*)malloc((63) * sizeof(char));
	snprintf(out, 63, "vec4( %12.6g, %12.6g, %12.6g, %12.6g )", (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int L>
static Py_ssize_t vec_len(PyObject *) {
	return (Py_ssize_t)L;
}

template<typename T>
static PyObject* vec1_sq_item(vec<1, T> * self, Py_ssize_t index) {
	if (index == 0) {
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	}
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return NULL;
}

template<typename T>
static PyObject* vec2_sq_item(vec<2, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* vec3_sq_item(vec<3, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.z);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* vec4_sq_item(vec<4, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.z);
	case 3:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type.w);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static int vec1_sq_ass_item(vec<1, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	if (index == 0) {
		self->super_type.x = f;
		return 0;
	}
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return -1;
}

template<typename T>
static int vec2_sq_ass_item(vec<2, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int vec3_sq_ass_item(vec<3, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	case 2:
		self->super_type.z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int vec4_sq_ass_item(vec<4, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type.x = f;
		return 0;
	case 1:
		self->super_type.y = f;
		return 0;
	case 2:
		self->super_type.z = f;
		return 0;
	case 3:
		self->super_type.z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<int L, typename T>
static int vec_contains(vec<L, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < L; i++) {
			if (f == self->super_type[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<int L, typename T>
static PyObject * vec_richcompare(vec<L, T> * self, PyObject * other, int comp_type) {
	glm::vec<L, T> o2;

	if (!unpack_vec(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_LT:
		return pack_vec<L, T>(glm::lessThan(self->super_type, o2));
		break;
	case Py_LE:
		return pack_vec<L, T>(glm::lessThanEqual(self->super_type, o2));
		break;
	case Py_GT:
		return pack_vec<L, T>(glm::greaterThan(self->super_type, o2));
		break;
	case Py_GE:
		return pack_vec<L, T>(glm::greaterThanEqual(self->super_type, o2));
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

template<typename T>
static bool unswizzle_vec(vec<1, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<2, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<3, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type.z;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_vec(vec<4, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type.x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type.y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type.z;
		return true;
	}
	if (c == 'w' || c == 'a' || c == 'p') {
		out = self->super_type.w;
		return true;
	}
	return false;
}

//template<int L, typename T>
//static bool unswizzle_vec(vec<L, T>* self, char c, T& out) {
//	if (L == 2) {
//		return unswizzle_vec2<T>(self, c, out);
//	}
//	if (L == 3) {
//		return unswizzle_vec3<T>(self, c, out);
//	}
//	return unswizzle_vec4<T>(self, c, out);
//}

template<int L, typename T>
static PyObject * vec_getattr(PyObject * obj, PyObject * name) {
	char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);

	if (len >= 4 && name_as_ccp[0] == '_' && name_as_ccp[1] == '_' && name_as_ccp[len - 1] == '_' && name_as_ccp[len - 2] == '_') {
		return PyObject_GenericGetAttr(obj, name);
	}
	if (len == 1) {
		T x;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x)) {
			return PyGLM_PyObject_FromNumber<T>((T)x);
		}
	}
	else if (len == 2) {
		T x;
		T y;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y)) {
			return pack_vec<2, T>(glm::vec<2, T>(x, y));
		}
	}
	else if (len == 3) {
		T x;
		T y;
		T z;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[2], z)) {
			return pack_vec<3, T>(glm::vec<3, T>(x, y, z));
		}
	}
	else if (len == 4) {
		T x;
		T y;
		T z;
		T w;
		if (unswizzle_vec((vec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[2], z) && unswizzle_vec((vec<L, T> *)obj, name_as_ccp[3], w)) {
			return pack_vec<4, T>(glm::vec<4, T>(x, y, z, w));
		}
	}
	return PyObject_GenericGetAttr(obj, name);
}

// iterator

template<int L, typename T>
static PyObject *
vecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	vec<L, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	vecIter<L, T> *rgstate = (vecIter<L, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static void
vecIter_dealloc(vecIter<L, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
vec1Iter_next(vecIter<1, T> *rgstate)
{
	if (rgstate->seq_index++ == 0) {
		return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
	}
	rgstate->seq_index = 1;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec2Iter_next(vecIter<2, T> *rgstate)
{
	if (rgstate->seq_index < 2) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		}
	}
	rgstate->seq_index = 2;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec3Iter_next(vecIter<3, T> *rgstate)
{
	if (rgstate->seq_index < 3) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.z);
		}
	}
	rgstate->seq_index = 3;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
vec4Iter_next(vecIter<4, T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.z);
		case 3:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type.w);
		}
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int L, typename T>
static PyObject * vec_geniter(vec<L, T>* self) {
	vecIter<L, T> *rgstate = (vecIter<L, T> *)(PyGLM_VECITER_TYPE<L, T>()->tp_alloc(PyGLM_VECITER_TYPE<L, T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static int
vec_getbuffer(vec<L, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0];
	view->len = sizeof(glm::vec<L, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ?	const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ?				const_cast<char*>("d") : \
		(std::is_same <T, std::int8_t>::value) ?		const_cast<char*>("c") : \
		(std::is_same <T, std::uint8_t>::value) ?		const_cast<char*>("b") : \
		(std::is_same <T, std::int16_t>::value) ?		const_cast<char*>("h") : \
		(std::is_same <T, std::uint16_t>::value) ?		const_cast<char*>("H") : \
		(std::is_same <T, std::int32_t>::value) ?		const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ?		const_cast<char*>("I") : \
		(std::is_same <T, std::int64_t>::value) ?		const_cast<char*>("L") : \
		(std::is_same <T, std::uint64_t>::value) ?		const_cast<char*>("K") : \
		(std::is_same <T, bool>::value) ?				const_cast<char*>("p") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = L;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
vec_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}
#pragma endregion 

// type mvec
#pragma region type mvec
template<int L, typename T>
static void
mvec_dealloc(PyObject* self)
{
	Py_XDECREF(((mvec<L, T>*)self)->master);
	self->ob_type->tp_free(self);
}

// unaryfunc
template<int L, typename T>
static PyObject *
mvec_neg(mvec<L, T> *obj)
{
	return pack_vec<L, T>(-*obj->super_type);
}

template<int L, typename T>
static PyObject *
mvec_pos(mvec<L, T> *obj)
{
	return pack_vec<L, T>(*obj->super_type);
}

template<int L, typename T>
static PyObject *
mvec_abs(mvec<L, T> *obj)
{
	return pack_vec<L, T>(glm::abs(*obj->super_type));
}

// binaryfunc
template<int L, typename T>
static PyObject *
mvec_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) + *(((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o + o2);
}

template<int L, typename T>
static PyObject *
mvec_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) - *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o - o2);
}

template<int L, typename T>
static PyObject *
mvec_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) * *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(o * o2);
}

template<int L, typename T>
static PyObject *
mvec_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1) / *((mvec<L, T>*)obj2)->super_type);
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return  pack_vec<L, T>(o / o2);
}

template<int L, typename T>
static PyObject *
mvec_mod(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(glm::mod(glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj1)), *((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for %: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(glm::mod(o, glm::vec<L, T>(PyGLM_Number_FromPyObject<T>(obj2))));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(glm::mod(o, o2));
}

template<int L, typename T>
static PyObject *
mvec_floordiv(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_vec<L, T>(floor(PyGLM_Number_FromPyObject<T>(obj1) / *((mvec<L, T>*)obj2)->super_type));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for //: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_vec<L, T>(floor(o / PyGLM_Number_FromPyObject<T>(obj2)));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a mvec
	return pack_vec<L, T>(floor(o / o2));
}

template<int L, typename T>
static PyObject *
mvec_divmod(PyObject * obj1, PyObject * obj2) {
	PyObject *arg1, *arg2;
	arg1 = mvec_floordiv<L, T>(obj1, obj2);
	arg2 = mvec_mod<L, T>(obj1, obj2);
	if (arg1 == NULL || arg2 == NULL) {
		return NULL;
	}
	PyObject* out = PyTuple_Pack(2, arg1, arg2);
	Py_DECREF(arg1);
	Py_DECREF(arg2);
	return out;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
mvec_pow(PyObject * obj1, PyObject * obj2, PyObject * obj3) {
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		T f = PyGLM_Number_FromPyObject<T>(obj1);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(glm::vec<L, T>(f), *((mvec<L, T>*)obj2)->super_type), o3));
	}

	glm::vec<L, T> o;

	if (!unpack_vec(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: 'glm::vec' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		T f = PyGLM_Number_FromPyObject<T>(obj2);

		if (obj3 == Py_None) {
			return pack_vec<L, T>(glm::pow(o, glm::vec<L, T>(f)));
		}

		if (PyGLM_Number_Check(obj3)) {
			T f2 = PyGLM_Number_FromPyObject<T>(obj3);
			return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), glm::vec<L, T>(f2)));
		}

		glm::vec<L, T> o3;

		if (!unpack_vec(obj3, o3)) {
			PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
			return NULL;
		}

		return pack_vec<L, T>(glm::mod(glm::pow(o, glm::vec<L, T>(f)), o3));
	}

	glm::vec<L, T> o2;

	if (!unpack_vec(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}



	// obj1 and obj2 can be interpreted as a mvec
	if (obj3 == Py_None) {
		return pack_vec<L, T>(glm::pow(o, o2));
	}

	if (PyGLM_Number_Check(obj3)) {
		T f2 = PyGLM_Number_FromPyObject<T>(obj3);
		return pack_vec<L, T>(glm::mod(glm::pow(o, o2), glm::vec<L, T>(f2)));
	}

	glm::vec<L, T> o3;

	if (!unpack_vec(obj3, o3)) {
		PyGLM_TYPEERROR_O("unsupported operand type(s) for **: ", obj3);
		return NULL;
	}

	return pack_vec<L, T>(glm::mod(glm::pow(o, o2), o3));
}

// inplace
// binaryfunc
template<int L, typename T>
static PyObject *
mvec_iadd(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_add<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_isub(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_sub<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_imul(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_mul<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_idiv(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_div<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_imod(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_mod<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int L, typename T>
static PyObject *
mvec_ifloordiv(mvec<L, T> *self, PyObject *obj)
{
	vec<L, T> * temp = (vec<L, T>*)mvec_floordiv<L, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

// ternaryfunc
template<int L, typename T>
static PyObject *
mvec_ipow(mvec<L, T> *self, PyObject *obj1, PyObject * obj2) // obj2 is unused. It points to an invalid address!
{
	vec<L, T> * temp = (vec<L, T>*)mvec_pow<L, T>((PyObject*)self, obj1, Py_None);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	*self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
mvec2_str(mvec<2, T>* self)
{
	char * out = (char*)malloc((36) * sizeof(char));
	snprintf(out, 36, "mvec2( %12.6g, %12.6g )", (double)self->super_type->x, (double)self->super_type->y);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mvec3_str(mvec<3, T>* self)
{
	char * out = (char*)malloc((50) * sizeof(char));
	snprintf(out, 50, "mvec3( %12.6g, %12.6g, %12.6g )", (double)self->super_type->x, (double)self->super_type->y, (double)self->super_type->z);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mvec4_str(mvec<4, T>* self)
{
	char * out = (char*)malloc((64) * sizeof(char));
	snprintf(out, 64, "mvec4( %12.6g, %12.6g, %12.6g, %12.6g )", (double)self->super_type->x, (double)self->super_type->y, (double)self->super_type->z, (double)self->super_type->w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int L>
static Py_ssize_t mvec_len(PyObject * self) {
	return (Py_ssize_t)L;
}

template<typename T>
static PyObject* mvec2_sq_item(mvec<2, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* mvec3_sq_item(mvec<3, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->z);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static PyObject* mvec4_sq_item(mvec<4, T> * self, Py_ssize_t index) {
	switch (index) {
	case 0:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->x);
	case 1:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->y);
	case 2:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->z);
	case 3:
		return PyGLM_PyObject_FromNumber<T>((T)self->super_type->w);
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
}

template<typename T>
static int mvec2_sq_ass_item(mvec<2, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int mvec3_sq_ass_item(mvec<3, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	case 2:
		self->super_type->z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<typename T>
static int mvec4_sq_ass_item(mvec<4, T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	switch (index) {
	case 0:
		self->super_type->x = f;
		return 0;
	case 1:
		self->super_type->y = f;
		return 0;
	case 2:
		self->super_type->z = f;
		return 0;
	case 3:
		self->super_type->z = f;
		return 0;
	default:
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
}

template<int L, typename T>
static int mvec_contains(mvec<L, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < L; i++) {
			if (f == (*self->super_type)[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<int L, typename T>
static PyObject * mvec_richcompare(mvec<L, T> * self, PyObject * other, int comp_type) {
	glm::vec<L, T> o2;

	if (!unpack_vec(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (*self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (*self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_LT:
		return pack_vec<L, T>(glm::lessThan(*self->super_type, o2));
		break;
	case Py_LE:
		return pack_vec<L, T>(glm::lessThanEqual(*self->super_type, o2));
		break;
	case Py_GT:
		return pack_vec<L, T>(glm::greaterThan(*self->super_type, o2));
		break;
	case Py_GE:
		return pack_vec<L, T>(glm::greaterThanEqual(*self->super_type, o2));
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

template<typename T>
static bool unswizzle_mvec(mvec<2, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_mvec(mvec<3, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type->z;
		return true;
	}
	return false;
}

template<typename T>
static bool unswizzle_mvec(mvec<4, T> * self, char c, T& out) {
	if (c == 'x' || c == 'r' || c == 's') {
		out = self->super_type->x;
		return true;
	}
	if (c == 'y' || c == 'g' || c == 't') {
		out = self->super_type->y;
		return true;
	}
	if (c == 'z' || c == 'b' || c == 'q') {
		out = self->super_type->z;
		return true;
	}
	if (c == 'w' || c == 'a' || c == 'p') {
		out = self->super_type->w;
		return true;
	}
	return false;
}

//template<int L, typename T>
//static bool unswizzle_mvec(mvec<L, T>* self, char c, T& out) {
//	if (L == 2) {
//		return unswizzle_mvec2<T>(self, c, out);
//	}
//	if (L == 3) {
//		return unswizzle_mvec3<T>(self, c, out);
//	}
//	return unswizzle_mvec4<T>(self, c, out);
//}

template<int L, typename T>
static PyObject * mvec_getattr(PyObject * obj, PyObject * name) {
	char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);

	if (len >= 4 && name_as_ccp[0] == '_' && name_as_ccp[1] == '_' && name_as_ccp[len - 1] == '_' && name_as_ccp[len - 2] == '_') {
		return PyObject_GenericGetAttr(obj, name);
	}
	if (len == 1) {
		T x;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x)) {
			return PyGLM_PyObject_FromNumber<T>((T)x);
		}
	}
	else if (len == 2) {
		T x;
		T y;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y)) {
			return pack_vec<2, T>(glm::vec<2, T>(x, y));
		}
	}
	else if (len == 3) {
		T x;
		T y;
		T z;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[2], z)) {
			return pack_vec<3, T>(glm::vec<3, T>(x, y, z));
		}
	}
	else if (len == 4) {
		T x;
		T y;
		T z;
		T w;
		if (unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[0], x) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[1], y) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[2], z) && unswizzle_mvec((mvec<L, T> *)obj, name_as_ccp[3], w)) {
			return pack_vec<4, T>(glm::vec<4, T>(x, y, z, w));
		}
	}
	return PyObject_GenericGetAttr(obj, name);
}

template<typename T>
static int mvec2_setattr(mvec<2, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}
template<typename T>
static int mvec3_setattr(mvec<3, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'z') {
		obj->super_type->z = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}
template<typename T>
static int mvec4_setattr(mvec<4, T>* obj, PyObject* name, PyObject* value) {
	const char * name_as_ccp = PyGLM_String_AsString(name);
	size_t len = strlen(name_as_ccp);
	if (!PyGLM_Number_Check(value) || len != 1) {
		return PyObject_GenericSetAttr((PyObject*)obj, name, value);
	}
	if (name_as_ccp[0] == 'x') {
		obj->super_type->x = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'y') {
		obj->super_type->y = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'z') {
		obj->super_type->z = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	if (name_as_ccp[0] == 'w') {
		obj->super_type->w = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	return PyObject_GenericSetAttr((PyObject*)obj, name, value);
}

// iterator

template<int L, typename T>
static PyObject *
mvecIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	mvec<L, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	mvecIter<L, T> *rgstate = (mvecIter<L, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static void
mvecIter_dealloc(mvecIter<L, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
mvec2Iter_next(mvecIter<2, T> *rgstate)
{
	if (rgstate->seq_index < 2) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		}
	}
	rgstate->seq_index = 2;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
mvec3Iter_next(mvecIter<3, T> *rgstate)
{
	if (rgstate->seq_index < 3) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->z);
		}
	}
	rgstate->seq_index = 3;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject *
mvec4Iter_next(mvecIter<4, T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		switch (rgstate->seq_index++) {
		case 0:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->x);
		case 1:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->y);
		case 2:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->z);
		case 3:
			return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type->w);
		}
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int L, typename T>
static PyObject * mvec_geniter(mvec<L, T>* self) {
	mvecIter<L, T> *rgstate = (mvecIter<L, T> *)(PyGLM_MVECITER_TYPE<L, T>()->tp_alloc(PyGLM_MVECITER_TYPE<L, T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int L, typename T>
static int
mvec_getbuffer(mvec<L, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)self->super_type;
	view->len = sizeof(glm::vec<L, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : \
		(std::is_same <T, std::int32_t>::value) ? const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ? const_cast<char*>("I") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = L;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
mvec_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}
#pragma endregion 

// type vec
#pragma region type mat
template<int C>
static PyObject* mat_length(PyObject * self, PyObject* arg) {
	return PyLong_FromLong(C);
}

static void
mat_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<int C, int R, typename T>
static PyObject *
mat_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	mat<C, R, T> *self = (mat<C, R, T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->super_type = glm::mat<C, R, T>();
	}
	return (PyObject *)self;
}


template<typename T>
static int
mat2x2_init(mat<2, 2, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	
	if (!PyArg_UnpackTuple(args, "mat2x2", 0, 4,
		&arg1, &arg2, &arg3, &arg4)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
		
	if (arg1 == NULL) {
		return 0;
	}
	
	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
	
	if (arg3 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
			return -1;
		}
		self->super_type = glm::mat<2, 2, T>(o, o2);
		return 0;
	}
	
	if (arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
		return -1;
	}
	
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
		self->super_type = glm::mat<2, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x2()");
	return -1;
}

template<typename T>
static int
mat2x3_init(mat<2, 3, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;

	if (!PyArg_UnpackTuple(args, "mat2x3", 0, 6,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (arg3 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
			return -1;
		}
		self->super_type = glm::mat<2, 3, T>(o, o2);
		return 0;
	}

	if (arg4 == NULL || arg5 == NULL || arg6 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {
		self->super_type = glm::mat<2, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x3()");
	return -1;
}

template<typename T>
static int
mat2x4_init(mat<2, 4, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;

	if (!PyArg_UnpackTuple(args, "mat2x4", 0, 8,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<2, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (arg3 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
			return -1;
		}
		self->super_type = glm::mat<2, 4, T>(o, o2);
		return 0;
	}

	if (arg4 == NULL || arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8)) {
		self->super_type = glm::mat<2, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat2x4()");
	return -1;
}

template<typename T>
static int
mat3x2_init(mat<3, 2, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x2", 0, 6,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		glm::vec<2, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
			return -1;
		}
		self->super_type = glm::mat<3, 2, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {
		self->super_type = glm::mat<3, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x2()");
	return -1;
}

template<typename T>
static int
mat3x3_init(mat<3, 3, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x3", 0, 9,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		glm::vec<3, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
			return -1;
		}
		self->super_type = glm::mat<3, 3, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9)) {
		self->super_type = glm::mat<3, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x3()");
	return -1;
}

template<typename T>
static int
mat3x4_init(mat<3, 4, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;

	if (!PyArg_UnpackTuple(args, "mat3x4", 0, 12,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<3, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg3 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (arg4 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		glm::vec<4, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
			return -1;
		}
		self->super_type = glm::mat<3, 4, T>(o, o2, o3);
		return 0;
	}

	if (arg5 == NULL || arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12)) {
		self->super_type = glm::mat<3, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat3x4()");
	return -1;
}

template<typename T>
static int
mat4x2_init(mat<4, 2, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x2", 0, 8,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 2, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<2, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		glm::vec<2, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
			return -1;
		}
		self->super_type = glm::mat<4, 2, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8)) {
		self->super_type = glm::mat<4, 2, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x2()");
	return -1;
}

template<typename T>
static int
mat4x3_init(mat<4, 3, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x3", 0, 12,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 3, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<3, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		glm::vec<3, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
			return -1;
		}
		self->super_type = glm::mat<4, 3, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12)) {
		self->super_type = glm::mat<4, 3, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x3()");
	return -1;
}

template<typename T>
static int
mat4x4_init(mat<4, 4, T> *self, PyObject *args, PyObject *kwds)
{
	PyObject *arg1 = NULL;
	PyObject *arg2 = NULL;
	PyObject *arg3 = NULL;
	PyObject *arg4 = NULL;
	PyObject *arg5 = NULL;
	PyObject *arg6 = NULL;
	PyObject *arg7 = NULL;
	PyObject *arg8 = NULL;
	PyObject *arg9 = NULL;
	PyObject *arg10 = NULL;
	PyObject *arg11 = NULL;
	PyObject *arg12 = NULL;
	PyObject *arg13 = NULL;
	PyObject *arg14 = NULL;
	PyObject *arg15 = NULL;
	PyObject *arg16 = NULL;

	if (!PyArg_UnpackTuple(args, "mat4x4", 0, 16,
		&arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13, &arg14, &arg15, &arg16)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg1 == NULL) {
		return 0;
	}

	if (arg2 == NULL) {
		if (PyGLM_Number_Check(arg1)) {
			self->super_type = glm::mat<4, 4, T>(PyGLM_Number_FromPyObject<T>(arg1));
			return 0;
		}
		if (PyGLM_Mat_Check(2, 2, T, arg1)) {
			self->super_type = unpack_mat<2, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 3, T, arg1)) {
			self->super_type = unpack_mat<2, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(2, 4, T, arg1)) {
			self->super_type = unpack_mat<2, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 2, T, arg1)) {
			self->super_type = unpack_mat<3, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 3, T, arg1)) {
			self->super_type = unpack_mat<3, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(3, 4, T, arg1)) {
			self->super_type = unpack_mat<3, 4, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 2, T, arg1)) {
			self->super_type = unpack_mat<4, 2, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 3, T, arg1)) {
			self->super_type = unpack_mat<4, 3, T>(arg1);
			return 0;
		}
		if (PyGLM_Mat_Check(4, 4, T, arg1)) {
			self->super_type = unpack_mat<4, 4, T>(arg1);
			return 0;
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg3 == NULL || arg4 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (arg5 == NULL) {
		glm::vec<4, T> o;
		if (!unpack_vec(arg1, o)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o2;
		if (!unpack_vec(arg2, o2)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o3;
		if (!unpack_vec(arg3, o3)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		glm::vec<4, T> o4;
		if (!unpack_vec(arg4, o4)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
			return -1;
		}
		self->super_type = glm::mat<4, 4, T>(o, o2, o3, o4);
		return 0;
	}

	if (arg6 == NULL || arg7 == NULL || arg8 == NULL || arg9 == NULL || arg10 == NULL || arg11 == NULL || arg12 == NULL || arg13 == NULL || arg14 == NULL || arg15 == NULL || arg16 == NULL) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
		return -1;
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6) && PyGLM_Number_Check(arg7) && PyGLM_Number_Check(arg8) && PyGLM_Number_Check(arg9) && PyGLM_Number_Check(arg10) && PyGLM_Number_Check(arg11) && PyGLM_Number_Check(arg12) && PyGLM_Number_Check(arg13) && PyGLM_Number_Check(arg14) && PyGLM_Number_Check(arg15) && PyGLM_Number_Check(arg16)) {
		self->super_type = glm::mat<4, 4, T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4), PyGLM_Number_FromPyObject<T>(arg5), PyGLM_Number_FromPyObject<T>(arg6), PyGLM_Number_FromPyObject<T>(arg7), PyGLM_Number_FromPyObject<T>(arg8), PyGLM_Number_FromPyObject<T>(arg9), PyGLM_Number_FromPyObject<T>(arg10), PyGLM_Number_FromPyObject<T>(arg11), PyGLM_Number_FromPyObject<T>(arg12), PyGLM_Number_FromPyObject<T>(arg13), PyGLM_Number_FromPyObject<T>(arg14), PyGLM_Number_FromPyObject<T>(arg15), PyGLM_Number_FromPyObject<T>(arg16));
		return 0;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mat4x4()");
	return -1;
}

// unaryfunc
template<int C, int R, typename T>
static PyObject *
mat_neg(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(-obj->super_type);
}

template<int C, int R, typename T>
static PyObject *
mat_pos(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(obj->super_type);
}

template<int C, int R, typename T>
static PyObject *
mat_abs(mat<C, R, T> *obj)
{
	return pack_mat<C, R, T>(glm::abs(obj->super_type));
}

// binaryfunc
template<int C, int R, typename T>
static PyObject *
matsq_add(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) + (((mat<C, R, T>*)obj2)->super_type));
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm::mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o + o2);
}

template<int C, int R, typename T>
static PyObject *
mat_add(PyObject *obj1, PyObject *obj2)
{
	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm::mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o + PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o + o2);
}

template<int C, int R, typename T>
static PyObject *
matsq_sub(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) - (((mat<C, R, T>*)obj2)->super_type));
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm::mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o - o2);
}

template<int C, int R, typename T>
static PyObject *
mat_sub(PyObject *obj1, PyObject *obj2)
{
	glm::mat<C, R, T> o;

	if (!unpack_mat(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm::mat' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_mat<C, R, T>(o - PyGLM_Number_FromPyObject<T>(obj2));
	}

	glm::mat<C, R, T> o2;

	if (!unpack_mat(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a vec
	return pack_mat<C, R, T>(o - o2);
}

template<int C, int R, typename T>
static PyObject *
mat_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat(PyGLM_Number_FromPyObject<T>(obj1) * ((mat<C, R, T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(R, T, obj1)) { // obj1 is a col_type
		glm::vec<R, T> o;
		unpack_vec(obj1, o);

		return pack_vec(o * ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T> (obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for *: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(C, T, obj2)) { // obj2 is a row_type
		glm::vec<C, T> o2;
		unpack_vec(obj2, o2);

		return pack_vec(o * o2);
	}

	if (PyGLM_Mat_Check(2, C, T, obj2)) {
		glm::mat<2, C, T> o2;
		unpack_mat<2, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	if (PyGLM_Mat_Check(3, C, T, obj2)) {
		glm::mat<3, C, T> o2;
		unpack_mat<3, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	if (PyGLM_Mat_Check(4, C, T, obj2)) {
		glm::mat<4, C, T> o2;
		unpack_mat<4, C, T>(obj2, o2);

		return pack_mat(o * o2);
	}

	Py_RETURN_NOTIMPLEMENTED;
}

template<int C, int R, typename T>
static PyObject *
matsq_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat<C, R, T>(PyGLM_Number_FromPyObject<T>(obj1) / ((mat<C, R, T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(R, T, obj1)) { // obj1 is a col_type
		glm::vec<R, T> o;
		unpack_vec(obj1, o);

		return pack_vec(o / ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T>(obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for /: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(C, T, obj2)) { // obj2 is a row_type
		glm::vec<C, T> o2;
		unpack_vec(obj2, o2);

		return pack_vec(o / o2);
	}

	if (PyGLM_Mat_Check(C, R, T, obj2)) {
		glm::mat<C, R, T> o2;
		unpack_mat<C, R, T>(obj2, o2);

		return pack_mat(o / o2);
	}
	Py_RETURN_NOTIMPLEMENTED;
}

template<int C, int R, typename T>
static PyObject *
mat_div(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar
		return pack_mat(PyGLM_Number_FromPyObject<T>(obj1) / ((mat<C, R, T>*)obj2)->super_type);
	}

	glm::mat<C, R, T> o;

	if (!unpack_mat<C, R, T>(obj1, o)) { // obj1 can't be interpreted as mat<C, R, T>
		PyGLM_TYPEERROR_2O("unsupported operand type(s) for /: ", obj1, obj2);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj2 is a scalar
		return pack_mat(o / PyGLM_Number_FromPyObject<T>(obj2));
	}
	Py_RETURN_NOTIMPLEMENTED;
}

// inplace
// binaryfunc
template<int C, int R, typename T>
static PyObject *
matsq_iadd(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_add<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_iadd(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_add<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
matsq_isub(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_sub<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_isub(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_sub<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_imul(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_mul<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Mat_Check(C, R, T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
matsq_idiv(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)matsq_div<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Mat_Check(C, R, T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<int C, int R, typename T>
static PyObject *
mat_idiv(mat<C, R, T> *self, PyObject *obj)
{
	mat<C, R, T> * temp = (mat<C, R, T>*)mat_div<C, R, T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}



template<typename T>
static PyObject *
mat2x2_str(mat<2, 2, T>* self)
{
	char * out = (char*)malloc((64) * sizeof(char));
	snprintf(out, 64, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[1][0], (float)self->super_type[1][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x3_str(mat<2, 3, T>* self)
{
	char * out = (char*)malloc((94) * sizeof(char));
	snprintf(out, 94, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat2x4_str(mat<2, 4, T>* self)
{
	char * out = (char*)malloc((124) * sizeof(char));
	snprintf(out, 124, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[0][3], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2], (float)self->super_type[1][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x2_str(mat<3, 2, T>* self)
{
	char * out = (char*)malloc((96) * sizeof(char));
	snprintf(out, 96, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[2][0], (float)self->super_type[2][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x3_str(mat<3, 3, T>* self)
{
	char * out = (char*)malloc((141) * sizeof(char));
	snprintf(out, 141, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2], (float)self->super_type[2][0], (float)self->super_type[2][1], (float)self->super_type[2][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat3x4_str(mat<3, 4, T>* self)
{
	char * out = (char*)malloc((186) * sizeof(char));
	snprintf(out, 186, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[0][3], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2], (float)self->super_type[1][3], (float)self->super_type[2][0], (float)self->super_type[2][1], (float)self->super_type[2][2], (float)self->super_type[2][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x2_str(mat<4, 2, T>* self)
{
	char * out = (char*)malloc((128) * sizeof(char));
	snprintf(out, 128, "[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]\n[ %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[2][0], (float)self->super_type[2][1], (float)self->super_type[3][0], (float)self->super_type[3][1]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x3_str(mat<4, 3, T>* self)
{
	char * out = (char*)malloc((188) * sizeof(char));
	snprintf(out, 188, "[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2], (float)self->super_type[2][0], (float)self->super_type[2][1], (float)self->super_type[2][2], (float)self->super_type[3][0], (float)self->super_type[3][1], (float)self->super_type[3][2]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<typename T>
static PyObject *
mat4x4_str(mat<4, 4, T>* self)
{
	char * out = (char*)malloc((248) * sizeof(char));
	snprintf(out, 248, "[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]\n[ %12.6g | %12.6g | %12.6g | %12.6g ]", (float)self->super_type[0][0], (float)self->super_type[0][1], (float)self->super_type[0][2], (float)self->super_type[0][3], (float)self->super_type[1][0], (float)self->super_type[1][1], (float)self->super_type[1][2], (float)self->super_type[1][3], (float)self->super_type[2][0], (float)self->super_type[2][1], (float)self->super_type[2][2], (float)self->super_type[2][3], (float)self->super_type[3][0], (float)self->super_type[3][1], (float)self->super_type[3][2], (float)self->super_type[3][3]);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

template<int C>
static Py_ssize_t mat_len(PyObject * self) {
	return (Py_ssize_t)C;
}

template<typename T>
static PyObject* mat2x2_mp_item(mat<2, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat2x3_mp_item(mat<2, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat2x4_mp_item(mat<2, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x2_mp_item(mat<3, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x3_mp_item(mat<3, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat3x4_mp_item(mat<3, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x2_mp_item(mat<4, 2, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<2, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x3_mp_item(mat<4, 3, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<3, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static PyObject* mat4x4_mp_item(mat<4, 4, T> * self, PyObject* key) {
	if (PyGLM_Number_Check(key)) {
		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}
		return pack_mvec<4, T>(&self->super_type[index], (PyObject*)self);
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return NULL;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return NULL;
		}

		return PyGLM_PyObject_FromNumber<T>(self->super_type[value0_as_long][value1_as_long]);
	}
	PyGLM_TYPEERROR_O("index must be int or a length 2 tuple, got ", key);
	return NULL;
}

template<typename T>
static int mat2x2_mp_ass_item(mat<2, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat2x3_mp_ass_item(mat<2, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat2x4_mp_ass_item(mat<2, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 1 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x2_mp_ass_item(mat<3, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x3_mp_ass_item(mat<3, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat3x4_mp_ass_item(mat<3, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 2 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x2_mp_ass_item(mat<4, 2, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<2, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec2, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 1) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x3_mp_ass_item(mat<4, 3, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<3, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec3, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 2) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<typename T>
static int mat4x4_mp_ass_item(mat<4, 4, T> * self, PyObject* key, PyObject * value) {
	if (value == NULL) {
		PyErr_SetString(PyExc_NotImplementedError, "item deletion not supported");
		return -1;
	}
	if (PyGLM_Number_Check(key)) {
		glm::vec<4, T> o;

		if (!unpack_vec(value, o)) {
			PyGLM_TYPEERROR_O("expected vec4, got ", value);
			return -1;
		}

		long index = PyGLM_Number_AsLong(key);

		if (index < 0 || index > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[index] = o;
		return 0;
	}
	if (PyTuple_Check(key) && Py_SIZE(key) == 2) {
		if (!PyGLM_Number_Check(value)) {
			PyGLM_TYPEERROR_O("expected a number, got ", value);
			return -1;
		}

		PyObject* value0 = PyTuple_GET_ITEM(key, 0);
		PyObject* value1 = PyTuple_GET_ITEM(key, 1);

		if (value0 == NULL || value1 == NULL || !PyGLM_Number_Check(value0) || !PyGLM_Number_Check(value1)) {
			Py_XDECREF(value0);
			Py_XDECREF(value1);

			PyErr_SetString(PyExc_TypeError, "indices must be a pair of integer");
			return -1;
		}

		long value0_as_long = PyGLM_Number_AsLong(value0);
		long value1_as_long = PyGLM_Number_AsLong(value1);

		Py_DECREF(value0);
		Py_DECREF(value1);

		if (value0_as_long < 0 || value0_as_long > 3 || value1_as_long < 0 || value1_as_long > 3) {
			PyErr_SetString(PyExc_IndexError, "index out of range");
			return -1;
		}

		self->super_type[value0_as_long][value1_as_long] = PyGLM_Number_FromPyObject<T>(value);
		return 0;
	}
	PyGLM_TYPEERROR_O("index must be int or tuple, not ", key);
	return -1;
}

template<int C, int R, typename T>
static int mat_contains(mat<C, R, T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int n = 0; n < C; n++) {
			for (int m = 0; m < R; m++) {
				if (f == self->super_type[n][m]) {
					contains = true;
					break;
				}
			}
		}
		return (int)contains;
	}
	if (PyGLM_Vec_Check(R, T, value)) {
		glm::vec<R, T> o;
		unpack_vec(value, o);
		for (int n = 0; n < C; n++) {
			bool contains = true;
			for (int m = 0; m < R; m++) {
				if (o[m] != self->super_type[n][m]) {
					contains = false;
					break;
				}
			}
			if (contains) {
				return 1;
			}
		}
	}
	return 0;

}

template<int C, int R, typename T>
static PyObject * mat_richcompare(mat<C, R, T> * self, PyObject * other, int comp_type) {
	glm::mat<C, R, T> o2;

	if (!unpack_mat(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

// iterator

template<int C, int R, typename T>
static PyObject *
matIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	mat<C, R, T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	matIter<C, R, T> *rgstate = (matIter<C, R, T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int C, int R, typename T>
static void
matIter_dealloc(matIter<C, R, T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<int C, int R, typename T>
static PyObject *
matIter_next(matIter<C, R, T> *rgstate)
{
	if (rgstate->seq_index < C) {
		return pack_mvec<R, T>(&rgstate->sequence->super_type[rgstate->seq_index++], (PyObject*)rgstate->sequence);
	}
	rgstate->seq_index = C;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<int C, int R, typename T>
static PyObject * mat_geniter(mat<C, R, T>* self) {
	PyTypeObject* matIterType = PyGLM_MATITER_TYPE<C, R, T>();
	matIter<C, R, T> *rgstate = (matIter<C, R, T> *)(matIterType->tp_alloc(matIterType, 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<int C, int R, typename T>
static int
mat_getbuffer(mat<C, R, T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0][0];
	view->len = sizeof(glm::mat<C, R, T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : \
		(std::is_same <T, std::int32_t>::value) ? const_cast<char*>("i") : \
		(std::is_same <T, std::uint32_t>::value) ? const_cast<char*>("I") : NULL;
	view->ndim = 2;
	view->shape = (Py_ssize_t*)malloc(2 * sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = C;
		view->shape[1] = R;
	}
	view->strides = (Py_ssize_t*)malloc(2 * sizeof(Py_ssize_t));
	if (view->strides != NULL) {
		view->strides[0] = sizeof(typename glm::mat<C, R, T>::col_type);
		view->strides[1] = sizeof(T);
	}
	
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
mat_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
	free(view->strides);
}
#pragma endregion 

// type qua
#pragma region type qua
static PyObject* qua_length(PyObject*, PyObject*) {
	return PyLong_FromLong(4);
}

static void
qua_dealloc(PyObject* self)
{
	Py_TYPE(self)->tp_free(self);
}

template<typename T>
static PyObject *
qua_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	qua<T> *self = (qua<T> *)type->tp_alloc(type, 0);
	if (self != NULL) {
		self->super_type = glm::qua<T>();
	}

	return (PyObject *)self;
}

template<typename T>
static int
qua_init(qua<T> *self, PyObject *args, PyObject *kwds)
{
	const char *kwlist[] = { "x", "y", "z", "w", NULL };

	PyObject * arg1 = NULL;
	PyObject * arg2 = NULL;
	PyObject * arg3 = NULL;
	PyObject * arg4 = NULL;

	if (PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", const_cast<char**>(kwlist),
		&arg1, &arg2, &arg3, &arg4)) {
		if (arg1 == NULL) {
			return 0;
		}
		if (arg2 == NULL) {
			if (PyGLM_Qua_Check(T, arg1)) {
				glm::qua<T> o;
				if (unpack_qua(arg1, o)) {
					self->super_type = o;
					return 0;
				}
			}
			else if (PyGLM_Vec_Check(3, T, arg1)) {
				glm::vec<3, T> o;
				if (unpack_vec(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			else if (PyGLM_Mat_Check(3, 3, T, arg1)) {
				glm::mat<3, 3, T> o;
				if (unpack_mat(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			else if (PyGLM_Mat_Check(4, 4, T, arg1)) {
				glm::mat<4, 4, T> o;
				if (unpack_mat(arg1, o)) {
					self->super_type = glm::qua<T>(o);
					return 0;
				}
			}
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
			return -1;
		}
		if (arg3 == NULL) {
			if (PyGLM_Number_Check(arg1)) {
				glm::vec<3, T> o;
				if (!unpack_vec(arg2, o)) {
					PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
					return -1;
				}
				self->super_type = glm::qua<T>(PyGLM_Number_FromPyObject<T>(arg1), o);
				return 0;
			}
			glm::vec<3, T> o;
			if (!unpack_vec(arg1, o)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
				return -1;
			}
			glm::vec<3, T> o2;
			if (!unpack_vec(arg2, o2)) {
				PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
				return -1;
			}
			self->super_type = glm::qua<T>(o, o2);
			return 0;
		}
		if (arg4 == NULL) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
			return -1;
		}
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
			self->super_type = glm::qua<T>(PyGLM_Number_FromPyObject<T>(arg1), PyGLM_Number_FromPyObject<T>(arg2), PyGLM_Number_FromPyObject<T>(arg3), PyGLM_Number_FromPyObject<T>(arg4));
			return 0;
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for quat()");
	return -1;
}

// unaryfunc
template<typename T>
static PyObject *
qua_neg(qua<T> *obj)
{
	return pack_qua<T>(-obj->super_type);
}

template<typename T>
static PyObject *
qua_pos(qua<T> *obj)
{
	return pack_qua<T>(obj->super_type);
}

// binaryfunc
template<typename T>
static PyObject *
qua_add(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for +: 'glm::qua' and ", obj1);
		return NULL;
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o + o2);
}

template<typename T>
static PyObject *
qua_sub(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for -: 'glm::qua' and ", obj1);
		return NULL;
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o - o2);
}

template<typename T>
static PyObject *
qua_mul(PyObject *obj1, PyObject *obj2)
{
	if (PyGLM_Number_Check(obj1)) { // obj1 is a scalar, obj2 is self
		return pack_qua<T>(PyGLM_Number_FromPyObject<T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(3, T, obj1)) {
		return pack_vec<3, T>(unpack_vec<3, T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	if (PyGLM_Vec_Check(4, T, obj1)) {
		return pack_vec<4, T>(unpack_vec<4, T>(obj1) * ((qua<T>*)obj2)->super_type);
	}

	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for *: 'glm::qua' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_qua<T>(o * PyGLM_Number_FromPyObject<T>(obj2));
	}

	if (PyGLM_Vec_Check(3, T, obj2)) {
		return pack_vec<3, T>(o * unpack_vec<3, T>(obj2));
	}

	if (PyGLM_Vec_Check(4, T, obj2)) {
		return pack_vec<4, T>(o * unpack_vec<4, T>(obj2));
	}

	glm::qua<T> o2;

	if (!unpack_qua(obj2, o2)) { // obj1 is self, obj2 is something else (maybe it knows how to do the operation)
		Py_RETURN_NOTIMPLEMENTED;
	}

	// obj1 and obj2 can be interpreted as a qua
	return pack_qua<T>(o * o2);
}

template<typename T>
static PyObject *
qua_div(PyObject *obj1, PyObject *obj2)
{
	glm::qua<T> o;

	if (!unpack_qua(obj1, o)) { // obj1 is not supported.
		PyGLM_TYPEERROR_O("unsupported operand type(s) for /: 'glm::qua' and ", obj1);
		return NULL;
	}

	if (PyGLM_Number_Check(obj2)) { // obj1 is self, obj2 is a scalar
		return pack_qua<T>(o / PyGLM_Number_FromPyObject<T>(obj2));
	}

	Py_RETURN_NOTIMPLEMENTED;
}

// inplace
// binaryfunc
template<typename T>
static PyObject *
qua_iadd(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_add<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_isub(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_sub<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_imul(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_mul<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	if (!PyGLM_Qua_Check(T, temp)) {
		Py_DECREF(temp);
		Py_RETURN_NOTIMPLEMENTED;
	}

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_idiv(qua<T> *self, PyObject *obj)
{
	qua<T> * temp = (qua<T>*)qua_div<T>((PyObject*)self, obj);

	if (Py_IS_NOTIMPLEMENTED(temp)) return (PyObject*)temp;

	self->super_type = temp->super_type;

	Py_DECREF(temp);
	Py_INCREF(self);
	return (PyObject*)self;
}

template<typename T>
static PyObject *
qua_str(qua<T>* self)
{
	char * out = (char*)malloc((63) * sizeof(char));
	snprintf(out, 63, "quat( %12.6g, %12.6g, %12.6g, %12.6g )", (double)self->super_type.x, (double)self->super_type.y, (double)self->super_type.z, (double)self->super_type.w);
	PyObject* po = PyUnicode_FromString(out);
	free(out);
	return po;
}

static Py_ssize_t qua_len(PyObject*) {
	return (Py_ssize_t)4;
}

template<typename T>
static PyObject* qua_sq_item(qua<T> * self, Py_ssize_t index) {
	if (index < 0 || index > 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	return PyGLM_PyObject_FromNumber<T>((T)self->super_type[(glm::length_t)index]);
}

template<typename T>
static int qua_sq_ass_item(qua<T> * self, Py_ssize_t index, PyObject * value) {
	T f;
	if (PyGLM_Number_Check(value)) {
		f = PyGLM_Number_FromPyObject<T>(value);
	}
	else {
		PyGLM_TYPEERROR_O("must be a real number, not ", value);
		return -1;
	}
	if (index < 0 || index > 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return -1;
	}
	self->super_type[(glm::length_t)index] = f;

	return 0;
}

template<typename T>
static int qua_contains(qua<T> * self, PyObject * value) {
	if (PyGLM_Number_Check(value)) {
		T f = PyGLM_Number_FromPyObject<T>(value);
		bool contains = false;
		for (int i = 0; i < 4; i++) {
			if (f == self->super_type[i]) {
				contains = true;
				break;
			}
		}
		return (int)contains;
	}
	return 0;

}

template<typename T>
static PyObject * qua_richcompare(qua<T> * self, PyObject * other, int comp_type) {
	glm::qua<T> o2;

	if (!unpack_qua(other, o2)) {
		if (comp_type == Py_EQ) {
			Py_RETURN_FALSE;
		}
		if (comp_type == Py_NE) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_NOTIMPLEMENTED;
	}

	switch (comp_type) {
	case Py_EQ:
		if (self->super_type == o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	case Py_NE:
		if (self->super_type != o2) Py_RETURN_TRUE;
		else Py_RETURN_FALSE;
		break;
	default:
		Py_RETURN_NOTIMPLEMENTED;
	}
}

// iterator

template<typename T>
static PyObject *
quaIter_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	qua<T> *sequence;

	if (!PyArg_UnpackTuple(args, "__iter__", 1, 1, &sequence))
		return NULL;

	quaIter<T> *rgstate = (quaIter<T> *)type->tp_alloc(type, 0);
	if (!rgstate)
		return NULL;

	rgstate->sequence = sequence;
	Py_INCREF(sequence);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<typename T>
static void
quaIter_dealloc(quaIter<T> *rgstate)
{
	Py_XDECREF(rgstate->sequence);
	Py_TYPE(rgstate)->tp_free(rgstate);
}

template<typename T>
static PyObject *
quaIter_next(quaIter<T> *rgstate)
{
	if (rgstate->seq_index < 4) {
		return PyGLM_PyObject_FromNumber<T>(rgstate->sequence->super_type[rgstate->seq_index++]);
	}
	rgstate->seq_index = 4;
	Py_CLEAR(rgstate->sequence);
	return NULL;
}

template<typename T>
static PyObject * qua_geniter(qua<T>* self) {
	quaIter<T> *rgstate = (quaIter<T> *)(PyGLM_QUAITER_TYPE<T>()->tp_alloc(PyGLM_QUAITER_TYPE<T>(), 0));
	if (!rgstate)
		return NULL;

	rgstate->sequence = self;
	Py_INCREF(self);
	rgstate->seq_index = 0;

	return (PyObject *)rgstate;
}

template<typename T>
static int
qua_getbuffer(qua<T>* self, Py_buffer* view, int flags) {
	if (view == NULL) {
		PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
		return -1;
	}
	view->obj = (PyObject*)self;
	view->buf = (void*)&self->super_type[0];
	view->len = sizeof(glm::qua<T>);
	view->readonly = 0;
	view->itemsize = sizeof(T);
	view->format = (std::is_same<T, float>::value) ? const_cast<char*>("f") : \
		(std::is_same <T, double>::value) ? const_cast<char*>("d") : NULL;
	view->ndim = 1;
	view->shape = (Py_ssize_t*)malloc(sizeof(Py_ssize_t));
	if (view->shape != NULL) {
		view->shape[0] = 4;
	}
	view->strides = &view->itemsize;
	view->suboffsets = NULL;
	view->internal = NULL;
	Py_INCREF(self);
	return 0;
}

void
qua_releasebuffer(PyObject*, Py_buffer* view) {
	free(view->shape);
}
#pragma endregion 

#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)

#pragma region macro generator functions
#define PyGLM_MAKE_GLM_FUNC_N_V__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Number_Check(arg)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN_VVV_VNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Number_Check(arg)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Vec_Check(1, float, arg)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}
#define PyGLM_MAKE_GLM_FUNC_NNN_VVV__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), unpack_vec<1, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), unpack_vec<1, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), unpack_vec<2, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), unpack_vec<2, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), unpack_vec<4, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), unpack_vec<4, double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN_VVN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_MM__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg1), unpack_mat<2, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg1), unpack_mat<2, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 3, float>(arg1), unpack_mat<2, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 3, double>(arg1), unpack_mat<2, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 4, float>(arg1), unpack_mat<2, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<2, 4, double>(arg1), unpack_mat<2, 4, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 2, float>(arg1), unpack_mat<3, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 2, double>(arg1), unpack_mat<3, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg1), unpack_mat<3, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg1), unpack_mat<3, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 4, float>(arg1), unpack_mat<3, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<3, 4, double>(arg1), unpack_mat<3, 4, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 2, float>(arg1), unpack_mat<4, 2, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 2, double>(arg1), unpack_mat<4, 2, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 3, float>(arg1), unpack_mat<4, 3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 3, double>(arg1), unpack_mat<4, 3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg1), unpack_mat<4, 4, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg1), unpack_mat<4, 4, double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_M__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 4, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 4, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_S__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_S_Q__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(2, 2, float, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(2, 2, double, arg)) {\
		return pack(glm::NAME(unpack_mat<2, 2, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC__rF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject*) {\
	return pack(glm::NAME<double>());\
}

#define PyGLM_MAKE_GLM_FUNC_M4V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_mat<4, 4, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5, *arg6;\
	PyGLM_Arg_Unpack_6O(args, #NAME, arg1, arg2, arg3, arg4, arg5, arg6);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5), PyGLM_Number_FromPyObject<float>(arg6)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4;\
	PyGLM_Arg_Unpack_4O(args, #NAME, arg1, arg2, arg3, arg4);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NNN__tf(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3, *arg4;\
	PyGLM_Arg_Unpack_4O(args, #NAME, arg1, arg2, arg3, arg4);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2) && PyGLM_Mat_Check(4, 4, float, arg3) && PyGLM_Vec_Check(4, float, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_mat<4, 4, float>(arg2), unpack_mat<4, 4, float>(arg3), unpack_vec<4, float>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2) && PyGLM_Mat_Check(4, 4, float, arg3) && PyGLM_Vec_Check(4, double, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_mat<4, 4, float>(arg2), unpack_mat<4, 4, float>(arg3), unpack_vec<4, double>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2) && PyGLM_Mat_Check(4, 4, double, arg3) && PyGLM_Vec_Check(4, float, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_mat<4, 4, double>(arg2), unpack_mat<4, 4, double>(arg3), unpack_vec<4, float>(arg4)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2) && PyGLM_Mat_Check(4, 4, double, arg3) && PyGLM_Vec_Check(4, double, arg4)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_mat<4, 4, double>(arg2), unpack_mat<4, 4, double>(arg3), unpack_vec<4, double>(arg4)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2), unpack_vec<3, float>(arg3)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2), unpack_vec<3, double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_V3V3__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_QQN__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2, *arg3;\
	PyGLM_Arg_Unpack_3O(args, #NAME, arg1, arg2, arg3);\
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_qua<float>(arg1), unpack_qua<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));\
	}\
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2) && PyGLM_Number_Check(arg3)) {\
		return pack(glm::NAME(unpack_qua<double>(arg1), unpack_qua<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));\
	}\
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for " #NAME "()");\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_Q(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Qua_Check(float, arg)) {\
		return pack(glm::NAME(unpack_qua<float>(arg)));\
	}\
	if (PyGLM_Qua_Check(double, arg)) {\
		return pack(glm::NAME(unpack_qua<double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_M3_M4__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* arg) {\
	if (PyGLM_Mat_Check(3, 3, float, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(3, 3, double, arg)) {\
		return pack(glm::NAME(unpack_mat<3, 3, double>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, float, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, float>(arg)));\
	}\
	if (PyGLM_Mat_Check(4, 4, double, arg)) {\
		return pack(glm::NAME(unpack_mat<4, 4, double>(arg)));\
	}\
	PyGLM_TYPEERROR_O("invalid argument type for " #NAME "(): ", arg);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::uint>(arg1), unpack_vec<1, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u64>(arg1), unpack_vec<1, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u16>(arg1), unpack_vec<1, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u8>(arg1), unpack_vec<1, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, bool, arg1) && PyGLM_Vec_Check(1, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, bool>(arg1), unpack_vec<1, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::uint>(arg1), unpack_vec<2, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u64>(arg1), unpack_vec<2, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u16>(arg1), unpack_vec<2, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u8>(arg1), unpack_vec<2, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, bool>(arg1), unpack_vec<2, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u64>(arg1), unpack_vec<3, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u16>(arg1), unpack_vec<3, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u8>(arg1), unpack_vec<3, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, bool>(arg1), unpack_vec<3, bool>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::uint>(arg1), unpack_vec<4, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u64>(arg1), unpack_vec<4, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u16>(arg1), unpack_vec<4, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u8>(arg1), unpack_vec<4, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, bool>(arg1), unpack_vec<4, bool>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, int, arg1) && PyGLM_Vec_Check(1, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, int>(arg1), unpack_vec<1, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::uint, arg1) && PyGLM_Vec_Check(1, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::uint>(arg1), unpack_vec<1, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i64, arg1) && PyGLM_Vec_Check(1, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i64>(arg1), unpack_vec<1, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u64, arg1) && PyGLM_Vec_Check(1, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u64>(arg1), unpack_vec<1, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i16, arg1) && PyGLM_Vec_Check(1, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i16>(arg1), unpack_vec<1, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u16, arg1) && PyGLM_Vec_Check(1, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u16>(arg1), unpack_vec<1, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::i8, arg1) && PyGLM_Vec_Check(1, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::i8>(arg1), unpack_vec<1, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, glm::u8, arg1) && PyGLM_Vec_Check(1, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, glm::u8>(arg1), unpack_vec<1, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, int>(arg1), unpack_vec<2, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::uint>(arg1), unpack_vec<2, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i64>(arg1), unpack_vec<2, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u64>(arg1), unpack_vec<2, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i16>(arg1), unpack_vec<2, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u16>(arg1), unpack_vec<2, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::i8>(arg1), unpack_vec<2, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, glm::u8>(arg1), unpack_vec<2, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, int>(arg1), unpack_vec<3, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::uint>(arg1), unpack_vec<3, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i64>(arg1), unpack_vec<3, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u64>(arg1), unpack_vec<3, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i16>(arg1), unpack_vec<3, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u16>(arg1), unpack_vec<3, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::i8>(arg1), unpack_vec<3, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, glm::u8>(arg1), unpack_vec<3, glm::u8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, int>(arg1), unpack_vec<4, int>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::uint>(arg1), unpack_vec<4, glm::uint>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i64>(arg1), unpack_vec<4, glm::i64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u64>(arg1), unpack_vec<4, glm::u64>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i16>(arg1), unpack_vec<4, glm::i16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u16>(arg1), unpack_vec<4, glm::u16>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::i8>(arg1), unpack_vec<4, glm::i8>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, glm::u8>(arg1), unpack_vec<4, glm::u8>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}

#define PyGLM_MAKE_GLM_FUNC_NN_VV_QQ__tfF(NAME)\
static PyObject*\
NAME##_(PyObject*, PyObject* args) {\
	PyObject *arg1, *arg2;\
	PyGLM_Arg_Unpack_2O(args, #NAME, arg1, arg2);\
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {\
		return pack(glm::NAME(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));\
	}\
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {\
		return pack(glm::NAME(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));\
	}\
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {\
		return pack(glm::NAME(unpack_qua<float>(arg1), unpack_qua<float>(arg2)));\
	}\
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {\
		return pack(glm::NAME(unpack_qua<double>(arg1), unpack_qua<double>(arg2)));\
	}\
	PyGLM_TYPEERROR_2O("invalid argument type(s) for " #NAME "(): ", arg1, arg2);\
	return NULL;\
}
#pragma endregion


static PyObject*
packDouble2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, glm::uint, arg)) {
		glm::uvec2 o;
		unpack_vec(arg, o);
		return PyFloat_FromDouble(glm::packDouble2x32(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packDouble2x32(): ", arg);
	return NULL;
}

static PyObject*
packHalf2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packHalf2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packHalf2x16(): ", arg);
	return NULL;
}

static PyObject*
packSnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packSnorm2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
packSnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packSnorm4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packSnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
packUnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec2 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packUnorm2x16(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
packUnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec4 o;
		unpack_vec(arg, o);
		return PyLong_FromLong((long)glm::packUnorm4x8(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for packUnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackDouble2x32_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackDouble2x32(PyGLM_Number_AsDouble(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackDouble2x32(): ", arg);
	return NULL;
}

static PyObject*
unpackHalf2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackHalf2x16((glm::uint)PyGLM_Number_AsLong(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackHalf2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackSnorm2x16((glm::uint)PyGLM_Number_AsLong(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm2x16_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackUnorm2x16((glm::uint)PyGLM_Number_AsLong(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm2x16(): ", arg);
	return NULL;
}

static PyObject*
unpackSnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackSnorm4x8((glm::uint)PyGLM_Number_AsLong(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackSnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
unpackUnorm4x8_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		return pack_vec(glm::unpackUnorm4x8((glm::uint)PyGLM_Number_AsLong(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for unpackUnorm4x8(): ", arg);
	return NULL;
}

static PyObject*
uaddCarry_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "uaddCarry", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "uaddCarry() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<2, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<3, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::uaddCarry(o, o2, ((vec<4, glm::uint>*)arg3)->super_type));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for uaddCarry()");
	return NULL;
}

static PyObject*
usubBorrow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "usubBorrow", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "usubBorrow() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<2, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<3, glm::uint>*)arg3)->super_type));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack_vec(glm::usubBorrow(o, o2, ((vec<4, glm::uint>*)arg3)->super_type));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for usubBorrow()");
	return NULL;
}

static PyObject*
umulExtended_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "umulExtended", arg1, arg2, arg3, arg4);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "umulExtended() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2) && Py_TYPE(arg3) == &huvec2Type && Py_TYPE(arg4) == &huvec2Type) {
		glm::uvec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<2, glm::uint>*)arg3)->super_type, ((vec<2, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2) && Py_TYPE(arg3) == &huvec3Type && Py_TYPE(arg4) == &huvec3Type) {
		glm::uvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<3, glm::uint>*)arg3)->super_type, ((vec<3, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2) && Py_TYPE(arg3) == &huvec4Type && Py_TYPE(arg4) == &huvec4Type) {
		glm::uvec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::umulExtended(o, o2, ((vec<4, glm::uint>*)arg3)->super_type, ((vec<4, glm::uint>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for umulExtended()");
	return NULL;
}

static PyObject*
imulExtended_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "imulExtended", arg1, arg2, arg3, arg4);
	if (PyGLM_Number_Check(arg1)) {
		PyErr_SetString(PyExc_TypeError, "imulExtended() doesn't accept integer inputs in PyGLM");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2) && Py_TYPE(arg3) == &hivec2Type && Py_TYPE(arg4) == &hivec2Type) {
		glm::ivec2 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<2, int>*)arg3)->super_type, ((vec<2, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2) && Py_TYPE(arg3) == &hivec3Type && Py_TYPE(arg4) == &hivec3Type) {
		glm::ivec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<3, int>*)arg3)->super_type, ((vec<3, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2) && Py_TYPE(arg3) == &hivec4Type && Py_TYPE(arg4) == &hivec4Type) {
		glm::ivec4 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		glm::imulExtended(o, o2, ((vec<4, int>*)arg3)->super_type, ((vec<4, int>*)arg4)->super_type);
		Py_RETURN_NONE;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for imulExtended()");
	return NULL;
}

static PyObject*
bitfieldExtract_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "bitfieldExtract", arg1, arg2, arg3);
	if (PyLong_Check(arg2) && PyLong_Check(arg3)) {
		int i = (int)PyLong_AS_LONG(arg2), i2 = (int)PyLong_AS_LONG(arg3);
		if (PyLong_Check(arg1)) {
			return PyLong_FromLong(glm::bitfieldExtract(PyLong_AS_LONG(arg1), i, i2));
		}
		if (PyGLM_Vec_Check(2, int, arg1)) {
			glm::ivec2 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
		if (PyGLM_Vec_Check(3, int, arg1)) {
			glm::ivec3 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
		if (PyGLM_Vec_Check(4, int, arg1)) {
			glm::ivec4 o;
			unpack_vec(arg1, o);
			return pack_vec(glm::bitfieldExtract(o, i, i2));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for bitfieldExtract()");
	return NULL;
}

static PyObject*
bitfieldInsert_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4;
	PyGLM_Arg_Unpack_4O(args, "bitfieldInsert", arg1, arg2, arg3, arg4);
	if (PyLong_Check(arg2) && PyLong_Check(arg3)) {
		int i = (int)PyLong_AS_LONG(arg3), i2 = (int)PyLong_AS_LONG(arg4);
		if (PyLong_Check(arg1) && PyLong_Check(arg2)) {
			return PyLong_FromLong(glm::bitfieldInsert(PyLong_AS_LONG(arg1), PyLong_AS_LONG(arg2), i, i2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::ivec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::ivec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::ivec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::bitfieldInsert(o, o2, i, i2));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for bitfieldInsert()");
	return NULL;
}

static PyObject* bitfieldReverse_(PyObject*, PyObject* arg) { 
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::bitfieldReverse(PyLong_AsUnsignedLong(arg))); 
	} 
	if (PyGLM_Vec_Check(2, glm::uint, arg)) { 
		return pack_vec(glm::bitfieldReverse(unpack_vec<2, glm::uint>(arg)));
	} 
	if (PyGLM_Vec_Check(3, glm::uint, arg)) {
		return pack_vec(glm::bitfieldReverse(unpack_vec<3, glm::uint>(arg)));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg)) {
		return pack_vec(glm::bitfieldReverse(unpack_vec<4, glm::uint>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for bitfieldReverse(): ", arg); 
	return NULL; 
}

static PyObject*
bitCount_(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::bitCount(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::bitCount(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for bitCount(): ", arg);
	return NULL;
}

static PyObject*
findLSB_(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::findLSB(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findLSB(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for findLSB(): ", arg);
	return NULL;
}

static PyObject*
findMSB_(PyObject* , PyObject* arg) {
	if (PyLong_Check(arg)) {
		return PyLong_FromLong(glm::findMSB(PyLong_AS_LONG(arg)));
	}
	if (PyGLM_Vec_Check(2, int, arg)) {
		glm::ivec2 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	if (PyGLM_Vec_Check(3, int, arg)) {
		glm::ivec3 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	if (PyGLM_Vec_Check(4, int, arg)) {
		glm::ivec4 o;
		unpack_vec(arg, o);
		return pack_vec(glm::findMSB(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for findMSB(): ", arg);
	return NULL;
}

static PyObject*
equal(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "equal", 2, 3, &arg1, &arg2, &arg3)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::vec<2, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
			glm::vec<2, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
			glm::vec<2, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
			glm::vec<2, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
			glm::vec<2, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
			glm::vec<2, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
			glm::vec<2, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
			glm::vec<2, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
			glm::vec<2, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::vec<3, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
			glm::vec<3, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
			glm::vec<3, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
			glm::vec<3, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
			glm::vec<3, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
			glm::vec<3, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
			glm::vec<3, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
			glm::vec<3, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
			glm::vec<3, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::vec<4, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
			glm::vec<4, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
			glm::vec<4, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
			glm::vec<4, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
			glm::vec<4, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
			glm::vec<4, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
			glm::vec<4, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
			glm::vec<4, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
			glm::vec<4, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2));
		}

		//if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		//	glm::mat<2, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		//	glm::mat<2, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		//	glm::mat<2, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		//	glm::mat<2, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
		//	glm::mat<2, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
		//	glm::mat<2, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
		//	glm::mat<2, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
		//	glm::mat<2, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
		//	glm::mat<2, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
		//	glm::mat<2, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
		//	glm::mat<2, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
		//	glm::mat<2, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
		//	glm::mat<3, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
		//	glm::mat<3, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
		//	glm::mat<3, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
		//	glm::mat<3, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		//	glm::mat<3, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		//	glm::mat<3, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		//	glm::mat<3, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		//	glm::mat<3, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
		//	glm::mat<3, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
		//	glm::mat<3, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
		//	glm::mat<3, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
		//	glm::mat<3, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
		//	glm::mat<4, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
		//	glm::mat<4, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
		//	glm::mat<4, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
		//	glm::mat<4, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
		//	glm::mat<4, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
		//	glm::mat<4, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
		//	glm::mat<4, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
		//	glm::mat<4, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		//	glm::mat<4, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		//	glm::mat<4, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		//	glm::mat<4, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		//	glm::mat<4, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::equal(o, o2));
		//}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for equal(): ", arg1, arg2);
		return NULL;
	}
	if (PyLong_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::equal(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			pack(glm::equal(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::equal(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(2, int, arg3)) {
		glm::vec<2, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(3, int, arg3)) {
		glm::vec<3, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(4, int, arg3)) {
		glm::vec<4, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}

	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
		glm::vec<1, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
		glm::vec<1, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::equal(o, o2, o3));
	}

	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::equal(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
		return NULL;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for equal()");
	return NULL;
}

static PyObject*
notEqual(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "notEqual", 2, 3, &arg1, &arg2, &arg3)) return NULL;
	if (arg3 == NULL) {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
			glm::vec<2, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
			glm::vec<2, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
			glm::vec<2, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
			glm::vec<2, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
			glm::vec<2, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
			glm::vec<2, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
			glm::vec<2, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
			glm::vec<2, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
			glm::vec<2, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
			glm::vec<3, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
			glm::vec<3, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
			glm::vec<3, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
			glm::vec<3, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
			glm::vec<3, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
			glm::vec<3, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
			glm::vec<3, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
			glm::vec<3, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
			glm::vec<3, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
			glm::vec<4, int> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
			glm::vec<4, glm::uint> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
			glm::vec<4, glm::i64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
			glm::vec<4, glm::u64> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
			glm::vec<4, glm::i16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
			glm::vec<4, glm::u16> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
			glm::vec<4, glm::i8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
			glm::vec<4, glm::u8> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
			glm::vec<4, bool> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}

		//if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		//	glm::mat<2, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		//	glm::mat<2, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		//	glm::mat<2, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		//	glm::mat<2, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
		//	glm::mat<2, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
		//	glm::mat<2, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
		//	glm::mat<2, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
		//	glm::mat<2, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
		//	glm::mat<2, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
		//	glm::mat<2, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
		//	glm::mat<2, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
		//	glm::mat<2, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
		//	glm::mat<3, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
		//	glm::mat<3, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
		//	glm::mat<3, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
		//	glm::mat<3, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		//	glm::mat<3, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		//	glm::mat<3, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		//	glm::mat<3, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		//	glm::mat<3, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
		//	glm::mat<3, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
		//	glm::mat<3, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
		//	glm::mat<3, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
		//	glm::mat<3, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
		//	glm::mat<4, 2, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
		//	glm::mat<4, 2, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
		//	glm::mat<4, 2, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
		//	glm::mat<4, 2, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
		//	glm::mat<4, 3, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
		//	glm::mat<4, 3, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
		//	glm::mat<4, 3, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
		//	glm::mat<4, 3, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		//	glm::mat<4, 4, float> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		//	glm::mat<4, 4, double> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		//	glm::mat<4, 4, int> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}
		//if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		//	glm::mat<4, 4, glm::uint> o, o2;
		//	unpack_mat(arg1, o);
		//	unpack_mat(arg2, o2);
		//	return pack(glm::notEqual(o, o2));
		//}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for notEqual(): ", arg1, arg2);
		return NULL;
	}
	if (PyLong_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::notEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
			glm::vec<1, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
			glm::vec<1, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<int>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			pack(glm::notEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}

		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::qua<float> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::qua<double> o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::notEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(2, int, arg3)) {
		glm::vec<2, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(3, int, arg3)) {
		glm::vec<3, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(4, int, arg3)) {
		glm::vec<4, int> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}

	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2) && PyGLM_Vec_Check(1, float, arg3)) {
		glm::vec<1, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2) && PyGLM_Vec_Check(1, double, arg3)) {
		glm::vec<1, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o, o2, o3;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		unpack_vec(arg3, o3);
		return pack(glm::notEqual(o, o2, o3));
	}

	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
			glm::mat<2, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
			glm::mat<2, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
			glm::mat<2, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
			glm::mat<2, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
			glm::mat<2, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
			glm::mat<2, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
			glm::mat<3, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
			glm::mat<3, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
			glm::mat<3, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
			glm::mat<3, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
			glm::mat<3, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
			glm::mat<3, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
			glm::mat<4, 2, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
			glm::mat<4, 3, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
			glm::mat<4, 4, float> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
			glm::mat<4, 2, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
			glm::mat<4, 3, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
			glm::mat<4, 4, double> o, o2;
			unpack_mat(arg1, o);
			unpack_mat(arg2, o2);
			return pack(glm::notEqual(o, o2, o3));
		}
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
		return NULL;
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for notEqual()");
	return NULL;
}

static PyObject*
lessThan(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "lessThan", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThan(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for lessThan(): ", arg1, arg2);
	return NULL;
}

static PyObject*
lessThanEqual(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "lessThanEqual", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::lessThanEqual(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for lessThanEqual(): ", arg1, arg2);
	return NULL;
}

static PyObject*
greaterThan(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "greaterThan", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThan(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for greaterThan(): ", arg1, arg2);
	return NULL;
}

static PyObject*
greaterThanEqual(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "greaterThanEqual", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::greaterThanEqual(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for greaterThanEqual(): ", arg1, arg2);
	return NULL;
}

static PyObject*
any(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, bool, arg)) {
		if (glm::any(unpack_vec<2, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		if (glm::any(unpack_vec<3, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		if (glm::any(unpack_vec<4, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	PyGLM_TYPEERROR_O("invalid argument type for any(): ", arg);
	return NULL;
}

static PyObject*
all(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, bool, arg)) {
		if (glm::all(unpack_vec<2, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		if (glm::all(unpack_vec<3, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		if (glm::all(unpack_vec<4, bool>(arg))) {
			Py_RETURN_TRUE;
		}
		Py_RETURN_FALSE;
	}
	PyGLM_TYPEERROR_O("invalid argument type for all(): ", arg);
	return NULL;
}

static PyObject*
not_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<2, bool>(arg)));
	}
	if (PyGLM_Vec_Check(3, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<3, bool>(arg)));
	}
	if (PyGLM_Vec_Check(4, bool, arg)) {
		return pack_vec(glm::not_(unpack_vec<4, bool>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for not_(): ", arg);
	return NULL;
}

static PyObject*
pow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "pow", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	if (PyGLM_Vec_Check(1, float, arg1) && PyGLM_Vec_Check(1, float, arg2)) {
		return pack(glm::pow(unpack_vec<1, float>(arg1), unpack_vec<1, float>(arg2)));
	}
	if (PyGLM_Vec_Check(1, double, arg1) && PyGLM_Vec_Check(1, double, arg2)) {
		return pack(glm::pow(unpack_vec<1, double>(arg1), unpack_vec<1, double>(arg2)));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		return pack(glm::pow(unpack_vec<2, float>(arg1), unpack_vec<2, float>(arg2)));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		return pack(glm::pow(unpack_vec<2, double>(arg1), unpack_vec<2, double>(arg2)));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		return pack(glm::pow(unpack_vec<3, float>(arg1), unpack_vec<3, float>(arg2)));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		return pack(glm::pow(unpack_vec<3, double>(arg1), unpack_vec<3, double>(arg2)));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		return pack(glm::pow(unpack_vec<4, float>(arg1), unpack_vec<4, float>(arg2)));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		return pack(glm::pow(unpack_vec<4, double>(arg1), unpack_vec<4, double>(arg2)));
	}

	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(unpack_qua<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2)));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Number_Check(arg2)) {
		return pack(glm::pow(unpack_qua<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for pow(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(exp)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(log)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(exp2)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(log2)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(sqrt)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(inversesqrt)

static PyObject*
iround_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		double d = PyGLM_Number_FromPyObject<double>(arg);
		PyGLM_ASSERT((0.0 <= d), "x has to be greater than or equal to 0");
		return pack(glm::iround(d));
	}
	if (PyGLM_Vec_Check(1, float, arg)) {
		glm::vec<1, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(1, double, arg)) {
		glm::vec<1, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::iround(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for iround(): ", arg);
	return NULL;
}

static PyObject*
uround_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		double d = PyGLM_Number_FromPyObject<double>(arg);
		PyGLM_ASSERT((0.0 <= d), "x has to be greater than or equal to 0");
		return pack(glm::uround(d));
	}
	if (PyGLM_Vec_Check(1, float, arg)) {
		glm::vec<1, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(1, double, arg)) {
		glm::vec<1, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<1, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(2, float, arg)) {
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<2, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<3, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, float>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		PyGLM_ASSERT((glm::all(glm::lessThanEqual(glm::vec<4, double>(0), o))), "x has to be greater or equal to 0");
		return pack(glm::uround(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for uround(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tfF(abs)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(sign)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(floor)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(trunc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(round)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(roundEven)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(ceil)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(fract)

PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(mod)
PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(min)
PyGLM_MAKE_GLM_FUNC_NN_VV_VN__tfF(max)

PyGLM_MAKE_GLM_FUNC_NNN_VVV_VNN__tf(clamp)

static PyObject*
mix_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "mix", arg1, arg2, arg3);
	
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyBool_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::mix(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<bool>(arg3)));
	}

	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::mix(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2) && PyGLM_Number_Check(arg3)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack_qua(glm::mix(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2) && PyGLM_Number_Check(arg3)) {
		glm::dquat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack_qua(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	}

	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, int, arg1) && PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg1) && PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg1) && PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg1) && PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg1) && PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg1) && PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg1) && PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg1) && PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, bool, arg1) && PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::bvec2 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, int, arg1) && PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg1) && PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg1) && PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg1) && PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg1) && PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg1) && PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg1) && PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg1) && PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, bool, arg1) && PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::bvec3 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, int, arg1) && PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg1) && PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg1) && PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg1) && PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg1) && PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg1) && PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg1) && PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg1) && PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, bool, arg1) && PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack_vec(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::bvec4 o3;
			unpack_vec(arg3, o3);
			return pack_vec(glm::mix(o, o2, o3));
		}
	}
	
	if (PyGLM_Mat_Check(2, 2, float, arg1) && PyGLM_Mat_Check(2, 2, float, arg2)) {
		glm::mat<2, 2, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, double, arg1) && PyGLM_Mat_Check(2, 2, double, arg2)) {
		glm::mat<2, 2, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, int, arg1) && PyGLM_Mat_Check(2, 2, int, arg2)) {
		glm::mat<2, 2, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(2, 2, glm::uint, arg1) && PyGLM_Mat_Check(2, 2, glm::uint, arg2)) {
		glm::mat<2, 2, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(2, 2, float, arg3)) {
			glm::mat<2, 2, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg3)) {
			glm::mat<2, 2, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	//if (PyGLM_Mat_Check(2, 3, float, arg1) && PyGLM_Mat_Check(2, 3, float, arg2)) {
	//	glm::mat<2, 3, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, double, arg1) && PyGLM_Mat_Check(2, 3, double, arg2)) {
	//	glm::mat<2, 3, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, int, arg1) && PyGLM_Mat_Check(2, 3, int, arg2)) {
	//	glm::mat<2, 3, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 3, glm::uint, arg1) && PyGLM_Mat_Check(2, 3, glm::uint, arg2)) {
	//	glm::mat<2, 3, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, float, arg3)) {
	//		glm::mat<2, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 3, double, arg3)) {
	//		glm::mat<2, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, float, arg1) && PyGLM_Mat_Check(2, 4, float, arg2)) {
	//	glm::mat<2, 4, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, double, arg1) && PyGLM_Mat_Check(2, 4, double, arg2)) {
	//	glm::mat<2, 4, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, int, arg1) && PyGLM_Mat_Check(2, 4, int, arg2)) {
	//	glm::mat<2, 4, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(2, 4, glm::uint, arg1) && PyGLM_Mat_Check(2, 4, glm::uint, arg2)) {
	//	glm::mat<2, 4, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, float, arg3)) {
	//		glm::mat<2, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(2, 4, double, arg3)) {
	//		glm::mat<2, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, float, arg1) && PyGLM_Mat_Check(3, 2, float, arg2)) {
	//	glm::mat<3, 2, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, double, arg1) && PyGLM_Mat_Check(3, 2, double, arg2)) {
	//	glm::mat<3, 2, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, int, arg1) && PyGLM_Mat_Check(3, 2, int, arg2)) {
	//	glm::mat<3, 2, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 2, glm::uint, arg1) && PyGLM_Mat_Check(3, 2, glm::uint, arg2)) {
	//	glm::mat<3, 2, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, float, arg3)) {
	//		glm::mat<3, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 2, double, arg3)) {
	//		glm::mat<3, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	if (PyGLM_Mat_Check(3, 3, float, arg1) && PyGLM_Mat_Check(3, 3, float, arg2)) {
		glm::mat<3, 3, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, double, arg1) && PyGLM_Mat_Check(3, 3, double, arg2)) {
		glm::mat<3, 3, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, int, arg1) && PyGLM_Mat_Check(3, 3, int, arg2)) {
		glm::mat<3, 3, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(3, 3, glm::uint, arg1) && PyGLM_Mat_Check(3, 3, glm::uint, arg2)) {
		glm::mat<3, 3, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg3)) {
			glm::mat<3, 3, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg3)) {
			glm::mat<3, 3, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	//if (PyGLM_Mat_Check(3, 4, float, arg1) && PyGLM_Mat_Check(3, 4, float, arg2)) {
	//	glm::mat<3, 4, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, double, arg1) && PyGLM_Mat_Check(3, 4, double, arg2)) {
	//	glm::mat<3, 4, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, int, arg1) && PyGLM_Mat_Check(3, 4, int, arg2)) {
	//	glm::mat<3, 4, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(3, 4, glm::uint, arg1) && PyGLM_Mat_Check(3, 4, glm::uint, arg2)) {
	//	glm::mat<3, 4, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, float, arg3)) {
	//		glm::mat<3, 4, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(3, 4, double, arg3)) {
	//		glm::mat<3, 4, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, float, arg1) && PyGLM_Mat_Check(4, 2, float, arg2)) {
	//	glm::mat<4, 2, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, double, arg1) && PyGLM_Mat_Check(4, 2, double, arg2)) {
	//	glm::mat<4, 2, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, int, arg1) && PyGLM_Mat_Check(4, 2, int, arg2)) {
	//	glm::mat<4, 2, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 2, glm::uint, arg1) && PyGLM_Mat_Check(4, 2, glm::uint, arg2)) {
	//	glm::mat<4, 2, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, float, arg3)) {
	//		glm::mat<4, 2, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 2, double, arg3)) {
	//		glm::mat<4, 2, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, float, arg1) && PyGLM_Mat_Check(4, 3, float, arg2)) {
	//	glm::mat<4, 3, float> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, double, arg1) && PyGLM_Mat_Check(4, 3, double, arg2)) {
	//	glm::mat<4, 3, double> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, int, arg1) && PyGLM_Mat_Check(4, 3, int, arg2)) {
	//	glm::mat<4, 3, int> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	//if (PyGLM_Mat_Check(4, 3, glm::uint, arg1) && PyGLM_Mat_Check(4, 3, glm::uint, arg2)) {
	//	glm::mat<4, 3, glm::uint> o, o2;
	//	unpack_mat(arg1, o);
	//	unpack_mat(arg2, o2);
	//	if (PyGLM_Number_Check(arg3)) {
	//		return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, float, arg3)) {
	//		glm::mat<4, 3, float> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//	if (PyGLM_Mat_Check(4, 3, double, arg3)) {
	//		glm::mat<4, 3, double> o3;
	//		unpack_mat(arg3, o3);
	//		return pack(glm::mix(o, o2, o3));
	//	}
	//}
	if (PyGLM_Mat_Check(4, 4, float, arg1) && PyGLM_Mat_Check(4, 4, float, arg2)) {
		glm::mat<4, 4, float> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1) && PyGLM_Mat_Check(4, 4, double, arg2)) {
		glm::mat<4, 4, double> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, int, arg1) && PyGLM_Mat_Check(4, 4, int, arg2)) {
		glm::mat<4, 4, int> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg1) && PyGLM_Mat_Check(4, 4, glm::uint, arg2)) {
		glm::mat<4, 4, glm::uint> o, o2;
		unpack_mat(arg1, o);
		unpack_mat(arg2, o2);
		if (PyGLM_Number_Check(arg3)) {
			return pack(glm::mix(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg3)) {
			glm::mat<4, 4, float> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg3)) {
			glm::mat<4, 4, double> o3;
			unpack_mat(arg3, o3);
			return pack(glm::mix(o, o2, o3));
		}
	}

	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for mix()"); 
	return NULL;
}

static PyObject*
step_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "step", arg1, arg2);
	if (PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg1)) {
		return PyGLM_PyObject_FromNumber(glm::step(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
	}
	if (PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec<2, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, float, arg1)) {
			glm::vec<2, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg2)) {
		glm::vec<2, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			glm::vec<2, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, int, arg2)) {
		glm::vec<2, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, int, arg1)) {
			glm::vec<2, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg2)) {
		glm::vec<2, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg1)) {
			glm::vec<2, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg2)) {
		glm::vec<2, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg1)) {
			glm::vec<2, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg2)) {
		glm::vec<2, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg1)) {
			glm::vec<2, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg2)) {
		glm::vec<2, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg1)) {
			glm::vec<2, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg2)) {
		glm::vec<2, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg1)) {
			glm::vec<2, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg2)) {
		glm::vec<2, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg1)) {
			glm::vec<2, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg2)) {
		glm::vec<2, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg1)) {
			glm::vec<2, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(2, bool, arg2)) {
		glm::vec<2, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(2, bool, arg1)) {
			glm::vec<2, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec<3, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			glm::vec<3, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg2)) {
		glm::vec<3, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			glm::vec<3, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, int, arg2)) {
		glm::vec<3, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, int, arg1)) {
			glm::vec<3, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg2)) {
		glm::vec<3, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg1)) {
			glm::vec<3, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg2)) {
		glm::vec<3, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg1)) {
			glm::vec<3, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg2)) {
		glm::vec<3, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg1)) {
			glm::vec<3, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg2)) {
		glm::vec<3, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg1)) {
			glm::vec<3, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg2)) {
		glm::vec<3, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg1)) {
			glm::vec<3, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg2)) {
		glm::vec<3, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg1)) {
			glm::vec<3, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg2)) {
		glm::vec<3, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg1)) {
			glm::vec<3, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(3, bool, arg2)) {
		glm::vec<3, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(3, bool, arg1)) {
			glm::vec<3, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec<4, float> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<float>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			glm::vec<4, float> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg2)) {
		glm::vec<4, double> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<double>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			glm::vec<4, double> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, int, arg2)) {
		glm::vec<4, int> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<int>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, int, arg1)) {
			glm::vec<4, int> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg2)) {
		glm::vec<4, glm::uint> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::uint>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg1)) {
			glm::vec<4, glm::uint> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg2)) {
		glm::vec<4, glm::i64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg1)) {
			glm::vec<4, glm::i64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg2)) {
		glm::vec<4, glm::u64> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u64>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg1)) {
			glm::vec<4, glm::u64> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg2)) {
		glm::vec<4, glm::i16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg1)) {
			glm::vec<4, glm::i16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg2)) {
		glm::vec<4, glm::u16> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u16>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg1)) {
			glm::vec<4, glm::u16> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg2)) {
		glm::vec<4, glm::i8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::i8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg1)) {
			glm::vec<4, glm::i8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg2)) {
		glm::vec<4, glm::u8> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<glm::u8>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg1)) {
			glm::vec<4, glm::u8> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	if (PyGLM_Vec_Check(4, bool, arg2)) {
		glm::vec<4, bool> o2;
		unpack_vec(arg2, o2);
		if (PyGLM_Number_Check(arg1)) {
			return pack_vec(glm::step(PyGLM_Number_FromPyObject<bool>(arg1), o2));
		}
		if (PyGLM_Vec_Check(4, bool, arg1)) {
			glm::vec<4, bool> o;
			unpack_vec(arg1, o);
			return pack_vec(glm::step(o, o2));
		}
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for step(): ", arg1, arg2);
	return NULL;
}

static PyObject*
smoothstep_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "smoothstep", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
		return PyGLM_PyObject_FromNumber(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	if (PyGLM_Vec_Check(2, float, arg3)) {
		glm::vec<2, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(2, double, arg3)) {
		glm::vec<2, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, float, arg3)) {
		glm::vec<3, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(3, double, arg3)) {
		glm::vec<3, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec<4, float> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	if (PyGLM_Vec_Check(4, double, arg3)) {
		glm::vec<4, double> o3;
		unpack_vec(arg3, o3);
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack_vec(glm::smoothstep(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::smoothstep(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for smoothstep()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(isnan)
PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(isinf)

static PyObject*
fma_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "fma", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2), PyGLM_Number_Check(arg3)) {
		return PyGLM_PyObject_FromNumber(glm::fma(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for fma()");
	return NULL;
}

static PyObject*
frexp_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "frexp", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyLong_Check(arg2)) {
		if (PyGLM_SHOW_WARNINGS & PyGLM_FREXP_WARNING) PyErr_WarnEx(PyExc_UserWarning, "This function will return this pair: (m, e), which differs from glm behaviour. You can silence this warning by calling glm.silence(1)", 1);
		int e = (int)PyLong_AS_LONG(arg2);
		double m = glm::frexp(PyGLM_Number_FromPyObject<double>(arg1), e);
		return Py_BuildValue("(d, i)", m, e);
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::frexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for frexp(): ", arg1, arg2);
	return NULL;
}

static PyObject*
ldexp_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "ldexp", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyObject_TypeCheck(arg2, &hivec2Type)) {
		glm::vec<2, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<2, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyObject_TypeCheck(arg2, &hivec3Type)) {
		glm::vec<3, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<3, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, float> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyObject_TypeCheck(arg2, &hivec4Type)) {
		glm::vec<4, double> o;
		unpack_vec(arg1, o);
		return pack_vec(glm::ldexp(o, ((vec<4, int>*)arg2)->super_type));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for ldexp(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V_Q__tfF(length)

PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(distance)
PyGLM_MAKE_GLM_FUNC_NN_VV_QQ__tfF(dot)

static PyObject*
cross_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "cross", arg1, arg2);

	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec3 o, o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
		glm::quat o, o2;
		unpack_qua(arg1, o);
		unpack_qua(arg2, o2);
		return pack(glm::cross(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for cross(): ", arg1, arg2);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V_Q__tfF(normalize)

PyGLM_MAKE_GLM_FUNC_NNN_VVV__tfF(faceforward)

PyGLM_MAKE_GLM_FUNC_NN_VV__tfF(reflect)

PyGLM_MAKE_GLM_FUNC_NNN_VVN__tfF(refract)

static PyObject*
outerProduct_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "outerProduct", arg1, arg2);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec2 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec2 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec2 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec3 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec3 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec3 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
		glm::vec4 o;
		glm::vec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		glm::vec4 o;
		glm::vec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
		glm::vec4 o;
		glm::vec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec2 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec2 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec2 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec3 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec3 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec3 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
		glm::dvec4 o;
		glm::dvec2 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		glm::dvec4 o;
		glm::dvec3 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
		glm::dvec4 o;
		glm::dvec4 o2;
		unpack_vec(arg1, o);
		unpack_vec(arg2, o2);
		return pack(glm::outerProduct(o, o2));
	}
	PyGLM_TYPEERROR_2O("invalid argument type(s) for outerProduct(): ", arg1, arg2);
	return NULL;
}

static PyObject*
affineInverse_(PyObject*, PyObject* arg) {
	if (PyGLM_Mat_Check(3, 3, float, arg)) {
		return pack(glm::affineInverse(unpack_mat<3, 3, float>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg)) {
		return pack(glm::affineInverse(unpack_mat<3, 3, double>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg)) {
		return pack(glm::affineInverse(unpack_mat<4, 4, float>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg)) {
		return pack(glm::affineInverse(unpack_mat<4, 4, double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for affineInverse(): ", arg);
	return NULL;
}

static PyObject*
inverseTranspose_(PyObject*, PyObject* arg) {
	if (PyGLM_Mat_Check(2, 2, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<2, 2, float>(arg)));
	}
	if (PyGLM_Mat_Check(2, 2, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<2, 2, double>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<3, 3, float>(arg)));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<3, 3, double>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<4, 4, float>(arg)));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg)) {
		return pack(glm::inverseTranspose(unpack_mat<4, 4, double>(arg)));
	}
	PyGLM_TYPEERROR_O("invalid argument type for inverseTranspose(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_MM__tfF(matrixCompMult)
PyGLM_MAKE_GLM_FUNC_M__tfF(transpose)
PyGLM_MAKE_GLM_FUNC_S__tfF(determinant)
PyGLM_MAKE_GLM_FUNC_S_Q__tfF(inverse)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(radians)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(degrees)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sin)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cos)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(tan)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asin)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acos)
static PyObject* 
atan_(PyObject*, PyObject* args) {
	PyObject* arg1 = NULL, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "atan", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for atan()");
		return NULL;
	}

	if (arg2 != NULL) {
		if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2)) {
			return pack(glm::atan(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2)));
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::atan(o, o2));
		}
		PyGLM_TYPEERROR_2O("invalid argument type(s) for atan(): ", arg1, arg2);
		return NULL;
	}

	if (PyGLM_Number_Check(arg1)) {
		return pack(glm::atan(PyGLM_Number_FromPyObject<double>(arg1)));
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		return pack(glm::atan(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for atan(): ", arg1);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sinh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cosh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(tanh)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asinh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acosh)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(atanh)

static PyObject*
convertLinearToSRGB_(PyObject*, PyObject* args) {
	PyObject* arg1;
	PyObject* arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "convertLinearToSRGB", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertLinearToSRGB()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertLinearToSRGB(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertLinearToSRGB(o));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertLinearToSRGB()");
	return NULL;
}

static PyObject*
convertSRGBToLinear_(PyObject*, PyObject* args) {
	PyObject* arg1;
	PyObject* arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "convertSRGBToLinear", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertSRGBToLinear()");
		return NULL;
	}
	if (PyGLM_Vec_Check(2, float, arg1)) {
		glm::vec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(3, float, arg1)) {
		glm::vec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(4, float, arg1)) {
		glm::vec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<float>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(2, double, arg1)) {
		glm::dvec2 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(3, double, arg1)) {
		glm::dvec3 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	if (PyGLM_Vec_Check(4, double, arg1)) {
		glm::dvec4 o;
		unpack_vec(arg1, o);
		if (arg2 != NULL && PyGLM_Number_Check(arg2)) {
			return pack(glm::convertSRGBToLinear(o, PyGLM_Number_FromPyObject<double>(arg2)));
		}
		return pack(glm::convertSRGBToLinear(o));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for convertSRGBToLinear()");
	return NULL;
}

//static PyObject* epsilon_(PyObject*, PyObject* narg) { return PyFloat_FromDouble(glm::epsilon<double>()); }

PyGLM_MAKE_GLM_FUNC__rF(epsilon)
PyGLM_MAKE_GLM_FUNC__rF(zero)
PyGLM_MAKE_GLM_FUNC__rF(one)
PyGLM_MAKE_GLM_FUNC__rF(pi)
PyGLM_MAKE_GLM_FUNC__rF(two_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_pi)
PyGLM_MAKE_GLM_FUNC__rF(half_pi)
PyGLM_MAKE_GLM_FUNC__rF(three_over_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(quarter_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(two_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(four_over_pi)
PyGLM_MAKE_GLM_FUNC__rF(two_over_root_pi)
PyGLM_MAKE_GLM_FUNC__rF(one_over_root_two)
PyGLM_MAKE_GLM_FUNC__rF(root_half_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_two_pi)
PyGLM_MAKE_GLM_FUNC__rF(root_ln_four)
PyGLM_MAKE_GLM_FUNC__rF(e)
PyGLM_MAKE_GLM_FUNC__rF(euler)
PyGLM_MAKE_GLM_FUNC__rF(root_two)
PyGLM_MAKE_GLM_FUNC__rF(root_three)
PyGLM_MAKE_GLM_FUNC__rF(root_five)
PyGLM_MAKE_GLM_FUNC__rF(ln_two)
PyGLM_MAKE_GLM_FUNC__rF(ln_ten)
PyGLM_MAKE_GLM_FUNC__rF(ln_ln_two)
PyGLM_MAKE_GLM_FUNC__rF(third)
PyGLM_MAKE_GLM_FUNC__rF(two_thirds)
PyGLM_MAKE_GLM_FUNC__rF(golden_ratio)

static PyObject* 
epsilonEqual_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "epsilonEqual", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2)) {
			if (glm::epsilonEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3))) {
				Py_RETURN_TRUE;
			}
			else {
				Py_RETURN_FALSE;
			}
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::quat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::dquat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
	}
	else {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonEqual(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for epsilonEqual()");
	return NULL;
}

static PyObject*
epsilonNotEqual_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "epsilonNotEqual", arg1, arg2, arg3);
	if (PyGLM_Number_Check(arg3)) {
		if (PyGLM_Number_Check(arg1), PyGLM_Number_Check(arg2)) {
			if (glm::epsilonNotEqual(PyGLM_Number_FromPyObject<double>(arg1), PyGLM_Number_FromPyObject<double>(arg2), PyGLM_Number_FromPyObject<double>(arg3))) {
				Py_RETURN_TRUE;
			}
			else {
				Py_RETURN_FALSE;
			}
		}
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::dvec2 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::dvec3 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::dvec4 o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack_vec(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
		if (PyGLM_Qua_Check(float, arg1) && PyGLM_Qua_Check(float, arg2)) {
			glm::quat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<float>(arg3)));
		}
		if (PyGLM_Qua_Check(double, arg1) && PyGLM_Qua_Check(double, arg2)) {
			glm::dquat o, o2;
			unpack_qua(arg1, o);
			unpack_qua(arg2, o2);
			return pack(glm::epsilonNotEqual(o, o2, PyGLM_Number_FromPyObject<double>(arg3)));
		}
	}
	else {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2) && PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(2, double, arg3)) {
			glm::dvec2 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2) && PyGLM_Vec_Check(3, double, arg3)) {
			glm::dvec3 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
			glm::dvec4 o, o2, o3;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			unpack_vec(arg3, o3);
			return pack(glm::epsilonNotEqual(o, o2, o3));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for epsilonNotEqual()");
	return NULL;
}

static PyObject*
identity_(PyObject*, PyObject* arg) {
	if (!PyType_Check(arg)) {
		PyGLM_TYPEERROR_O("identity() requires a PyGLM matrix type as it's argument, not ", arg);
		return NULL;
	}
	if (arg == (PyObject*)&hfmat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, double> >());
	}
	if (arg == (PyObject*)&himat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, int> >());
	}
	if (arg == (PyObject*)&humat2x2Type) {
		return pack(glm::identity<glm::mat<2, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, double> >());
	}
	if (arg == (PyObject*)&himat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, int> >());
	}
	if (arg == (PyObject*)&humat2x3Type) {
		return pack(glm::identity<glm::mat<2, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, double> >());
	}
	if (arg == (PyObject*)&himat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, int> >());
	}
	if (arg == (PyObject*)&humat2x4Type) {
		return pack(glm::identity<glm::mat<2, 4, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, double> >());
	}
	if (arg == (PyObject*)&himat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, int> >());
	}
	if (arg == (PyObject*)&humat3x2Type) {
		return pack(glm::identity<glm::mat<3, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, double> >());
	}
	if (arg == (PyObject*)&himat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, int> >());
	}
	if (arg == (PyObject*)&humat3x3Type) {
		return pack(glm::identity<glm::mat<3, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, double> >());
	}
	if (arg == (PyObject*)&himat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, int> >());
	}
	if (arg == (PyObject*)&humat3x4Type) {
		return pack(glm::identity<glm::mat<3, 4, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, float> >());
	}
	if (arg == (PyObject*)&hdmat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, double> >());
	}
	if (arg == (PyObject*)&himat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, int> >());
	}
	if (arg == (PyObject*)&humat4x2Type) {
		return pack(glm::identity<glm::mat<4, 2, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, float> >());
	}
	if (arg == (PyObject*)&hdmat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, double> >());
	}
	if (arg == (PyObject*)&himat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, int> >());
	}
	if (arg == (PyObject*)&humat4x3Type) {
		return pack(glm::identity<glm::mat<4, 3, glm::uint> >());
	}
	if (arg == (PyObject*)&hfmat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, float> >());
	}
	if (arg == (PyObject*)&hdmat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, double> >());
	}
	if (arg == (PyObject*)&himat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, int> >());
	}
	if (arg == (PyObject*)&humat4x4Type) {
		return pack(glm::identity<glm::mat<4, 4, glm::uint> >());
	}
	PyErr_Format(PyExc_TypeError, "identity() requires a PyGLM matrix type as it's argument, not '%s'", ((PyTypeObject*)arg)->tp_name);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_M4V3__tfF(translate)

static PyObject*
rotate_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "rotate", arg1, arg2, arg3);
	if (PyGLM_Mat_Check(4, 4, float, arg1)) {
		glm::mat4x4 m;
		glm::vec3 axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack(glm::rotate(m, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1)) {
		glm::dmat4x4 m;
		glm::dvec3 axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack(glm::rotate(m, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	if (PyGLM_Qua_Check(float, arg1)) {
		glm::quat q;
		glm::vec3 axis;
		if (!unpack_qua(arg1, q) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack_qua(glm::rotate(q, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Qua_Check(double, arg1)) {
		glm::dquat q;
		glm::dvec3 axis;
		if (!unpack_qua(arg1, q) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
			return NULL;
		}
		return pack_qua(glm::rotate(q, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate()");
	return NULL;
}

static PyObject*
rotate_slow_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "rotate_slow", arg1, arg2, arg3);
	if (PyGLM_Mat_Check(4, 4, float, arg1)) {
		glm::mat<4, 4, float> m;
		glm::vec<3, float> axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
			return NULL;
		}
		return pack(glm::rotate_slow(m, PyGLM_Number_FromPyObject<float>(arg2), axis));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg1)) {
		glm::mat<4, 4, double> m;
		glm::vec<3, double> axis;
		if (!unpack_mat(arg1, m) || !PyGLM_Number_Check(arg2) || !unpack_vec(arg3, axis)) {
			PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
			return NULL;
		}
		return pack(glm::rotate_slow(m, PyGLM_Number_FromPyObject<double>(arg2), axis));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for rotate_slow()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_M4V3__tfF(scale)
PyGLM_MAKE_GLM_FUNC_M4V3__tfF(scale_slow)

static PyObject*
ortho_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5 = NULL, *arg6 = NULL;
	if (!PyArg_UnpackTuple(args, "ortho", 4, 6, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for ortho()");
		return NULL;
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)) {
		if (arg5 != NULL && arg6 != NULL && PyGLM_Number_Check(arg5) && PyGLM_Number_Check(arg6)) return pack(glm::ortho(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5), PyGLM_Number_FromPyObject<float>(arg6)));
		if (arg5 == NULL && arg6 == NULL) return pack(glm::ortho(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for ortho()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoLH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoRH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(orthoNO)

PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustum)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumLH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumZO)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumRH)
PyGLM_MAKE_GLM_FUNC_NNNNNN__tf(frustumNO)

PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspective)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH_NO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH_ZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH_NO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveLH)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveZO)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveRH)
PyGLM_MAKE_GLM_FUNC_NNNN__tf(perspectiveNO)

static PyObject*
perspectiveFov_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFov", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4)&& PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFov() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFov(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFov()");
	return NULL;
}
static PyObject*
perspectiveFovLH_ZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH_ZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH_ZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH_ZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH_ZO()");
	return NULL;
}
static PyObject*
perspectiveFovLH_NO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH_NO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH_NO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH_NO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH_NO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_ZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH_ZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH_ZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH_ZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH_ZO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_NO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH_NO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH_NO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH_NO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH_NO()");
	return NULL;
}
static PyObject*
perspectiveFovLH_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovLH", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovLH() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovLH(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovLH()");
	return NULL;
}
static PyObject*
perspectiveFovZO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovZO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovZO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovZO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovZO()");
	return NULL;
}
static PyObject*
perspectiveFovRH_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovRH", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovRH() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovRH(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovRH()");
	return NULL;
}
static PyObject*
perspectiveFovNO_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4, *arg5;
	PyGLM_Arg_Unpack_5O(args, "perspectiveFovNO", arg1, arg2, arg3, arg4, arg5);
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3) && PyGLM_Number_Check(arg4) && PyGLM_Number_Check(arg5)) {
		float f = PyGLM_Number_FromPyObject<float>(arg1), f2 = PyGLM_Number_FromPyObject<float>(arg2), f3 = PyGLM_Number_FromPyObject<float>(arg3);
		if (!(f > 0 && f2 > 0 && f3 > 0)) {
			PyErr_SetString(PyExc_ValueError, "fov, width and height arguments of perspectiveFovNO() must be greater than 0");
			return NULL;
		}
		return pack(glm::perspectiveFovNO(f, f2, f3, PyGLM_Number_FromPyObject<float>(arg4), PyGLM_Number_FromPyObject<float>(arg5)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perspectiveFovNO()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspective)
PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspectiveLH)
PyGLM_MAKE_GLM_FUNC_NNN__tf(infinitePerspectiveRH)

static PyObject*
tweakedInfinitePerspective_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3, *arg4 = NULL;
	if (!PyArg_UnpackTuple(args, "tweakedInfinitePerspective", 3, 4, &arg1, &arg2, &arg3, &arg4)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for tweakedInfinitePerspective()");
		return NULL;
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Number_Check(arg2) && PyGLM_Number_Check(arg3)) {
		if (arg4 != NULL && PyGLM_Number_Check(arg4)) {
			return pack(glm::tweakedInfinitePerspective(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3), PyGLM_Number_FromPyObject<float>(arg4)));
		}
		return pack(glm::tweakedInfinitePerspective(PyGLM_Number_FromPyObject<float>(arg1), PyGLM_Number_FromPyObject<float>(arg2), PyGLM_Number_FromPyObject<float>(arg3)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for tweakedInfinitePerspective()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(project)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(projectZO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(projectNO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProject)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProjectZO)
PyGLM_MAKE_GLM_FUNC_V3M4M4V4__tfF(unProjectNO)

static PyObject*
pickMatrix_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3;
	PyGLM_Arg_Unpack_3O(args, "pickMatrix", arg1, arg2, arg3);
	if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2) && PyGLM_Vec_Check(4, float, arg3)) {
		glm::vec2 o, o2;
		glm::vec4 o3;
		if (!(o.x > 0.0f && o.y > 0.0f)) {
			PyErr_SetString(PyExc_ValueError, "delta has to be greater than 0 for pickMatrix()");
			return NULL;
		}
		return pack(glm::pickMatrix(o, o2, o3));
	}
	if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2) && PyGLM_Vec_Check(4, double, arg3)) {
		glm::dvec2 o, o2;
		glm::dvec4 o3;
		if (!(o.x > 0.0 && o.y > 0.0)) {
			PyErr_SetString(PyExc_ValueError, "delta has to be greater than 0 for pickMatrix()");
			return NULL;
		}
		return pack(glm::pickMatrix(o, o2, o3));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for pickMatrix()");
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAt)
PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAtLH)
PyGLM_MAKE_GLM_FUNC_V3V3V3__tfF(lookAtRH)

PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAt)
PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAtLH)
PyGLM_MAKE_GLM_FUNC_V3V3__tfF(quatLookAtRH)

PyGLM_MAKE_GLM_FUNC_QQN__tfF(lerp)
PyGLM_MAKE_GLM_FUNC_QQN__tfF(slerp)

PyGLM_MAKE_GLM_FUNC_Q(conjugate)

PyGLM_MAKE_GLM_FUNC_Q(eulerAngles)

PyGLM_MAKE_GLM_FUNC_Q(roll)
PyGLM_MAKE_GLM_FUNC_Q(pitch)
PyGLM_MAKE_GLM_FUNC_Q(yaw)

PyGLM_MAKE_GLM_FUNC_Q(mat3_cast)

PyGLM_MAKE_GLM_FUNC_Q(mat4_cast)

PyGLM_MAKE_GLM_FUNC_M3_M4__tfF(quat_cast)

PyGLM_MAKE_GLM_FUNC_Q(angle)
PyGLM_MAKE_GLM_FUNC_Q(axis)

static PyObject*
angleAxis_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2;
	PyGLM_Arg_Unpack_2O(args, "angleAxis", arg1, arg2);
	if (PyGLM_Number_Check(arg1) && PyGLM_Vec_Check(3, float, arg2)) {
		return pack(glm::angleAxis(PyGLM_Number_FromPyObject<float>(arg1), unpack_vec<3, float>(arg2)));
	}
	if (PyGLM_Number_Check(arg1) && PyGLM_Vec_Check(3, double, arg2)) {
		return pack(glm::angleAxis(PyGLM_Number_FromPyObject<double>(arg1), unpack_vec<3, double>(arg2)));
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for angleAxis()");
	return NULL;
}

static PyObject*
row_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "row", 2, 3, &arg1, &arg2, &arg3) || !PyGLM_Number_Check(arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for row()");
		return NULL;
	}
	glm::length_t index = PyGLM_Number_FromPyObject<glm::length_t>(arg2);
	if (index < 0) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	if (arg3 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec<2, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec<3, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec<4, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::vec<2, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::vec<3, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::vec<4, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, int, arg3)) {
			glm::vec<2, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, int, arg3)) {
			glm::vec<3, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, int, arg3)) {
			glm::vec<4, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg3)) {
			glm::vec<2, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg3)) {
			glm::vec<3, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg3)) {
			glm::vec<4, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg3)) {
			glm::vec<2, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg3)) {
			glm::vec<3, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg3)) {
			glm::vec<4, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg3)) {
			glm::vec<2, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg3)) {
			glm::vec<3, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg3)) {
			glm::vec<4, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg3)) {
			glm::vec<2, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg3)) {
			glm::vec<3, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg3)) {
			glm::vec<4, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg3)) {
			glm::vec<2, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg3)) {
			glm::vec<3, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg3)) {
			glm::vec<4, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg3)) {
			glm::vec<2, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg3)) {
			glm::vec<3, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg3)) {
			glm::vec<4, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg3)) {
			glm::vec<2, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg3)) {
			glm::vec<3, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg3)) {
			glm::vec<4, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::vec<2, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::vec<3, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::vec<4, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::row(m, index, x));
			}
		}

	}
	else {
		if (PyGLM_Mat_Check(2, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, float> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, double> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, int> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}

		if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
		if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(glm::row(m, index));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for row()");
	return NULL;
}

static PyObject*
column_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2, *arg3 = NULL;
	if (!PyArg_UnpackTuple(args, "column", 2, 3, &arg1, &arg2, &arg3) || !PyGLM_Number_Check(arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for column()");
		return NULL;
	}
	glm::length_t index = PyGLM_Number_FromPyObject<glm::length_t>(arg2);
	if (index < 0) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		return NULL;
	}
	if (arg3 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg3)) {
			glm::vec<2, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, float, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, float, arg3)) {
			glm::vec<3, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, float, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, float, arg3)) {
			glm::vec<4, float> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, float, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, float> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, double, arg3)) {
			glm::vec<2, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, double, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, double, arg3)) {
			glm::vec<3, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, double, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, double, arg3)) {
			glm::vec<4, double> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, double, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, double> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, int, arg3)) {
			glm::vec<2, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, int, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, int, arg3)) {
			glm::vec<3, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, int, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, int, arg3)) {
			glm::vec<4, int> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, int, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, int> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::uint, arg3)) {
			glm::vec<2, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::uint, arg3)) {
			glm::vec<3, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::uint, arg3)) {
			glm::vec<4, glm::uint> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::uint> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i64, arg3)) {
			glm::vec<2, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i64, arg3)) {
			glm::vec<3, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i64, arg3)) {
			glm::vec<4, glm::i64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u64, arg3)) {
			glm::vec<2, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u64, arg3)) {
			glm::vec<3, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u64, arg3)) {
			glm::vec<4, glm::u64> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u64> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i16, arg3)) {
			glm::vec<2, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i16, arg3)) {
			glm::vec<3, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i16, arg3)) {
			glm::vec<4, glm::i16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u16, arg3)) {
			glm::vec<2, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u16, arg3)) {
			glm::vec<3, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u16, arg3)) {
			glm::vec<4, glm::u16> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u16> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::i8, arg3)) {
			glm::vec<2, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::i8, arg3)) {
			glm::vec<3, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::i8, arg3)) {
			glm::vec<4, glm::i8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::i8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, glm::u8, arg3)) {
			glm::vec<2, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, glm::u8, arg3)) {
			glm::vec<3, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, glm::u8, arg3)) {
			glm::vec<4, glm::u8> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, glm::u8> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(2, bool, arg3)) {
			glm::vec<2, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
				if (index > 1) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 2, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(3, bool, arg3)) {
			glm::vec<3, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
				if (index > 2) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 3, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
		if (PyGLM_Vec_Check(4, bool, arg3)) {
			glm::vec<4, bool> x;
			unpack_vec(arg3, x);
			if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<2, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<3, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
			if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
				if (index > 3) {
					PyErr_SetString(PyExc_IndexError, "index out of range");
					return NULL;
				}
				glm::mat<4, 4, bool> m;
				unpack_mat(arg1, m);
				return pack(glm::column(m, index, x));
			}
		}
	}
	else {
		if (PyGLM_Mat_Check(2, 2, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, float, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, float, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, float, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, float> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, double, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, double, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, double, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, double> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, int, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, int, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, int, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, int> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::uint, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::uint, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::uint, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::uint> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u64, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u64, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u64, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u64> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u16, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u16, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u16, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u16> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::i8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::i8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::i8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::i8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, glm::u8, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, glm::u8, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, glm::u8, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, glm::u8> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 2, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 3, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(2, 4, bool, arg1)) {
			if (index > 1) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<2, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(3, 2, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 3, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(3, 4, bool, arg1)) {
			if (index > 2) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<3, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

		if (PyGLM_Mat_Check(4, 2, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 2, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 3, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 3, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}
		if (PyGLM_Mat_Check(4, 4, bool, arg1)) {
			if (index > 3) {
				PyErr_SetString(PyExc_IndexError, "index out of range");
				return NULL;
			}
			glm::mat<4, 4, bool> m;
			unpack_mat(arg1, m);
			return pack(m[index]);
		}

	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for column()");
	return NULL;
}

static PyObject*
perlin_(PyObject*, PyObject* args) {
	PyObject *arg1, *arg2 = NULL;
	if (!PyArg_UnpackTuple(args, "perlin", 1, 2, &arg1, &arg2)) {
		PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perlin()");
		return NULL;
	}
	if (arg2 != NULL) {
		if (PyGLM_Vec_Check(2, float, arg1) && PyGLM_Vec_Check(2, float, arg2)) {
			glm::vec<2, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(3, float, arg1) && PyGLM_Vec_Check(3, float, arg2)) {
			glm::vec<3, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(4, float, arg1) && PyGLM_Vec_Check(4, float, arg2)) {
			glm::vec<4, float> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(2, double, arg1) && PyGLM_Vec_Check(2, double, arg2)) {
			glm::vec<2, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(3, double, arg1) && PyGLM_Vec_Check(3, double, arg2)) {
			glm::vec<3, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
		if (PyGLM_Vec_Check(4, double, arg1) && PyGLM_Vec_Check(4, double, arg2)) {
			glm::vec<4, double> o, o2;
			unpack_vec(arg1, o);
			unpack_vec(arg2, o2);
			return pack(glm::perlin(o, o2));
		}
	}
	else {
		if (PyGLM_Vec_Check(2, float, arg1)) {
			glm::vec<2, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(3, float, arg1)) {
			glm::vec<3, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(4, float, arg1)) {
			glm::vec<4, float> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(2, double, arg1)) {
			glm::vec<2, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(3, double, arg1)) {
			glm::vec<3, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
		if (PyGLM_Vec_Check(4, double, arg1)) {
			glm::vec<4, double> o;
			unpack_vec(arg1, o);
			return pack(glm::perlin(o));
		}
	}
	PyErr_SetString(PyExc_TypeError, "invalid argument type(s) for perlin()");
	return NULL;
}

static PyObject* simplex_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(2, float, arg)) { 
		glm::vec<2, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	} 
	if (PyGLM_Vec_Check(3, float, arg)) {
		glm::vec<3, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(4, float, arg)) {
		glm::vec<4, float> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(2, double, arg)) {
		glm::vec<2, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(3, double, arg)) {
		glm::vec<3, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	if (PyGLM_Vec_Check(4, double, arg)) {
		glm::vec<4, double> o;
		unpack_vec(arg, o);
		return pack(glm::simplex(o));
	}
	PyGLM_TYPEERROR_O("invalid argument type for simplex(): ", arg); 
	return NULL; 
}

PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(linearRand)
PyGLM_MAKE_GLM_FUNC_NN_VV__tGPL(gaussRand)

static PyObject*
circularRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "circularRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::circularRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for circularRand(): ", arg);
	return NULL;
}

static PyObject*
sphericalRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "sphericalRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::sphericalRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for sphericalRand(): ", arg);
	return NULL;
}

static PyObject*
diskRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "diskRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::diskRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for diskRand(): ", arg);
	return NULL;
}

static PyObject*
ballRand_(PyObject*, PyObject* arg) {
	if (PyGLM_Number_Check(arg)) {
		float f = PyGLM_Number_AsFloat(arg);
		if (f <= 0) {
			PyErr_SetString(PyExc_ValueError, "ballRand() requires a Radius greater than 0");
			return NULL;
		}
		return pack(glm::ballRand(f));
	}
	PyGLM_TYPEERROR_O("invalid argument type for ballRand(): ", arg);
	return NULL;
}

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sec)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(csc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(cot)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asec)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acsc)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acot)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(sech)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(csch)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(coth)

PyGLM_MAKE_GLM_FUNC_N_V__tfF(asech)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acsch)
PyGLM_MAKE_GLM_FUNC_N_V__tfF(acoth)

static PyObject*
sizeof_(PyObject*, PyObject* arg) {
	if (PyGLM_Vec_Check(1, float, arg) || arg == (PyObject*)&hfvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, float>));
	}
	if (PyGLM_Vec_Check(1, double, arg) || arg == (PyObject*)&hdvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, double>));
	}
	if (PyGLM_Vec_Check(1, int, arg) || arg == (PyObject*)&hivec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, int>));
	}
	if (PyGLM_Vec_Check(1, glm::uint, arg) || arg == (PyObject*)&huvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::uint>));
	}
	if (PyGLM_Vec_Check(1, glm::i64, arg) || arg == (PyObject*)&hi64vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i64>));
	}
	if (PyGLM_Vec_Check(1, glm::u64, arg) || arg == (PyObject*)&hu64vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u64>));
	}
	if (PyGLM_Vec_Check(1, glm::i16, arg) || arg == (PyObject*)&hi16vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i16>));
	}
	if (PyGLM_Vec_Check(1, glm::u16, arg) || arg == (PyObject*)&hu16vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u16>));
	}
	if (PyGLM_Vec_Check(1, glm::i8, arg) || arg == (PyObject*)&hi8vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::i8>));
	}
	if (PyGLM_Vec_Check(1, glm::u8, arg) || arg == (PyObject*)&hu8vec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, glm::u8>));
	}
	if (PyGLM_Vec_Check(1, bool, arg) || arg == (PyObject*)&hbvec1Type) {
		return PyLong_FromLong(sizeof(glm::vec<1, bool>));
	}
	if (PyGLM_Vec_Check(2, float, arg) || arg == (PyObject*)&hfvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, float>));
	}
	if (PyGLM_Vec_Check(2, double, arg) || arg == (PyObject*)&hdvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, double>));
	}
	if (PyGLM_Vec_Check(2, int, arg) || arg == (PyObject*)&hivec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, int>));
	}
	if (PyGLM_Vec_Check(2, glm::uint, arg) || arg == (PyObject*)&huvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::uint>));
	}
	if (PyGLM_Vec_Check(2, glm::i64, arg) || arg == (PyObject*)&hi64vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i64>));
	}
	if (PyGLM_Vec_Check(2, glm::u64, arg) || arg == (PyObject*)&hu64vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u64>));
	}
	if (PyGLM_Vec_Check(2, glm::i16, arg) || arg == (PyObject*)&hi16vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i16>));
	}
	if (PyGLM_Vec_Check(2, glm::u16, arg) || arg == (PyObject*)&hu16vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u16>));
	}
	if (PyGLM_Vec_Check(2, glm::i8, arg) || arg == (PyObject*)&hi8vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::i8>));
	}
	if (PyGLM_Vec_Check(2, glm::u8, arg) || arg == (PyObject*)&hu8vec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, glm::u8>));
	}
	if (PyGLM_Vec_Check(2, bool, arg) || arg == (PyObject*)&hbvec2Type) {
		return PyLong_FromLong(sizeof(glm::vec<2, bool>));
	}
	if (PyGLM_Vec_Check(3, float, arg) || arg == (PyObject*)&hfvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, float>));
	}
	if (PyGLM_Vec_Check(3, double, arg) || arg == (PyObject*)&hdvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, double>));
	}
	if (PyGLM_Vec_Check(3, int, arg) || arg == (PyObject*)&hivec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, int>));
	}
	if (PyGLM_Vec_Check(3, glm::uint, arg) || arg == (PyObject*)&huvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::uint>));
	}
	if (PyGLM_Vec_Check(3, glm::i64, arg) || arg == (PyObject*)&hi64vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i64>));
	}
	if (PyGLM_Vec_Check(3, glm::u64, arg) || arg == (PyObject*)&hu64vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u64>));
	}
	if (PyGLM_Vec_Check(3, glm::i16, arg) || arg == (PyObject*)&hi16vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i16>));
	}
	if (PyGLM_Vec_Check(3, glm::u16, arg) || arg == (PyObject*)&hu16vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u16>));
	}
	if (PyGLM_Vec_Check(3, glm::i8, arg) || arg == (PyObject*)&hi8vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::i8>));
	}
	if (PyGLM_Vec_Check(3, glm::u8, arg) || arg == (PyObject*)&hu8vec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, glm::u8>));
	}
	if (PyGLM_Vec_Check(3, bool, arg) || arg == (PyObject*)&hbvec3Type) {
		return PyLong_FromLong(sizeof(glm::vec<3, bool>));
	}
	if (PyGLM_Vec_Check(4, float, arg) || arg == (PyObject*)&hfvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, float>));
	}
	if (PyGLM_Vec_Check(4, double, arg) || arg == (PyObject*)&hdvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, double>));
	}
	if (PyGLM_Vec_Check(4, int, arg) || arg == (PyObject*)&hivec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, int>));
	}
	if (PyGLM_Vec_Check(4, glm::uint, arg) || arg == (PyObject*)&huvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::uint>));
	}
	if (PyGLM_Vec_Check(4, glm::i64, arg) || arg == (PyObject*)&hi64vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i64>));
	}
	if (PyGLM_Vec_Check(4, glm::u64, arg) || arg == (PyObject*)&hu64vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u64>));
	}
	if (PyGLM_Vec_Check(4, glm::i16, arg) || arg == (PyObject*)&hi16vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i16>));
	}
	if (PyGLM_Vec_Check(4, glm::u16, arg) || arg == (PyObject*)&hu16vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u16>));
	}
	if (PyGLM_Vec_Check(4, glm::i8, arg) || arg == (PyObject*)&hi8vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::i8>));
	}
	if (PyGLM_Vec_Check(4, glm::u8, arg) || arg == (PyObject*)&hu8vec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, glm::u8>));
	}
	if (PyGLM_Vec_Check(4, bool, arg) || arg == (PyObject*)&hbvec4Type) {
		return PyLong_FromLong(sizeof(glm::vec<4, bool>));
	}
	if (PyGLM_Qua_Check(float, arg) || arg == (PyObject*)&hfquaType) {
		return PyLong_FromLong(sizeof(glm::qua<float>));
	}
	if (PyGLM_Qua_Check(double, arg) || arg == (PyObject*)&hdquaType) {
		return PyLong_FromLong(sizeof(glm::qua<double>));
	}
	if (PyGLM_Mat_Check(2, 2, float, arg) || arg == (PyObject*)&hfmat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, float>));
	}
	if (PyGLM_Mat_Check(2, 2, double, arg) || arg == (PyObject*)&hdmat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, double>));
	}
	if (PyGLM_Mat_Check(2, 2, int, arg) || arg == (PyObject*)&himat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, int>));
	}
	if (PyGLM_Mat_Check(2, 2, glm::uint, arg) || arg == (PyObject*)&humat2x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(2, 3, float, arg) || arg == (PyObject*)&hfmat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, float>));
	}
	if (PyGLM_Mat_Check(2, 3, double, arg) || arg == (PyObject*)&hdmat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, double>));
	}
	if (PyGLM_Mat_Check(2, 3, int, arg) || arg == (PyObject*)&himat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, int>));
	}
	if (PyGLM_Mat_Check(2, 3, glm::uint, arg) || arg == (PyObject*)&humat2x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(2, 4, float, arg) || arg == (PyObject*)&hfmat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, float>));
	}
	if (PyGLM_Mat_Check(2, 4, double, arg) || arg == (PyObject*)&hdmat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, double>));
	}
	if (PyGLM_Mat_Check(2, 4, int, arg) || arg == (PyObject*)&himat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, int>));
	}
	if (PyGLM_Mat_Check(2, 4, glm::uint, arg) || arg == (PyObject*)&humat2x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<2, 4, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 2, float, arg) || arg == (PyObject*)&hfmat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, float>));
	}
	if (PyGLM_Mat_Check(3, 2, double, arg) || arg == (PyObject*)&hdmat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, double>));
	}
	if (PyGLM_Mat_Check(3, 2, int, arg) || arg == (PyObject*)&himat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, int>));
	}
	if (PyGLM_Mat_Check(3, 2, glm::uint, arg) || arg == (PyObject*)&humat3x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 3, float, arg) || arg == (PyObject*)&hfmat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, float>));
	}
	if (PyGLM_Mat_Check(3, 3, double, arg) || arg == (PyObject*)&hdmat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, double>));
	}
	if (PyGLM_Mat_Check(3, 3, int, arg) || arg == (PyObject*)&himat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, int>));
	}
	if (PyGLM_Mat_Check(3, 3, glm::uint, arg) || arg == (PyObject*)&humat3x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(3, 4, float, arg) || arg == (PyObject*)&hfmat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, float>));
	}
	if (PyGLM_Mat_Check(3, 4, double, arg) || arg == (PyObject*)&hdmat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, double>));
	}
	if (PyGLM_Mat_Check(3, 4, int, arg) || arg == (PyObject*)&himat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, int>));
	}
	if (PyGLM_Mat_Check(3, 4, glm::uint, arg) || arg == (PyObject*)&humat3x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<3, 4, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 2, float, arg) || arg == (PyObject*)&hfmat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, float>));
	}
	if (PyGLM_Mat_Check(4, 2, double, arg) || arg == (PyObject*)&hdmat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, double>));
	}
	if (PyGLM_Mat_Check(4, 2, int, arg) || arg == (PyObject*)&himat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, int>));
	}
	if (PyGLM_Mat_Check(4, 2, glm::uint, arg) || arg == (PyObject*)&humat4x2Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 2, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 3, float, arg) || arg == (PyObject*)&hfmat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, float>));
	}
	if (PyGLM_Mat_Check(4, 3, double, arg) || arg == (PyObject*)&hdmat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, double>));
	}
	if (PyGLM_Mat_Check(4, 3, int, arg) || arg == (PyObject*)&himat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, int>));
	}
	if (PyGLM_Mat_Check(4, 3, glm::uint, arg) || arg == (PyObject*)&humat4x3Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 3, glm::uint>));
	}
	if (PyGLM_Mat_Check(4, 4, float, arg) || arg == (PyObject*)&hfmat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, float>));
	}
	if (PyGLM_Mat_Check(4, 4, double, arg) || arg == (PyObject*)&hdmat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, double>));
	}
	if (PyGLM_Mat_Check(4, 4, int, arg) || arg == (PyObject*)&himat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, int>));
	}
	if (PyGLM_Mat_Check(4, 4, glm::uint, arg) || arg == (PyObject*)&humat4x4Type) {
		return PyLong_FromLong(sizeof(glm::mat<4, 4, glm::uint>));
	}
	PyGLM_TYPEERROR_O("sizeof() requires the argument to be a glm type, not ", arg);
	return NULL;
}

static PyObject*
value_ptr_(PyObject* self, PyObject* arg) {
	if (Py_TYPE(arg) == &hfvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<2, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<3, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hivec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &huvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi64vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu64vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u64>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi16vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu16vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u16>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hi8vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::i8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hu8vec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, glm::u8>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hbvec4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((vec<4, bool>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfquaType) {
		return PyGLM_ToCtypesP(glm::value_ptr(((qua<float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdquaType) {
		return PyGLM_ToCtypesP(glm::value_ptr(((qua<double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat2x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<2, 4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat3x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<3, 4, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x2Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 2, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x3Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 3, glm::uint>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hfmat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, float>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &hdmat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, double>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &himat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, int>*)arg)->super_type));
	}
	if (Py_TYPE(arg) == &humat4x4Type) {
		return PyGLM_ToCtypesP(glm::value_ptr(((mat<4, 4, glm::uint>*)arg)->super_type));
	}
	PyGLM_TYPEERROR_O("value_ptr() requires the argument to be a glm type, not ", arg);
	return NULL;
}

static PyObject*
make_vec2_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec2((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec2((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec2((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec2((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec2((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec2((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec2((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}

static PyObject*
make_vec3_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec3((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec3((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec3((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec3((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec3((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec3((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec3((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}

static PyObject*
make_vec4_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_vec4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_vec4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_vec4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_vec4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int64_p)) {
		return pack(glm::make_vec4((glm::i64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint64_p)) {
		return pack(glm::make_vec4((glm::u64*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int16_p)) {
		return pack(glm::make_vec4((glm::i16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint16_p)) {
		return pack(glm::make_vec4((glm::u16*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int8_p)) {
		return pack(glm::make_vec4((glm::i8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint8_p)) {
		return pack(glm::make_vec4((glm::u8*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_bool_p)) {
		return pack(glm::make_vec4((bool*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_vec4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_quat_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_quat((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_quat((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_quat() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x2_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x3_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat2x4_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat2x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat2x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat2x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat2x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat2x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x2_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x3_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat3x4_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat3x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat3x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat3x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat3x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat3x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x2_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x2((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x2((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x2((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x2((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x2() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x3_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x3((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x3((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x3((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x3((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x3() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}
static PyObject*
make_mat4x4_(PyObject* self, PyObject* arg) {
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_float_p)) {
		return pack(glm::make_mat4x4((float*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_double_p)) {
		return pack(glm::make_mat4x4((double*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_int32_p)) {
		return pack(glm::make_mat4x4((int*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	if (PyObject_TypeCheck(arg, (PyTypeObject*)ctypes_uint32_p)) {
		return pack(glm::make_mat4x4((glm::uint*)PyGLM_UnsignedLongLong_FromCtypesP(arg)));
	}
	PyGLM_TYPEERROR_O("make_mat4x4() requires a ctypes pointer as it's argument, not ", arg);
	return NULL;
}


static PyObject*
silence(PyObject*, PyObject* arg) {
	if (PyLong_Check(arg)) {
		int warning_id = static_cast<int>(PyLong_AS_LONG(arg));
		if (warning_id < 0 || warning_id > 1) {
			PyErr_SetString(PyExc_ValueError, "the specified warning does not exist.");
			return NULL;
		}
		if (warning_id == 0) {
			PyGLM_SHOW_WARNINGS = 0;
		}
		else {
			PyGLM_SHOW_WARNINGS = PyGLM_SHOW_WARNINGS ^ warning_id;
		}
		Py_RETURN_NONE;
	}
	PyGLM_TYPEERROR_O("silence() requires an integer as it's argument, not ", arg);
	return NULL;
}

//static PyObject*
//test(PyObject* self, PyObject* arg) {
//	return pack_mat2x2(glm::identity<glm::mat2>());
//}
//#define HAS_TEST
//#define TEST_FUNC_TYPE METH_NOARGS

static PyMethodDef glmmethods[] = {
	// DETAIL
	// func_packing
	{ "packDouble2x32", (PyCFunction)packDouble2x32_, METH_O, "packDouble2x32(v) -> float\nReturns a double-qualifier value obtained by packing the components of v into a 64-bit value." },
	{ "packUnorm2x16", (PyCFunction)packUnorm2x16_, METH_O, "packUnorm2x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packSnorm2x16", (PyCFunction)packSnorm2x16_, METH_O, "packSnorm2x16(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packSnorm4x8", (PyCFunction)packSnorm4x8_, METH_O, "packSnorm4x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packUnorm4x8", (PyCFunction)packUnorm4x8_, METH_O, "packUnorm4x8(v) -> int\nFirst, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.\nThen, the results are packed into the returned 32-bit unsigned integer." },
	{ "packHalf2x16", (PyCFunction)packHalf2x16_, METH_O, "packHalf2x16(v) -> int\nReturns an unsigned integer obtained by converting the components of a two - component floating - point vector\nto the 16-bit floating-point representation found in the OpenGL Specification,\nand then packing these two 16- bit integers into a 32-bit unsigned integer." },
	{ "unpackDouble2x32", (PyCFunction)unpackDouble2x32_, METH_O, "unpackDouble2x32(v) -> float\nReturns a two-component unsigned integer vector representation of v." },
	{ "unpackUnorm2x16", (PyCFunction)unpackUnorm2x16_, METH_O, "unpackUnorm2x16(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackSnorm2x16", (PyCFunction)unpackSnorm2x16_, METH_O, "unpackSnorm2x16(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackSnorm4x8", (PyCFunction)unpackSnorm4x8_, METH_O, "unpackSnorm4x8(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackUnorm4x8", (PyCFunction)unpackUnorm4x8_, METH_O, "unpackUnorm4x8(v) -> int\nFirst, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\nThen, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector." },
	{ "unpackHalf2x16", (PyCFunction)unpackHalf2x16_, METH_O, "unpackHalf2x16(v) -> int\nReturns a two - component floating - point vector with components obtained by unpacking a 32 - bit unsigned integer into a pair of 16 - bit values,\ninterpreting those values as 16-bit floating-point numbers according to the OpenGL Specification,\nand converting them to 32-bit floating-point values." },

	// func_integer
	{ "uaddCarry", (PyCFunction)uaddCarry_, METH_VARARGS, "uaddCarry(x, y, Carry) -> vecn\nAdds 32-bit unsigned integer x and y, returning the sum\nmodulo pow(2, 32). The value carry is set to 0 if the sum was\nless than pow(2, 32), or to 1 otherwise." },
	{ "usubBorrow", (PyCFunction)usubBorrow_, METH_VARARGS, "usubBorrow(x, y, Borrow) -> vecn\nSubtracts the 32-bit unsigned integer y from x, returning\nthe difference if non-negative, or pow(2, 32) plus the difference\notherwise. The value borrow is set to 0 if x >= y, or to 1 otherwise." },
	{ "umulExtended", (PyCFunction)umulExtended_, METH_VARARGS, "umulExtended(x, y, msb, lsb) -> None\nMultiplies 32-bit integers x and y, producing a 64-bit\nresult. The 32 least-significant bits are returned in lsb.\nThe 32 most-significant bits are returned in msb." },
	{ "imulExtended", (PyCFunction)imulExtended_, METH_VARARGS, "imulExtended(x, y, msb, lsb) -> None\nMultiplies 32-bit integers x and y, producing a 64-bit\nresult. The 32 least-significant bits are returned in lsb.\nThe 32 most-significant bits are returned in msb." },
	{ "bitfieldExtract", (PyCFunction)bitfieldExtract_, METH_VARARGS, "bitfieldExtract(Value, Offset, Bits) -> vecn or int\nExtracts bits [offset, offset + bits - 1] from value,\nreturning them in the least significant bits of the result." },
	{ "bitfieldInsert", (PyCFunction)bitfieldInsert_, METH_VARARGS, "bitfieldInsert(Base, Insert, Offset, Bits) -> vecn or int\nReturns the insertion the bits least-significant bits of insert into base." },
	{ "bitfieldReverse", (PyCFunction)bitfieldReverse_, METH_O, "bitfieldReverse(v) -> vecn or float\nReturns the reversal of the bits of value." },
	{ "bitCount", (PyCFunction)bitCount_, METH_O, "bitCount(v) -> vecn or int\nReturns the number of bits set to 1 in the binary representation of value." },
	{ "findLSB", (PyCFunction)findLSB_, METH_O, "findLSB(x) -> vecn or int\nReturns the bit number of the least significant bit set to\n1 in the binary representation of value.\nIf value is zero, -1 will be returned." },
	{ "findMSB", (PyCFunction)findMSB_, METH_O, "findMSB(x) -> vecn or int\nReturns the bit number of the most significant bit in the binary representation of value." },

	// func_vector_relational
	{ "equal", (PyCFunction)equal, METH_VARARGS, "equal(x, y[, ...]) -> (x == y)\nReturns the component-wise comparison of result x == y." },
	{ "notEqual", (PyCFunction)notEqual, METH_VARARGS, "notEqual(x, y[, ...]) -> (x != y)\nReturns the component-wise comparison of result x != y." },
	{ "lessThan", (PyCFunction)lessThan, METH_VARARGS, "lessThan(x, y) -> (x < y)\nReturns the component-wise comparison of result x < y." },
	{ "lessThanEqual", (PyCFunction)lessThanEqual, METH_VARARGS, "lessThanEqual(x, y) -> (x <= y)\nReturns the component-wise comparison of result x <= y." },
	{ "greaterThan", (PyCFunction)greaterThan, METH_VARARGS, "greaterThan(x, y) -> (x > y)\nReturns the component-wise comparison of result x > y." },
	{ "greaterThanEqual", (PyCFunction)greaterThanEqual, METH_VARARGS, "greaterThanEqual(x, y) -> (x >= y)\nReturns the component-wise comparison of result x >= y." },
	{ "any", (PyCFunction)any, METH_O, "any(x) -> bool\nReturns true if any component of x is true." },
	{ "all", (PyCFunction)all, METH_O, "all(x) -> bool\nReturns true if all components of x are true." },
	{ "not_", (PyCFunction)not_, METH_O, "not(x) -> bool\nReturns the component-wise logical complement of x." },

	// func_exponential 
	{ "pow", (PyCFunction)pow_, METH_VARARGS, "pow(base, exponent) -> float, vecn or quat\nReturns 'base' raised to the power 'exponent'." },
	{ "exp", (PyCFunction)exp_, METH_O, "exp(x) -> float, vecn or quat\nReturns the natural exponentiation of x, i.e., e^x." },
	{ "log", (PyCFunction)log_, METH_O, "log(v) -> float, vecn or quat\nReturns the natural logarithm of v, i.e.,\nreturns the value y which satisfies the equation x = e^y.\nResults are undefined if v <= 0." },
	{ "exp2", (PyCFunction)exp2_, METH_O, "exp2(v) -> float or vecn\nReturns 2 raised to the v power." },
	{ "log2", (PyCFunction)log2_, METH_O, "log2(x) -> float or vecn\nReturns the base 2 log of x, i.e., returns the value y,\nwhich satisfies the equation x = 2 ^ y." },
	{ "sqrt", (PyCFunction)sqrt_, METH_O, "sqrt(v) -> float, vecn or quat\nReturns the positive square root of v." },
	{ "inversesqrt", (PyCFunction)inversesqrt_, METH_O, "inversesqrt(v) -> float or vecn\nReturns the reciprocal of the positive square root of v." },

	// func_common
	{ "abs", (PyCFunction)abs_, METH_O, "abs(x) -> float or vecn\nReturns x if x >= 0; otherwise, it returns -x." },
	{ "sign", (PyCFunction)sign_, METH_O, "sign(x) -> float or vecn\nReturns 1.0 if x > 0, 0.0 if x == 0, or -1.0 if x < 0. " },
	{ "floor", (PyCFunction)floor_, METH_O, "floor(x) -> float or vecn\nReturns a value equal to the nearest integer that is less then or equal to x." },
	{ "trunc", (PyCFunction)trunc_, METH_O, "trunc(x) -> float or vecn\nReturns a value equal to the nearest integer to x\nwhose absolute value is not larger than the absolute value of x." },
	{ "round", (PyCFunction)round_, METH_O, "round(x) -> float or vecn\nReturns a value equal to the nearest integer to x.\nThe fraction 0.5 will round in a direction chosen by the\nimplementation, presumably the direction that is fastest.\nThis includes the possibility that round(x) returns the\nsame value as roundEven(x) for all values of x." },
	{ "roundEven", (PyCFunction)roundEven_, METH_O, "roundEven(x) -> float or vecn\nReturns a value equal to the nearest integer to x.\nA fractional part of 0.5 will round toward the nearest even\ninteger. (Both 3.5 and 4.5 for x will return 4.0.)" },
	{ "ceil", (PyCFunction)ceil_, METH_O, "ceil(x) -> float or vecn\nReturns a value equal to the nearest integer\nthat is greater than or equal to x." },
	{ "fract", (PyCFunction)fract_, METH_O, "fract(x) -> float or vecn\nReturn x - floor(x)." },
	{ "mod", (PyCFunction)mod_, METH_VARARGS, "mod(x, y) -> float or vecn\nModulus. Returns x - y * floor(x / y)\nfor each component in x using the floating point value y." },
	{ "min", (PyCFunction)min_, METH_VARARGS, "min(x, y) -> float or vecn\nReturns y if y < x; otherwise, it returns x." },
	{ "max", (PyCFunction)max_, METH_VARARGS, "max(x, y) -> float or vecn\nReturns y if x < y; otherwise, it returns x." },
	{ "clamp", (PyCFunction)clamp_, METH_VARARGS, "clamp(x, minVal, maxVal) -> float or vecn\nReturns min(max(x, minVal), maxVal) for each component in x\nusing the floating-point values minVal and maxVal." },
	{ "mix", (PyCFunction)mix_, METH_VARARGS, "mix(x, y, a) -> float, vecn or quat\nReturns x * (1.0 - a) + y * a, i.e., the linear blend of\nx and y using the floating-point value a.\nThe value for a is not restricted to the range [0, 1]." },
	{ "step", (PyCFunction)step_, METH_VARARGS, "step(edge, x) -> Returns 0.0 if x < edge, otherwise it returns 1.0." },
	{ "smoothstep", (PyCFunction)smoothstep_, METH_VARARGS, "smoothstep(edge0, edge1, x) -> float or vecn\nReturns 0.0 if x <= edge0 and 1.0 if x >= edge1 and\nperforms smooth Hermite interpolation between 0 and 1\nwhen edge0 < x < edge1. This is useful in cases where\nyou would want a threshold function with a smooth\ntransition." },
	{ "isnan", (PyCFunction)isnan_, METH_O, "isnan(x) -> bool or vecn\nReturns true if x holds a NaN (not a number)\nrepresentation in the underlying implementation's set of\nfloating point representations. Returns false otherwise,\nincluding for implementations with no NaN\nrepresentations." },
	{ "isinf", (PyCFunction)isinf_, METH_O, "isinf(x) -> bool or vecn\nReturns true if x holds a positive infinity or negative\ninfinity representation in the underlying implementation's\nset of floating point representations. Returns false\notherwise, including for implementations with no infinity\nrepresentations." },
	{ "fma", (PyCFunction)fma_, METH_VARARGS, "fma(a, b, c) -> float\nComputes and returns a * b + c." },
	{ "frexp", (PyCFunction)frexp_, METH_VARARGS, "frexp(x, exp) -> float or vecn\nSplits x into a floating-point significand in the range\n[0.5, 1.0) and an integral exponent of two, such that:\nx = significand * exp(2, exponent)" },
	{ "ldexp", (PyCFunction)ldexp_, METH_VARARGS, "ldexp(x, exp) -> float or vecn\nBuilds a floating-point number from x and the\ncorresponding integral exponent of two in exp, returning:\nsignificand * exp(2, exponent)" },

	// func_geometric
	{ "length", (PyCFunction)length_, METH_O, "length(x) -> float\nReturns the length of x, i.e., sqrt(x * x)." },
	{ "distance", (PyCFunction)distance_, METH_VARARGS, "distance(p0, p1) -> float\nReturns the distance betwwen p0 and p1, i.e., length(p0 - p1)." },
	{ "dot", (PyCFunction)dot_, METH_VARARGS, "dot(x, y) -> float\nReturns the dot product of x and y, i.e., result = x * y." },
	{ "cross", (PyCFunction)cross_, METH_VARARGS, "cross(x, y) -> vec3 or quat\nReturns the cross product of x and y." },
	{ "normalize", (PyCFunction)normalize_, METH_O, "normalize(x) -> vecn or quat\nReturns a vector in the same direction as x but with length of 1." },
	{ "faceforward", (PyCFunction)faceforward_, METH_VARARGS, "faceforward(N, I, Nref) -> float or vecn\nIf dot(Nref, I) < 0.0, return N, otherwise, return -N." },
	{ "reflect", (PyCFunction)reflect_, METH_VARARGS, "reflect(I, N) -> float or vecn\nFor the incident vector I and surface orientation N,\nreturns the reflection direction : result = I - 2.0 * dot(N, I) * N." },
	{ "refract", (PyCFunction)refract_, METH_VARARGS, "refract(I, N, eta) -> float or vecn\nFor the incident vector I and surface normal N,\nand the ratio of indices of refraction eta,\nreturn the refraction vector." },

	// func_matrix
	{ "matrixCompMult", (PyCFunction)matrixCompMult_, METH_VARARGS, "matrixCompMult(x, y) -> matnxn\nMultiply matrix x by matrix y component-wise, i.e.,\nresult[i][j] is the scalar product of x[i][j] and y[i][j]." },
	{ "outerProduct", (PyCFunction)outerProduct_, METH_VARARGS, "outerProduct(c, r) -> matnxn\nTreats the first parameter c as a column vector\nand the second parameter r as a row vector\nand does a linear algebraic matrix multiply c * r." },
	{ "transpose", (PyCFunction)transpose_, METH_O, "transpose(x) -> matnxn\nReturns the transposed matrix of x" },
	{ "determinant", (PyCFunction)determinant_, METH_O, "determinant(x) -> float\nReturn the determinant of a squared matrix." },
	{ "inverse", (PyCFunction)inverse_, METH_O, "inverse(x) -> matnxn or quat\nReturn the inverse of a squared matrix or quaternion." },

	// func_trigonometric
	{ "radians", (PyCFunction)radians_, METH_O, "radians(x) -> float or vecn\nConverts degrees to radians and returns the result." },
	{ "degrees", (PyCFunction)degrees_, METH_O, "degrees(x) -> float or vecn\nConverts radians to degrees and returns the result." },
	{ "sin", (PyCFunction)sin_, METH_O, "sin(x) -> vecn\nThe standard trigonometric sine function. \nThe values returned by this function will range from [-1, 1]." },
	{ "cos", (PyCFunction)cos_, METH_O, "cos(x) -> vecn\nThe standard trigonometric cosine function.\nThe values returned by this function will range from [-1, 1]." },
	{ "tan", (PyCFunction)tan_, METH_O, "tan(x) -> vecn\nThe standard trigonometric tangent function." },
	{ "asin", (PyCFunction)asin_, METH_O, "asin(x) -> vecn\nArc sine. Returns an angle whose sine is x. \nThe range of values returned by this function is [-PI/2, PI/2].\nResults are undefined if |x| > 1." },
	{ "acos", (PyCFunction)acos_, METH_O, "acos(x) -> vecn\nArc cosine. Returns an angle whose sine is x.\nThe range of values returned by this function is [0, PI].\nResults are undefined if |x| > 1." },
	{ "atan", (PyCFunction)atan_,  METH_VARARGS | METH_KEYWORDS, "atan(y [,x]) -> float or vecn\nArc tangent. Returns an angle whose tangent is y/x.\nThe signs of x and y are used to determine what\nquadrant the angle is in. The range of values returned\nby this function is [-PI, PI]. Results are undefined\nif x and y are both 0." },
	{ "sinh", (PyCFunction)sinh_, METH_O, "sinh(x) -> vecn\nReturns the hyperbolic sine function, (exp(x) - exp(-x)) / 2" },
	{ "cosh", (PyCFunction)cosh_, METH_O, "cosh(x) -> vecn\nReturns the hyperbolic cosine function, (exp(x) + exp(-x)) / 2" },
	{ "tanh", (PyCFunction)tanh_, METH_O, "tanh(x) -> vecn\nReturns the hyperbolic tangent function, sinh(angle) / cosh(angle)" },
	{ "asinh", (PyCFunction)asinh_, METH_O, "asinh(x) -> float or vecn\nArc hyperbolic sine; returns the inverse of sinh." },
	{ "acosh", (PyCFunction)acosh_, METH_O, "acosh(x) -> float or vecn\nArc hyperbolic cosine; returns the non-negative inverse\nof cosh. Results are undefined if x < 1." },
	{ "atanh", (PyCFunction)atanh_, METH_O, "atanh(x) -> float or vecn\nArc hyperbolic tangent; returns the inverse of tanh.\nResults are undefined if abs(x) >= 1." },

	// EXTENSIONS
	// color_space
	{ "convertLinearToSRGB", (PyCFunction)convertLinearToSRGB_, METH_VARARGS | METH_KEYWORDS, "convertLinearToSRGB(ColorLinear[, Gamma]) -> vecn\nConvert a linear color to sRGB color using a standard / custom gamma correction." },
	{ "convertSRGBToLinear", (PyCFunction)convertSRGBToLinear_, METH_VARARGS | METH_KEYWORDS, "convertSRGBToLinear(ColorLinear[, Gamma]) -> vecn\nConvert a sRGB color to linear color using a standard / custom gamma correction." },

	// constants
	{ "epsilon", (PyCFunction)epsilon_, METH_NOARGS, "epsilon() -> float\nReturn the epsilon constant for floating point types." },
	{ "zero", (PyCFunction)zero_, METH_NOARGS, "zero() -> float\nReturn 0." },
	{ "one", (PyCFunction)one_, METH_NOARGS, "one() -> float\nReturn 1." },
	{ "pi", (PyCFunction)pi_, METH_NOARGS, "pi() -> float\nReturn the pi constant." },
	{ "two_pi", (PyCFunction)two_pi_, METH_NOARGS, "two_pi() -> float\nReturn pi * 2." },
	{ "root_pi", (PyCFunction)root_pi_, METH_NOARGS, "root_pi() -> float\nReturn square root of pi." },
	{ "half_pi", (PyCFunction)half_pi_, METH_NOARGS, "half_pi() -> float\nReturn pi / 2." },
	{ "three_over_two_pi", (PyCFunction)three_over_two_pi_, METH_NOARGS, "three_over_two_pi() -> float\nReturn pi / 2 * 3." },
	{ "quarter_pi", (PyCFunction)quarter_pi_, METH_NOARGS, "quarter_pi() -> float\nReturn pi / 4." },
	{ "one_over_pi", (PyCFunction)one_over_pi_, METH_NOARGS, "one_over_pi() -> float\nReturn 1 / pi." },
	{ "one_over_two_pi", (PyCFunction)one_over_two_pi_, METH_NOARGS, "one_over_two_pi() -> float\nReturn 1 / (pi * 2)." },
	{ "two_over_pi", (PyCFunction)two_over_pi_, METH_NOARGS, "two_over_pi() -> float\nReturn 2 / pi." },
	{ "four_over_pi", (PyCFunction)four_over_pi_, METH_NOARGS, "four_over_pi() -> float\nReturn 4 / pi." },
	{ "two_over_root_pi", (PyCFunction)two_over_root_pi_, METH_NOARGS, "two_over_root_pi() -> float\nReturn 2 / sqrt(pi)." },
	{ "one_over_root_two", (PyCFunction)one_over_root_two_, METH_NOARGS, "one_over_root_two() -> float\nReturn 1 / sqrt(2)." },
	{ "root_half_pi", (PyCFunction)root_half_pi_, METH_NOARGS, "root_half_pi() -> float\nReturn sqrt(pi / 2)." },
	{ "root_two_pi", (PyCFunction)root_two_pi_, METH_NOARGS, "root_two_pi() -> float\nReturn sqrt(2 * pi)." },
	{ "root_ln_four", (PyCFunction)root_ln_four_, METH_NOARGS, "root_ln_four() -> float\nReturn sqrt(ln(4))." },
	{ "e", (PyCFunction)e_, METH_NOARGS, "e() -> float\nReturn e constant." },
	{ "euler", (PyCFunction)euler_, METH_NOARGS, "euler() -> float\nReturn Euler's constant." },
	{ "root_two", (PyCFunction)root_two_, METH_NOARGS, "root_two() -> float\nReturn sqrt(2)." },
	{ "root_three", (PyCFunction)root_three_, METH_NOARGS, "root_three() -> float\nReturn sqrt(3)." },
	{ "root_five", (PyCFunction)root_five_, METH_NOARGS, "root_five() -> float\nReturn sqrt(5)." },
	{ "ln_two", (PyCFunction)ln_two_, METH_NOARGS, "ln_two() -> float\nReturn ln(2)." },
	{ "ln_ten", (PyCFunction)ln_ten_, METH_NOARGS, "ln_ten() -> float\nReturn ln(10)." },
	{ "ln_ln_two", (PyCFunction)ln_ln_two_, METH_NOARGS, "ln_ln_two() -> float\nReturn ln(ln(2))." },
	{ "third", (PyCFunction)third_, METH_NOARGS, "third() -> float\nReturn 1 / 3." },
	{ "two_thirds", (PyCFunction)two_thirds_, METH_NOARGS, "two_thirds() -> float\nReturn 2 / 3." },
	{ "golden_ratio", (PyCFunction)golden_ratio_, METH_NOARGS, "golden_ratio() -> float\nReturn the golden ratio constant." },

	// epsilon
	{ "epsilonEqual", (PyCFunction)epsilonEqual_, METH_VARARGS, "epsilonEqual(x, y, epsilon) -> vecn or quat\nReturns the component-wise comparison of |x - y| < epsilon.\nTrue if this expression is satisfied." },
	{ "epsilonNotEqual", (PyCFunction)epsilonNotEqual_, METH_VARARGS, "epsilonNotEqual(x, y, epsilon) -> vecn or quat\nReturns the component-wise comparison of |x - y| >= epsilon.\nTrue if this expression is satisfied." },

	// integer
	{ "iround", (PyCFunction)iround_, METH_O, "iround(x) -> int or ivec\nReturns a value equal to the nearest integer to x." },
	{ "uround", (PyCFunction)uround_, METH_O, "uround(x) -> int or uvec\nReturns a value equal to the nearest integer to x." },

	// matrix_inverse
	{ "affineInverse", (PyCFunction)affineInverse_, METH_O, "affineInverse(m) -> matn\nFast matrix inverse for affine matrix." },
	{ "inverseTranspose", (PyCFunction)inverseTranspose_, METH_O, "inverseTranspose(m) -> matn\nCompute the inverse transpose of a matrix." },

	// matrix_transform
	{ "identity", (PyCFunction)identity_, METH_O, "identity(matrix_type) -> matrix\nBuilds an identity matrix." },
	{ "translate", (PyCFunction)translate_, METH_VARARGS, "translate(m, v) -> mat4x4\nBuilds a translation 4 * 4 matrix created from a vector of 3 components." },
	{ "rotate", (PyCFunction)rotate_, METH_VARARGS, "rotate(m, angle, axis) -> mat4x4 or quat\nBuilds a rotation 4 * 4 matrix created from an axis vector and an angle\nor rotates a quaternion from a vector of 3 components axis and an angle." },
	{ "rotate_slow", (PyCFunction)rotate_slow_, METH_VARARGS, "rotate_slow(m, angle, axis) -> mat4x4\nBuilds a rotation 4 * 4 matrix created from an axis vector and an angle." },
	{ "scale", (PyCFunction)scale_, METH_VARARGS, "scale(m, v) -> mat4x4\nBuilds a scale 4 * 4 matrix created from 3 scalars." },
	{ "scale_slow", (PyCFunction)scale_slow_, METH_VARARGS, "scale_slow(m, v) -> mat4x4\nBuilds a scale 4 * 4 matrix created from 3 scalars." },
	{ "ortho", (PyCFunction)ortho_, METH_VARARGS, "ortho(left, right, bottom, top[, zNear, zFar]) -> mat4x4\nCreates a matrix for projecting two-dimensional coordinates onto the screen." },
	{ "orthoLH_ZO", (PyCFunction)orthoLH_ZO_, METH_VARARGS, "orthoLH_ZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoLH_NO", (PyCFunction)orthoLH_NO_, METH_VARARGS, "orthoLH_NO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoRH_ZO", (PyCFunction)orthoRH_ZO_, METH_VARARGS, "orthoRH_ZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoRH_NO", (PyCFunction)orthoRH_NO_, METH_VARARGS, "orthoRH_NO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoZO", (PyCFunction)orthoZO_, METH_VARARGS, "orthoZO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "orthoNO", (PyCFunction)orthoNO_, METH_VARARGS, "orthoNO(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoLH", (PyCFunction)orthoLH_, METH_VARARGS, "orthoLH(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "orthoRH", (PyCFunction)orthoRH_, METH_VARARGS, "orthoRH(left, right, bottom, top, zNear, zFar) -> mat4x4\nCreates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustum", (PyCFunction)frustum_, METH_VARARGS, "frustum(left, right, bottom, top, near, far) -> mat4x4\nCreates a frustum matrix with default handedness, using right-handedness and -1 to +1 near and far clip planes definition." },
	{ "frustumLH_ZO", (PyCFunction)frustumLH_ZO_, METH_VARARGS, "frustumLH_ZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumLH_NO", (PyCFunction)frustumLH_NO_, METH_VARARGS, "frustumLH_NO(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumRH_ZO", (PyCFunction)frustumRH_ZO_, METH_VARARGS, "frustumRH_ZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumRH_NO", (PyCFunction)frustumRH_NO_, METH_VARARGS, "frustumRH_NO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumZO", (PyCFunction)frustumZO_, METH_VARARGS, "frustumZO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "frustumNO", (PyCFunction)frustumNO_, METH_VARARGS, "frustumNO(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumLH", (PyCFunction)frustumLH_, METH_VARARGS, "frustumLH(left, right, bottom, top, near, far) -> mat4x4\nCreates a left handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "frustumRH", (PyCFunction)frustumRH_, METH_VARARGS, "frustumRH(left, right, bottom, top, near, far) -> mat4x4\nCreates a right handed frustum matrix.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspective", (PyCFunction)perspective_, METH_VARARGS, "perspective(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum." },
	{ "perspectiveLH_ZO", (PyCFunction)perspectiveLH_ZO_, METH_VARARGS, "perspectiveLH_ZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveLH_NO", (PyCFunction)perspectiveLH_NO_, METH_VARARGS, "perspectiveLH_NO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveRH_ZO", (PyCFunction)perspectiveRH_ZO_, METH_VARARGS, "perspectiveRH_ZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveRH_NO", (PyCFunction)perspectiveRH_NO_, METH_VARARGS, "perspectiveRH_NO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveZO", (PyCFunction)perspectiveZO_, METH_VARARGS, "perspectiveZO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveNO", (PyCFunction)perspectiveNO_, METH_VARARGS, "perspectiveNO(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveLH", (PyCFunction)perspectiveLH_, METH_VARARGS, "perspectiveLH(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a left handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveRH", (PyCFunction)perspectiveRH_, METH_VARARGS, "perspectiveRH(fovy, aspect, near, far) -> mat4x4\nCreates a matrix for a right handed, symetric perspective-view frustum.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFov", (PyCFunction)perspectiveFov_, METH_VARARGS, "perspectiveFov(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates." },
	{ "perspectiveFovLH_ZO", (PyCFunction)perspectiveFovLH_ZO_, METH_VARARGS, "perspectiveFovLH_ZO(fov, width, height, near, far) -> mat4x4\n\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovLH_NO", (PyCFunction)perspectiveFovLH_NO_, METH_VARARGS, "perspectiveFovLH_NO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovRH_ZO", (PyCFunction)perspectiveFovRH_ZO_, METH_VARARGS, "perspectiveFovRH_ZO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovRH_NO", (PyCFunction)perspectiveFovRH_NO_, METH_VARARGS, "perspectiveFovRH_NO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovZO", (PyCFunction)perspectiveFovZO_, METH_VARARGS, "perspectiveFovZO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "perspectiveFovNO", (PyCFunction)perspectiveFovNO_, METH_VARARGS, "perspectiveFovNO(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovLH", (PyCFunction)perspectiveFovLH_, METH_VARARGS, "perspectiveFovLH(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using left-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "perspectiveFovRH", (PyCFunction)perspectiveFovRH_, METH_VARARGS, "perspectiveFovRH(fov, width, height, near, far) -> mat4x4\nBuilds a perspective projection matrix based on a field of view using right-handed coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "infinitePerspective", (PyCFunction)infinitePerspective_, METH_VARARGS, "infinitePerspective(fovy, aspect, near) -> mat4x4\nCreates a matrix for a right handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "infinitePerspectiveRH", (PyCFunction)infinitePerspectiveRH_, METH_VARARGS, "infinitePerspectiveRH(fovy, aspect, near) -> mat4x4\nCreates a matrix for a right handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "infinitePerspectiveLH", (PyCFunction)infinitePerspectiveLH_, METH_VARARGS, "infinitePerspectiveLH(fovy, aspect, near) -> mat4x4\nCreates a matrix for a left handed, symmetric perspective-view frustum with far plane at infinite." },
	{ "tweakedInfinitePerspective", (PyCFunction)tweakedInfinitePerspective_, METH_VARARGS, "tweakedInfinitePerspective(fovy, aspect, near[, ep]) -> mat4x4\nCreates a matrix for a symmetric perspective-view frustum with far plane at infinite for graphics hardware that doesn't support depth clamping." },
	{ "project", (PyCFunction)project_, METH_VARARGS, "project(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "projectNO", (PyCFunction)projectNO_, METH_VARARGS, "projectNO(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "projectZO", (PyCFunction)projectZO_, METH_VARARGS, "projectZO(obj, model, proj, viewport) -> vec3\nMap the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "unProject", (PyCFunction)unProject_, METH_VARARGS, "unProject(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "unProjectNO", (PyCFunction)unProjectNO_, METH_VARARGS, "unProjectNO(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.\n(OpenGL clip volume definition)" },
	{ "unProjectZO", (PyCFunction)unProjectZO_, METH_VARARGS, "unProjectZO(obj, model, proj, viewport) -> vec3\nMap the specified window coordinates (win.x, win.y, win.z) into object coordinates.\nThe near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively.\n(Direct3D clip volume definition)" },
	{ "pickMatrix", (PyCFunction)pickMatrix_, METH_VARARGS, "pickMatrix(center, delta, viewport) -> mat4x4\nDefine a picking region" },
	{ "lookAt", (PyCFunction)lookAt_, METH_VARARGS, "lookAt(eye, center, up) -> mat4x4\nBuild a right handed look at view matrix." },
	{ "lookAtRH", (PyCFunction)lookAtRH_, METH_VARARGS, "lookAtRH(eye, center, up) -> mat4x4\nBuild a right handed look at view matrix." },
	{ "lookAtLH", (PyCFunction)lookAtLH_, METH_VARARGS, "lookAtLH(eye, center, up) -> mat4x4\nBuild a left handed look at view matrix." },

	// quaternion
	{ "quatLookAt", (PyCFunction)quatLookAt_, METH_VARARGS, "quatLookAt(direction, up) -> quat\nBuild a look at quaternion based on the default handedness." },
	{ "quatLookAtLH", (PyCFunction)quatLookAtLH_, METH_VARARGS, "quatLookAtLH(direction, up) -> quat\nBuild a left-handed look at quaternion." },
	{ "quatLookAtRH", (PyCFunction)quatLookAtRH_, METH_VARARGS, "quatLookAtRH(direction, up) -> quat\nBuild a right-handed look at quaternion." },
	{ "lerp", (PyCFunction)lerp_, METH_VARARGS, "lerp(x, y, a) -> quat\nLinear interpolation of two quaternions.\nThe interpolation is oriented." },
	{ "slerp", (PyCFunction)slerp_, METH_VARARGS, "slerp(x, y, a) -> quat\nSpherical linear interpolation of two quaternions.\nThe interpolation always take the short path and the rotation is performed at constant speed." },
	{ "conjugate", (PyCFunction)conjugate_, METH_O, "conjugate(q) -> quat\nReturns the q conjugate." },
	{ "eulerAngles", (PyCFunction)eulerAngles_, METH_O, "eulerAngles(x) -> vec3\nReturns euler angles, pitch as x, yaw as y, roll as z." },
	{ "roll", (PyCFunction)roll_, METH_O, "roll(x) -> float\nReturns roll value of euler angles expressed in radians." },
	{ "pitch", (PyCFunction)pitch_, METH_O, "pitch(x) -> float\nReturns pitch value of euler angles expressed in radians." },
	{ "yaw", (PyCFunction)yaw_, METH_O, "yaw(x) -> float\nReturns yaw value of euler angles expressed in radians." },
	{ "mat3_cast", (PyCFunction)mat3_cast_, METH_O, "mat3_cast(x) -> mat3x3\nConverts a quaternion to a 3 * 3 matrix." },
	{ "mat4_cast", (PyCFunction)mat4_cast_, METH_O, "mat4_cast(x) -> mat4x4\nConverts a quaternion to a 4 * 4 matrix." },
	{ "quat_cast", (PyCFunction)quat_cast_, METH_O, "quat_cast(m) -> quat\nConverts a 3 * 3 or 4 * 4 matrix to a quaternion." },
	{ "angle", (PyCFunction)angle_, METH_O, "angle(x) -> float\nReturns the quaternion rotation angle." },
	{ "axis", (PyCFunction)axis_, METH_O, "axis(x) -> vec3\nReturns the quaternion rotation axis." },
	{ "angleAxis", (PyCFunction)angleAxis_, METH_VARARGS, "angleAxis(angle, v) -> quat\nBuild a quaternion from an angle and a normalized axis." },

	// matrix_access
	{ "row", (PyCFunction)row_, METH_VARARGS | METH_KEYWORDS, "row(m, index[, x]) -> vecn or matnxn\nGet a specific row of a matrix or set a specific row to a matrix." },
	{ "column", (PyCFunction)column_, METH_VARARGS | METH_KEYWORDS, "column(m, index[, x]) -> vecn or matnxn\nGet a specific column of a matrix or set a specific column to a matrix." },

	// noise
	{ "perlin", (PyCFunction)perlin_, METH_VARARGS, "perlin(p[, rep]) -> float\nClassic or periodic perlin noise." },
	{ "simplex", (PyCFunction)simplex_, METH_O, "simplex(p) -> float\nSimplex noise." },

	// random
	{ "linearRand", (PyCFunction)linearRand_, METH_VARARGS, "linearRand(Min, Max) -> float or vecn\nGenerate random numbers in the interval [Min, Max], according a linear distribution" },
	{ "gaussRand", (PyCFunction)gaussRand_, METH_VARARGS, "gaussRand(Mean, Deviation) -> float\nGenerate random numbers in the interval [Min, Max], according a gaussian distribution" },
	{ "circularRand", (PyCFunction)circularRand_, METH_O, "circularRand(Radius) -> vec2\nGenerate a random 2D vector which coordinates are regulary distributed on a circle of a given radius" },
	{ "sphericalRand", (PyCFunction)sphericalRand_, METH_O, "sphericalRand(Radius) -> vec3\nGenerate a random 3D vector which coordinates are regulary distributed on a sphere of a given radius" },
	{ "diskRand", (PyCFunction)diskRand_, METH_O, "diskRand(Radius) -> vec2\nGenerate a random 2D vector which coordinates are regulary distributed within the area of a disk of a given radius" },
	{ "ballRand", (PyCFunction)ballRand_, METH_O, "ballRand(Radius) -> vec3\nGenerate a random 3D vector which coordinates are regulary distributed within the area of a ball of a given radius" },

	// reciprocal
	{ "sec", (PyCFunction)sec_, METH_O, "sec(x) -> float or vecn\nSecant function.\nhypotenuse / adjacent or 1 / cos(x)" },
	{ "csc", (PyCFunction)csc_, METH_O, "csc(x) -> float or vecn\nCosecant function.\nhypotenuse / opposite or 1 / sin(x)" },
	{ "cot", (PyCFunction)cot_, METH_O, "cot(x) -> float or vecn\nCotangent function.\nadjacent / opposite or 1 / tan(x)" },
	{ "asec", (PyCFunction)asec_, METH_O, "asec(x) -> float or vecn\nInverse secant function." },
	{ "acsc", (PyCFunction)acsc_, METH_O, "acsc(x) -> float or vecn\nInverse cosecant function." },
	{ "acot", (PyCFunction)acot_, METH_O, "acot(x) -> float or vecn\nInverse cotangent function." },
	{ "sech", (PyCFunction)sech_, METH_O, "sech(x) -> float or vecn\nSecant hyperbolic function." },
	{ "csch", (PyCFunction)csch_, METH_O, "csch(x) -> float or vecn\nCosecant hyperbolic function." },
	{ "coth", (PyCFunction)coth_, METH_O, "coth(x) -> float or vecn\nCotangent hyperbolic function." },
	{ "asech", (PyCFunction)asech_, METH_O, "asech(x) -> float or vecn\nInverse secant hyperbolic function." },
	{ "acsch", (PyCFunction)acsch_, METH_O, "acsch(x) -> float or vecn\nInverse cosecant hyperbolic function." },
	{ "acoth", (PyCFunction)acoth_, METH_O, "acoth(x) -> float or vecn\nInverse cotangent hyperbolic function." },

	// type_ptr
	{ "value_ptr", (PyCFunction)value_ptr_, METH_O, "value_ptr(x) -> void* as int\nReturn the constant address to the data of the input parameter." },
	{ "sizeof", (PyCFunction)sizeof_, METH_O, "sizeof(x) -> int\nReturn the size of x in bytes." },
	{ "make_vec2", (PyCFunction)make_vec2_, METH_O, "make_vec2(ptr) -> vec2\nBuild a vector from a pointer." },
	{ "make_vec3", (PyCFunction)make_vec3_, METH_O, "make_vec3(ptr) -> vec3\nBuild a vector from a pointer." },
	{ "make_vec4", (PyCFunction)make_vec4_, METH_O, "make_vec4(ptr) -> vec4\nBuild a vector from a pointer." },
	{ "make_mat2", (PyCFunction)make_mat2x2_, METH_O, "make_mat2(ptr) -> mat2x2\nBuild a matrix from a pointer." },
	{ "make_mat2x2", (PyCFunction)make_mat2x2_, METH_O, "make_mat2x2(ptr) -> mat2x2\nBuild a matrix from a pointer." },
	{ "make_mat2x3", (PyCFunction)make_mat2x3_, METH_O, "make_mat2x3(ptr) -> mat2x3\nBuild a matrix from a pointer." },
	{ "make_mat2x4", (PyCFunction)make_mat2x4_, METH_O, "make_mat2x4(ptr) -> mat2x4\nBuild a matrix from a pointer." },
	{ "make_mat3x2", (PyCFunction)make_mat3x2_, METH_O, "make_mat3x2(ptr) -> mat3x2\nBuild a matrix from a pointer." },
	{ "make_mat3", (PyCFunction)make_mat3x3_, METH_O, "make_mat3(ptr) -> mat3x3\nBuild a matrix from a pointer." },
	{ "make_mat3x3", (PyCFunction)make_mat3x3_, METH_O, "make_mat3x3(ptr) -> mat3x3\nBuild a matrix from a pointer." },
	{ "make_mat3x4", (PyCFunction)make_mat3x4_, METH_O, "make_mat3x4(ptr) -> mat3x4\nBuild a matrix from a pointer." },
	{ "make_mat4x2", (PyCFunction)make_mat4x2_, METH_O, "make_mat4x2(ptr) -> mat4x2\nBuild a matrix from a pointer." },
	{ "make_mat4x3", (PyCFunction)make_mat4x3_, METH_O, "make_mat4x3(ptr) -> mat4x3\nBuild a matrix from a pointer." },
	{ "make_mat4", (PyCFunction)make_mat4x4_, METH_O, "make_mat4(ptr) -> mat4x4\nBuild a matrix from a pointer." },
	{ "make_mat4x4", (PyCFunction)make_mat4x4_, METH_O, "make_mat4x4(ptr) -> mat4x4\nBuild a matrix from a pointer." },
	{ "make_quat", (PyCFunction)make_quat_, METH_O, "make_quat(ptr) -> quat\nBuild a quaternion from a pointer." },

	// PyGLM functions
	{ "silence", (PyCFunction)silence, METH_O, "silence(ID) -> None\nSilence a PyGLM warning (or all using 0)." },
#ifdef HAS_TEST
	{"test", (PyCFunction)test, TEST_FUNC_TYPE, ""},
#endif
	{ NULL, NULL, 0, NULL }
};

#endif

static PyModuleDef glmmodule = {
	PyModuleDef_HEAD_INIT,
	"glm",
	"Features that implement the GLSL specification as close as possible.",
	-1,
#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
	glmmethods, 
#else
	NULL,
#endif
	NULL, NULL, NULL, NULL
};

extern "C" {
	PyMODINIT_FUNC
		PyInit_glm(void)
	{
#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
		PyObject* mainmod = PyImport_AddModule("__main__");
		PyObject* maindict = PyModule_GetDict(mainmod);
		PyObject* ctypes_list = Py_BuildValue("(s, s, s, s, s, s, s, s, s, s, s, s, s, s)", "cast", "c_void_p", "POINTER", "c_float", "c_double", "c_int64", "c_int32", "c_int16", "c_int8", "c_uint64", "c_uint32", "c_uint16", "c_uint8", "c_bool");

		PyObject* ctypes_module = PyImport_ImportModuleEx("ctypes", maindict, maindict, ctypes_list);
		Py_DECREF(ctypes_list);

		ctypes_cast = PyObject_GetAttrString(ctypes_module, "cast");

		ctypes_void_p = PyObject_GetAttrString(ctypes_module, "c_void_p");

		PyObject* ctypes_POINTER = PyObject_GetAttrString(ctypes_module, "POINTER");

		PyObject* ctypes_float = PyObject_GetAttrString(ctypes_module, "c_float");
		ctypes_float_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_float, NULL);
		Py_DECREF(ctypes_float);

		PyObject* ctypes_double = PyObject_GetAttrString(ctypes_module, "c_double");
		ctypes_double_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_double, NULL);
		Py_DECREF(ctypes_double);

		PyObject* ctypes_int64 = PyObject_GetAttrString(ctypes_module, "c_int64");
		ctypes_int64_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int64, NULL);
		Py_DECREF(ctypes_int64);

		PyObject* ctypes_int32 = PyObject_GetAttrString(ctypes_module, "c_int32");
		ctypes_int32_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int32, NULL);
		Py_DECREF(ctypes_int32);

		PyObject* ctypes_int16 = PyObject_GetAttrString(ctypes_module, "c_int16");
		ctypes_int16_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int16, NULL);
		Py_DECREF(ctypes_int16);

		PyObject* ctypes_int8 = PyObject_GetAttrString(ctypes_module, "c_int8");
		ctypes_int8_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_int8, NULL);
		Py_DECREF(ctypes_int8);

		PyObject* ctypes_uint64 = PyObject_GetAttrString(ctypes_module, "c_uint64");
		ctypes_uint64_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint64, NULL);
		Py_DECREF(ctypes_uint64);

		PyObject* ctypes_uint32 = PyObject_GetAttrString(ctypes_module, "c_uint32");
		ctypes_uint32_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint32, NULL);
		Py_DECREF(ctypes_uint32);

		PyObject* ctypes_uint16 = PyObject_GetAttrString(ctypes_module, "c_uint16");
		ctypes_uint16_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint16, NULL);
		Py_DECREF(ctypes_uint16);

		PyObject* ctypes_uint8 = PyObject_GetAttrString(ctypes_module, "c_uint8");
		ctypes_uint8_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_uint8, NULL);
		Py_DECREF(ctypes_uint8);

		PyObject* ctypes_bool = PyObject_GetAttrString(ctypes_module, "c_bool");
		ctypes_bool_p = PyObject_CallFunctionObjArgs(ctypes_POINTER, ctypes_bool, NULL);
		Py_DECREF(ctypes_bool);

		Py_DECREF(ctypes_POINTER);
		Py_DECREF(ctypes_module);
		
#endif

		PyObject* module_glm;

		if (PyType_Ready(&hfvec1Type) < 0 || PyType_Ready(&hfvec1IterType) < 0
			|| PyType_Ready(&hfvec2Type) < 0 || PyType_Ready(&hfvec2IterType) < 0
			|| PyType_Ready(&hfvec3Type) < 0 || PyType_Ready(&hfvec3IterType) < 0
			|| PyType_Ready(&hfvec4Type) < 0 || PyType_Ready(&hfvec4IterType) < 0
			|| PyType_Ready(&hdvec1Type) < 0 || PyType_Ready(&hdvec1IterType) < 0
			|| PyType_Ready(&hdvec2Type) < 0 || PyType_Ready(&hdvec2IterType) < 0
			|| PyType_Ready(&hdvec3Type) < 0 || PyType_Ready(&hdvec3IterType) < 0
			|| PyType_Ready(&hdvec4Type) < 0 || PyType_Ready(&hdvec4IterType) < 0
			|| PyType_Ready(&hi8vec1Type) < 0 || PyType_Ready(&hi8vec1IterType) < 0
			|| PyType_Ready(&hi8vec2Type) < 0 || PyType_Ready(&hi8vec2IterType) < 0
			|| PyType_Ready(&hi8vec3Type) < 0 || PyType_Ready(&hi8vec3IterType) < 0
			|| PyType_Ready(&hi8vec4Type) < 0 || PyType_Ready(&hi8vec4IterType) < 0
			|| PyType_Ready(&hi16vec1Type) < 0 || PyType_Ready(&hi16vec1IterType) < 0
			|| PyType_Ready(&hi16vec2Type) < 0 || PyType_Ready(&hi16vec2IterType) < 0
			|| PyType_Ready(&hi16vec3Type) < 0 || PyType_Ready(&hi16vec3IterType) < 0
			|| PyType_Ready(&hi16vec4Type) < 0 || PyType_Ready(&hi16vec4IterType) < 0
			|| PyType_Ready(&hivec1Type) < 0 || PyType_Ready(&hivec1IterType) < 0
			|| PyType_Ready(&hivec2Type) < 0 || PyType_Ready(&hivec2IterType) < 0
			|| PyType_Ready(&hivec3Type) < 0 || PyType_Ready(&hivec3IterType) < 0
			|| PyType_Ready(&hivec4Type) < 0 || PyType_Ready(&hivec4IterType) < 0
			|| PyType_Ready(&hi64vec1Type) < 0 || PyType_Ready(&hi64vec1IterType) < 0
			|| PyType_Ready(&hi64vec2Type) < 0 || PyType_Ready(&hi64vec2IterType) < 0
			|| PyType_Ready(&hi64vec3Type) < 0 || PyType_Ready(&hi64vec3IterType) < 0
			|| PyType_Ready(&hi64vec4Type) < 0 || PyType_Ready(&hi64vec4IterType) < 0
			|| PyType_Ready(&hu8vec1Type) < 0 || PyType_Ready(&hu8vec1IterType) < 0
			|| PyType_Ready(&hu8vec2Type) < 0 || PyType_Ready(&hu8vec2IterType) < 0
			|| PyType_Ready(&hu8vec3Type) < 0 || PyType_Ready(&hu8vec3IterType) < 0
			|| PyType_Ready(&hu8vec4Type) < 0 || PyType_Ready(&hu8vec4IterType) < 0
			|| PyType_Ready(&hu16vec1Type) < 0 || PyType_Ready(&hu16vec1IterType) < 0
			|| PyType_Ready(&hu16vec2Type) < 0 || PyType_Ready(&hu16vec2IterType) < 0
			|| PyType_Ready(&hu16vec3Type) < 0 || PyType_Ready(&hu16vec3IterType) < 0
			|| PyType_Ready(&hu16vec4Type) < 0 || PyType_Ready(&hu16vec4IterType) < 0
			|| PyType_Ready(&huvec1Type) < 0 || PyType_Ready(&huvec1IterType) < 0
			|| PyType_Ready(&huvec2Type) < 0 || PyType_Ready(&huvec2IterType) < 0
			|| PyType_Ready(&huvec3Type) < 0 || PyType_Ready(&huvec3IterType) < 0
			|| PyType_Ready(&huvec4Type) < 0 || PyType_Ready(&huvec4IterType) < 0
			|| PyType_Ready(&hu64vec1Type) < 0 || PyType_Ready(&hu64vec1IterType) < 0
			|| PyType_Ready(&hu64vec2Type) < 0 || PyType_Ready(&hu64vec2IterType) < 0
			|| PyType_Ready(&hu64vec3Type) < 0 || PyType_Ready(&hu64vec3IterType) < 0
			|| PyType_Ready(&hu64vec4Type) < 0 || PyType_Ready(&hu64vec4IterType) < 0
			|| PyType_Ready(&hbvec1Type) < 0 || PyType_Ready(&hbvec1IterType) < 0
			|| PyType_Ready(&hbvec2Type) < 0 || PyType_Ready(&hbvec2IterType) < 0
			|| PyType_Ready(&hbvec3Type) < 0 || PyType_Ready(&hbvec3IterType) < 0
			|| PyType_Ready(&hbvec4Type) < 0 || PyType_Ready(&hbvec4IterType) < 0
			|| PyType_Ready(&hfmvec2Type) < 0 || PyType_Ready(&hfmvec2IterType) < 0
			|| PyType_Ready(&hfmvec3Type) < 0 || PyType_Ready(&hfmvec3IterType) < 0
			|| PyType_Ready(&hfmvec4Type) < 0 || PyType_Ready(&hfmvec4IterType) < 0
			|| PyType_Ready(&hdmvec2Type) < 0 || PyType_Ready(&hdmvec2IterType) < 0
			|| PyType_Ready(&hdmvec3Type) < 0 || PyType_Ready(&hdmvec3IterType) < 0
			|| PyType_Ready(&hdmvec4Type) < 0 || PyType_Ready(&hdmvec4IterType) < 0
			|| PyType_Ready(&himvec2Type) < 0 || PyType_Ready(&himvec2IterType) < 0
			|| PyType_Ready(&himvec3Type) < 0 || PyType_Ready(&himvec3IterType) < 0
			|| PyType_Ready(&himvec4Type) < 0 || PyType_Ready(&himvec4IterType) < 0
			|| PyType_Ready(&humvec2Type) < 0 || PyType_Ready(&humvec2IterType) < 0
			|| PyType_Ready(&humvec3Type) < 0 || PyType_Ready(&humvec3IterType) < 0
			|| PyType_Ready(&humvec4Type) < 0 || PyType_Ready(&humvec4IterType) < 0
			|| PyType_Ready(&hfmat2x2Type) < 0 || PyType_Ready(&hfmat2x2IterType) < 0
			|| PyType_Ready(&hfmat2x3Type) < 0 || PyType_Ready(&hfmat2x3IterType) < 0
			|| PyType_Ready(&hfmat2x4Type) < 0 || PyType_Ready(&hfmat2x4IterType) < 0
			|| PyType_Ready(&hfmat3x2Type) < 0 || PyType_Ready(&hfmat3x2IterType) < 0
			|| PyType_Ready(&hfmat3x3Type) < 0 || PyType_Ready(&hfmat3x3IterType) < 0
			|| PyType_Ready(&hfmat3x4Type) < 0 || PyType_Ready(&hfmat3x4IterType) < 0
			|| PyType_Ready(&hfmat4x2Type) < 0 || PyType_Ready(&hfmat4x2IterType) < 0
			|| PyType_Ready(&hfmat4x3Type) < 0 || PyType_Ready(&hfmat4x3IterType) < 0
			|| PyType_Ready(&hfmat4x4Type) < 0 || PyType_Ready(&hfmat4x4IterType) < 0
			|| PyType_Ready(&hdmat2x2Type) < 0 || PyType_Ready(&hdmat2x2IterType) < 0
			|| PyType_Ready(&hdmat2x3Type) < 0 || PyType_Ready(&hdmat2x3IterType) < 0
			|| PyType_Ready(&hdmat2x4Type) < 0 || PyType_Ready(&hdmat2x4IterType) < 0
			|| PyType_Ready(&hdmat3x2Type) < 0 || PyType_Ready(&hdmat3x2IterType) < 0
			|| PyType_Ready(&hdmat3x3Type) < 0 || PyType_Ready(&hdmat3x3IterType) < 0
			|| PyType_Ready(&hdmat3x4Type) < 0 || PyType_Ready(&hdmat3x4IterType) < 0
			|| PyType_Ready(&hdmat4x2Type) < 0 || PyType_Ready(&hdmat4x2IterType) < 0
			|| PyType_Ready(&hdmat4x3Type) < 0 || PyType_Ready(&hdmat4x3IterType) < 0
			|| PyType_Ready(&hdmat4x4Type) < 0 || PyType_Ready(&hdmat4x4IterType) < 0
			|| PyType_Ready(&himat2x2Type) < 0 || PyType_Ready(&himat2x2IterType) < 0
			|| PyType_Ready(&himat2x3Type) < 0 || PyType_Ready(&himat2x3IterType) < 0
			|| PyType_Ready(&himat2x4Type) < 0 || PyType_Ready(&himat2x4IterType) < 0
			|| PyType_Ready(&himat3x2Type) < 0 || PyType_Ready(&himat3x2IterType) < 0
			|| PyType_Ready(&himat3x3Type) < 0 || PyType_Ready(&himat3x3IterType) < 0
			|| PyType_Ready(&himat3x4Type) < 0 || PyType_Ready(&himat3x4IterType) < 0
			|| PyType_Ready(&himat4x2Type) < 0 || PyType_Ready(&himat4x2IterType) < 0
			|| PyType_Ready(&himat4x3Type) < 0 || PyType_Ready(&himat4x3IterType) < 0
			|| PyType_Ready(&himat4x4Type) < 0 || PyType_Ready(&himat4x4IterType) < 0
			|| PyType_Ready(&humat2x2Type) < 0 || PyType_Ready(&humat2x2IterType) < 0
			|| PyType_Ready(&humat2x3Type) < 0 || PyType_Ready(&humat2x3IterType) < 0
			|| PyType_Ready(&humat2x4Type) < 0 || PyType_Ready(&humat2x4IterType) < 0
			|| PyType_Ready(&humat3x2Type) < 0 || PyType_Ready(&humat3x2IterType) < 0
			|| PyType_Ready(&humat3x3Type) < 0 || PyType_Ready(&humat3x3IterType) < 0
			|| PyType_Ready(&humat3x4Type) < 0 || PyType_Ready(&humat3x4IterType) < 0
			|| PyType_Ready(&humat4x2Type) < 0 || PyType_Ready(&humat4x2IterType) < 0
			|| PyType_Ready(&humat4x3Type) < 0 || PyType_Ready(&humat4x3IterType) < 0
			|| PyType_Ready(&humat4x4Type) < 0 || PyType_Ready(&humat4x4IterType) < 0
			|| PyType_Ready(&hfquaType) < 0 || PyType_Ready(&hfquaIterType) < 0
			|| PyType_Ready(&hdquaType) < 0 || PyType_Ready(&hdquaIterType) < 0)
			return NULL;

		module_glm = PyModule_Create(&glmmodule);
		if (module_glm == NULL)
			return NULL;


#if !(PyGLM_BUILD & PyGLM_NO_FUNCTIONS)
		// backwards compatibility
		Py_INCREF(module_glm);
		PyModule_AddObject(module_glm, "detail", module_glm);

		Py_INCREF(module_glm);
		PyModule_AddObject(module_glm, "gtc", module_glm);
#endif

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "vec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "vec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "vec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "vec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "mat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "mat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "mat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "mat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "mat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "mat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "mat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "mat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "mat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "mat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "mat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "mat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "quat", (PyObject *)&hfquaType);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "fquat", (PyObject *)&hfquaType);

		Py_INCREF(&hdquaType);
		PyModule_AddObject(module_glm, "dquat", (PyObject *)&hdquaType);

		Py_INCREF(&hfquaType);
		PyModule_AddObject(module_glm, "f32quat", (PyObject *)&hfquaType);

		Py_INCREF(&hdquaType);
		PyModule_AddObject(module_glm, "f64quat", (PyObject *)&hdquaType);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "fmat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "fmat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "fmat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "fmat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "fmat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "fmat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "fmat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "fmat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "fmat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "fmat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "fmat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "fmat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "dmat2x2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat2x3Type);
		PyModule_AddObject(module_glm, "dmat2x3", (PyObject *)&hdmat2x3Type);
		Py_INCREF(&hdmat2x4Type);
		PyModule_AddObject(module_glm, "dmat2x4", (PyObject *)&hdmat2x4Type);
		Py_INCREF(&hdmat3x2Type);
		PyModule_AddObject(module_glm, "dmat3x2", (PyObject *)&hdmat3x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "dmat3x3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat3x4Type);
		PyModule_AddObject(module_glm, "dmat3x4", (PyObject *)&hdmat3x4Type);
		Py_INCREF(&hdmat4x2Type);
		PyModule_AddObject(module_glm, "dmat4x2", (PyObject *)&hdmat4x2Type);
		Py_INCREF(&hdmat4x3Type);
		PyModule_AddObject(module_glm, "dmat4x3", (PyObject *)&hdmat4x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "dmat4x4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "dmat2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "dmat3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "dmat4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "imat2x2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat2x3Type);
		PyModule_AddObject(module_glm, "imat2x3", (PyObject *)&himat2x3Type);
		Py_INCREF(&himat2x4Type);
		PyModule_AddObject(module_glm, "imat2x4", (PyObject *)&himat2x4Type);
		Py_INCREF(&himat3x2Type);
		PyModule_AddObject(module_glm, "imat3x2", (PyObject *)&himat3x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "imat3x3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat3x4Type);
		PyModule_AddObject(module_glm, "imat3x4", (PyObject *)&himat3x4Type);
		Py_INCREF(&himat4x2Type);
		PyModule_AddObject(module_glm, "imat4x2", (PyObject *)&himat4x2Type);
		Py_INCREF(&himat4x3Type);
		PyModule_AddObject(module_glm, "imat4x3", (PyObject *)&himat4x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "imat4x4", (PyObject *)&himat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "imat2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "imat3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "imat4", (PyObject *)&himat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "umat2x2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat2x3Type);
		PyModule_AddObject(module_glm, "umat2x3", (PyObject *)&humat2x3Type);
		Py_INCREF(&humat2x4Type);
		PyModule_AddObject(module_glm, "umat2x4", (PyObject *)&humat2x4Type);
		Py_INCREF(&humat3x2Type);
		PyModule_AddObject(module_glm, "umat3x2", (PyObject *)&humat3x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "umat3x3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat3x4Type);
		PyModule_AddObject(module_glm, "umat3x4", (PyObject *)&humat3x4Type);
		Py_INCREF(&humat4x2Type);
		PyModule_AddObject(module_glm, "umat4x2", (PyObject *)&humat4x2Type);
		Py_INCREF(&humat4x3Type);
		PyModule_AddObject(module_glm, "umat4x3", (PyObject *)&humat4x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "umat4x4", (PyObject *)&humat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "umat2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "umat3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "umat4", (PyObject *)&humat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "f32mat2x2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat2x3Type);
		PyModule_AddObject(module_glm, "f32mat2x3", (PyObject *)&hfmat2x3Type);
		Py_INCREF(&hfmat2x4Type);
		PyModule_AddObject(module_glm, "f32mat2x4", (PyObject *)&hfmat2x4Type);
		Py_INCREF(&hfmat3x2Type);
		PyModule_AddObject(module_glm, "f32mat3x2", (PyObject *)&hfmat3x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "f32mat3x3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat3x4Type);
		PyModule_AddObject(module_glm, "f32mat3x4", (PyObject *)&hfmat3x4Type);
		Py_INCREF(&hfmat4x2Type);
		PyModule_AddObject(module_glm, "f32mat4x2", (PyObject *)&hfmat4x2Type);
		Py_INCREF(&hfmat4x3Type);
		PyModule_AddObject(module_glm, "f32mat4x3", (PyObject *)&hfmat4x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "f32mat4x4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hfmat2x2Type);
		PyModule_AddObject(module_glm, "f32mat2", (PyObject *)&hfmat2x2Type);
		Py_INCREF(&hfmat3x3Type);
		PyModule_AddObject(module_glm, "f32mat3", (PyObject *)&hfmat3x3Type);
		Py_INCREF(&hfmat4x4Type);
		PyModule_AddObject(module_glm, "f32mat4", (PyObject *)&hfmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "f64mat2x2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat2x3Type);
		PyModule_AddObject(module_glm, "f64mat2x3", (PyObject *)&hdmat2x3Type);
		Py_INCREF(&hdmat2x4Type);
		PyModule_AddObject(module_glm, "f64mat2x4", (PyObject *)&hdmat2x4Type);
		Py_INCREF(&hdmat3x2Type);
		PyModule_AddObject(module_glm, "f64mat3x2", (PyObject *)&hdmat3x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "f64mat3x3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat3x4Type);
		PyModule_AddObject(module_glm, "f64mat3x4", (PyObject *)&hdmat3x4Type);
		Py_INCREF(&hdmat4x2Type);
		PyModule_AddObject(module_glm, "f64mat4x2", (PyObject *)&hdmat4x2Type);
		Py_INCREF(&hdmat4x3Type);
		PyModule_AddObject(module_glm, "f64mat4x3", (PyObject *)&hdmat4x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "f64mat4x4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&hdmat2x2Type);
		PyModule_AddObject(module_glm, "f64mat2", (PyObject *)&hdmat2x2Type);
		Py_INCREF(&hdmat3x3Type);
		PyModule_AddObject(module_glm, "f64mat3", (PyObject *)&hdmat3x3Type);
		Py_INCREF(&hdmat4x4Type);
		PyModule_AddObject(module_glm, "f64mat4", (PyObject *)&hdmat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "i32mat2x2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat2x3Type);
		PyModule_AddObject(module_glm, "i32mat2x3", (PyObject *)&himat2x3Type);
		Py_INCREF(&himat2x4Type);
		PyModule_AddObject(module_glm, "i32mat2x4", (PyObject *)&himat2x4Type);
		Py_INCREF(&himat3x2Type);
		PyModule_AddObject(module_glm, "i32mat3x2", (PyObject *)&himat3x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "i32mat3x3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat3x4Type);
		PyModule_AddObject(module_glm, "i32mat3x4", (PyObject *)&himat3x4Type);
		Py_INCREF(&himat4x2Type);
		PyModule_AddObject(module_glm, "i32mat4x2", (PyObject *)&himat4x2Type);
		Py_INCREF(&himat4x3Type);
		PyModule_AddObject(module_glm, "i32mat4x3", (PyObject *)&himat4x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "i32mat4x4", (PyObject *)&himat4x4Type);

		Py_INCREF(&himat2x2Type);
		PyModule_AddObject(module_glm, "i32mat2", (PyObject *)&himat2x2Type);
		Py_INCREF(&himat3x3Type);
		PyModule_AddObject(module_glm, "i32mat3", (PyObject *)&himat3x3Type);
		Py_INCREF(&himat4x4Type);
		PyModule_AddObject(module_glm, "i32mat4", (PyObject *)&himat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "u32mat2x2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat2x3Type);
		PyModule_AddObject(module_glm, "u32mat2x3", (PyObject *)&humat2x3Type);
		Py_INCREF(&humat2x4Type);
		PyModule_AddObject(module_glm, "u32mat2x4", (PyObject *)&humat2x4Type);
		Py_INCREF(&humat3x2Type);
		PyModule_AddObject(module_glm, "u32mat3x2", (PyObject *)&humat3x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "u32mat3x3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat3x4Type);
		PyModule_AddObject(module_glm, "u32mat3x4", (PyObject *)&humat3x4Type);
		Py_INCREF(&humat4x2Type);
		PyModule_AddObject(module_glm, "u32mat4x2", (PyObject *)&humat4x2Type);
		Py_INCREF(&humat4x3Type);
		PyModule_AddObject(module_glm, "u32mat4x3", (PyObject *)&humat4x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "u32mat4x4", (PyObject *)&humat4x4Type);

		Py_INCREF(&humat2x2Type);
		PyModule_AddObject(module_glm, "u32mat2", (PyObject *)&humat2x2Type);
		Py_INCREF(&humat3x3Type);
		PyModule_AddObject(module_glm, "u32mat3", (PyObject *)&humat3x3Type);
		Py_INCREF(&humat4x4Type);
		PyModule_AddObject(module_glm, "u32mat4", (PyObject *)&humat4x4Type);

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "fvec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "fvec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "fvec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "fvec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hdvec1Type);
		PyModule_AddObject(module_glm, "dvec1", (PyObject *)&hdvec1Type);
		Py_INCREF(&hdvec2Type);
		PyModule_AddObject(module_glm, "dvec2", (PyObject *)&hdvec2Type);
		Py_INCREF(&hdvec3Type);
		PyModule_AddObject(module_glm, "dvec3", (PyObject *)&hdvec3Type);
		Py_INCREF(&hdvec4Type);
		PyModule_AddObject(module_glm, "dvec4", (PyObject *)&hdvec4Type);

		Py_INCREF(&hfvec1Type);
		PyModule_AddObject(module_glm, "f32vec1", (PyObject *)&hfvec1Type);
		Py_INCREF(&hfvec2Type);
		PyModule_AddObject(module_glm, "f32vec2", (PyObject *)&hfvec2Type);
		Py_INCREF(&hfvec3Type);
		PyModule_AddObject(module_glm, "f32vec3", (PyObject *)&hfvec3Type);
		Py_INCREF(&hfvec4Type);
		PyModule_AddObject(module_glm, "f32vec4", (PyObject *)&hfvec4Type);

		Py_INCREF(&hdvec1Type);
		PyModule_AddObject(module_glm, "f64vec1", (PyObject *)&hdvec1Type);
		Py_INCREF(&hdvec2Type);
		PyModule_AddObject(module_glm, "f64vec2", (PyObject *)&hdvec2Type);
		Py_INCREF(&hdvec3Type);
		PyModule_AddObject(module_glm, "f64vec3", (PyObject *)&hdvec3Type);
		Py_INCREF(&hdvec4Type);
		PyModule_AddObject(module_glm, "f64vec4", (PyObject *)&hdvec4Type);

		Py_INCREF(&hi8vec1Type);
		PyModule_AddObject(module_glm, "i8vec1", (PyObject *)&hi8vec1Type);
		Py_INCREF(&hi8vec2Type);
		PyModule_AddObject(module_glm, "i8vec2", (PyObject *)&hi8vec2Type);
		Py_INCREF(&hi8vec3Type);
		PyModule_AddObject(module_glm, "i8vec3", (PyObject *)&hi8vec3Type);
		Py_INCREF(&hi8vec4Type);
		PyModule_AddObject(module_glm, "i8vec4", (PyObject *)&hi8vec4Type);

		Py_INCREF(&hi16vec1Type);
		PyModule_AddObject(module_glm, "i16vec1", (PyObject *)&hi16vec1Type);
		Py_INCREF(&hi16vec2Type);
		PyModule_AddObject(module_glm, "i16vec2", (PyObject *)&hi16vec2Type);
		Py_INCREF(&hi16vec3Type);
		PyModule_AddObject(module_glm, "i16vec3", (PyObject *)&hi16vec3Type);
		Py_INCREF(&hi16vec4Type);
		PyModule_AddObject(module_glm, "i16vec4", (PyObject *)&hi16vec4Type);

		Py_INCREF(&hivec1Type);
		PyModule_AddObject(module_glm, "i32vec1", (PyObject *)&hivec1Type);
		Py_INCREF(&hivec2Type);
		PyModule_AddObject(module_glm, "i32vec2", (PyObject *)&hivec2Type);
		Py_INCREF(&hivec3Type);
		PyModule_AddObject(module_glm, "i32vec3", (PyObject *)&hivec3Type);
		Py_INCREF(&hivec4Type);
		PyModule_AddObject(module_glm, "i32vec4", (PyObject *)&hivec4Type);

		Py_INCREF(&hivec1Type);
		PyModule_AddObject(module_glm, "ivec1", (PyObject *)&hivec1Type);
		Py_INCREF(&hivec2Type);
		PyModule_AddObject(module_glm, "ivec2", (PyObject *)&hivec2Type);
		Py_INCREF(&hivec3Type);
		PyModule_AddObject(module_glm, "ivec3", (PyObject *)&hivec3Type);
		Py_INCREF(&hivec4Type);
		PyModule_AddObject(module_glm, "ivec4", (PyObject *)&hivec4Type);

		Py_INCREF(&hi64vec1Type);
		PyModule_AddObject(module_glm, "i64vec1", (PyObject *)&hi64vec1Type);
		Py_INCREF(&hi64vec2Type);
		PyModule_AddObject(module_glm, "i64vec2", (PyObject *)&hi64vec2Type);
		Py_INCREF(&hi64vec3Type);
		PyModule_AddObject(module_glm, "i64vec3", (PyObject *)&hi64vec3Type);
		Py_INCREF(&hi64vec4Type);
		PyModule_AddObject(module_glm, "i64vec4", (PyObject *)&hi64vec4Type);

		Py_INCREF(&hu8vec1Type);
		PyModule_AddObject(module_glm, "u8vec1", (PyObject *)&hu8vec1Type);
		Py_INCREF(&hu8vec2Type);
		PyModule_AddObject(module_glm, "u8vec2", (PyObject *)&hu8vec2Type);
		Py_INCREF(&hu8vec3Type);
		PyModule_AddObject(module_glm, "u8vec3", (PyObject *)&hu8vec3Type);
		Py_INCREF(&hu8vec4Type);
		PyModule_AddObject(module_glm, "u8vec4", (PyObject *)&hu8vec4Type);

		Py_INCREF(&hu16vec1Type);
		PyModule_AddObject(module_glm, "u16vec1", (PyObject *)&hu16vec1Type);
		Py_INCREF(&hu16vec2Type);
		PyModule_AddObject(module_glm, "u16vec2", (PyObject *)&hu16vec2Type);
		Py_INCREF(&hu16vec3Type);
		PyModule_AddObject(module_glm, "u16vec3", (PyObject *)&hu16vec3Type);
		Py_INCREF(&hu16vec4Type);
		PyModule_AddObject(module_glm, "u16vec4", (PyObject *)&hu16vec4Type);

		Py_INCREF(&huvec1Type);
		PyModule_AddObject(module_glm, "u32vec1", (PyObject *)&huvec1Type);
		Py_INCREF(&huvec2Type);
		PyModule_AddObject(module_glm, "u32vec2", (PyObject *)&huvec2Type);
		Py_INCREF(&huvec3Type);
		PyModule_AddObject(module_glm, "u32vec3", (PyObject *)&huvec3Type);
		Py_INCREF(&huvec4Type);
		PyModule_AddObject(module_glm, "u32vec4", (PyObject *)&huvec4Type);

		Py_INCREF(&huvec1Type);
		PyModule_AddObject(module_glm, "uvec1", (PyObject *)&huvec1Type);
		Py_INCREF(&huvec2Type);
		PyModule_AddObject(module_glm, "uvec2", (PyObject *)&huvec2Type);
		Py_INCREF(&huvec3Type);
		PyModule_AddObject(module_glm, "uvec3", (PyObject *)&huvec3Type);
		Py_INCREF(&huvec4Type);
		PyModule_AddObject(module_glm, "uvec4", (PyObject *)&huvec4Type);
		
		Py_INCREF(&hu64vec1Type);
		PyModule_AddObject(module_glm, "u64vec1", (PyObject *)&hu64vec1Type);
		Py_INCREF(&hu64vec2Type);
		PyModule_AddObject(module_glm, "u64vec2", (PyObject *)&hu64vec2Type);
		Py_INCREF(&hu64vec3Type);
		PyModule_AddObject(module_glm, "u64vec3", (PyObject *)&hu64vec3Type);
		Py_INCREF(&hu64vec4Type);
		PyModule_AddObject(module_glm, "u64vec4", (PyObject *)&hu64vec4Type);

		Py_INCREF(&hbvec1Type);
		PyModule_AddObject(module_glm, "bvec1", (PyObject *)&hbvec1Type);
		Py_INCREF(&hbvec2Type);
		PyModule_AddObject(module_glm, "bvec2", (PyObject *)&hbvec2Type);
		Py_INCREF(&hbvec3Type);
		PyModule_AddObject(module_glm, "bvec3", (PyObject *)&hbvec3Type);
		Py_INCREF(&hbvec4Type);
		PyModule_AddObject(module_glm, "bvec4", (PyObject *)&hbvec4Type);

		return module_glm;
	}
}